<!doctype html><html lang=zh-cn data-figures=true class=page data-mode=lit><head><title>FFmpeg文档 | X•O专业去码</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta http-equiv=x-ua-compatible content="IE=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=XXXXXXXXXX"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","XXXXXXXXXX")</script><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta name=description content="Article description."><meta name=twitter:card content="summary"><meta name=twitter:creator content="@janedoe"><meta name=twitter:title content="FFmpeg文档"><meta property="og:url" content="https://b9aobj.github.io/post/zh-cn/2020/ffmpeg%E6%96%87%E6%A1%A3/"><meta property="og:title" content="FFmpeg文档"><meta property="og:description" content="Article description."><meta property="og:image" content="https://b9aobj.github.io/images/path/share.png"><link rel=apple-touch-icon sizes=180x180 href=https://b9aobj.github.io/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://b9aobj.github.io/icons/favicon-32x32.png><link rel=manifest href=https://b9aobj.github.io/icons/site.webmanifest><link rel=canonical href=https://b9aobj.github.io/post/zh-cn/2020/ffmpeg%E6%96%87%E6%A1%A3/><link rel=preload href=https://b9aobj.github.io/css/styles.72a67e58db00d351a932a445418818833ed2d333f3ffdbc0cacc9ba359c23a49dbad141eab8535b88bca7bbd7b983cb841034fe19dff757d16850f3989fef915.css integrity="sha512-cqZ+WNsA01GpMqRFQYgYgz7S0zPz/9vAysybo1nCOknbrRQeq4U1uIvKe717mDy4QQNP4Z3/dX0WhQ85if75FQ==" as=style crossorigin=anonymous><link rel=preload href=https://b9aobj.github.io/js/bundle.min.d0f0362720d4ba914aa22c906d463694ca5445a70923037ec128f108cf4616c6df3dba89902f7d6b8b123a359aaf0485763117871aa780a561c563ed6adfda0e.js as=script integrity="sha512-0PA2JyDUupFKoiyQbUY2lMpURacJIwN+wSjxCM9GFsbfPbqJkC99a4sSOjWarwSFdjEXhxqngKVhxWPtat/aDg==" crossorigin=anonymous><link rel=stylesheet type=text/css href=https://b9aobj.github.io/css/styles.72a67e58db00d351a932a445418818833ed2d333f3ffdbc0cacc9ba359c23a49dbad141eab8535b88bca7bbd7b983cb841034fe19dff757d16850f3989fef915.css integrity="sha512-cqZ+WNsA01GpMqRFQYgYgz7S0zPz/9vAysybo1nCOknbrRQeq4U1uIvKe717mDy4QQNP4Z3/dX0WhQ85if75FQ==" crossorigin=anonymous></head><body data-code=10 data-lines=false id=documentTop><header class=nav_header><nav class=nav><a href=https://b9aobj.github.io/ class="nav_brand nav_item" title=X•O专业去码><img src=https://b9aobj.github.io/logos/logo.png class=logo alt=X•O专业去码><div class=nav_close><div><svg class="icon"><use xlink:href="#open-menu"/></svg><svg class="icon"><use xlink:href="#closeme"/></svg></div></div></a><div class="nav_body nav_body_left"><div class=nav_parent><a href=https://b9aobj.github.io/ class=nav_item title=主页>主页</a></div><div class=nav_parent><a href=https://b9aobj.github.io/post/rich-content/ class=nav_item title=归档>归档</a></div><div class=nav_parent><a href=https://b9aobj.github.io/ class=nav_item title=个人链>个人链 <img src=https://b9aobj.github.io/icons/caret-icon.svg alt=icon class=nav_icon></a><div class=nav_sub><span class=nav_child></span>
<a href=https://www.linkedin.com/ class="nav_child nav_item" title=LinkedIn>LinkedIn</a>
<a href=https://twitter.com/ class="nav_child nav_item" title=Twitter>Twitter</a></div></div><div class=nav_parent><a href=https://b9aobj.github.io/about/ class=nav_item title=关于>关于</a></div><div class=nav_parent><a href=# class=nav_item>🌐</a><div class=nav_sub><span class=nav_child></span>
<a href=https://b9aobj.github.io/ class="nav_child nav_item">中文</a>
<a href=https://b9aobj.github.io/pt/ class="nav_child nav_item">Português</a>
<a href=https://b9aobj.github.io/en/ class="nav_child nav_item">English</a></div></div><div class=follow><a href=https://github.com/#><svg class="icon"><use xlink:href="#github"/></svg></a><a href=https://twitter.com/#><svg class="icon"><use xlink:href="#twitter"/></svg></a><a href=https://www.linkedin.com/in/#><svg class="icon"><use xlink:href="#linkedin"/></svg></a><a href=https://b9aobj.github.io/index.xml><svg class="icon"><use xlink:href="#rss"/></svg></a><div class=color_mode><input type=checkbox class=color_choice id=mode></div></div></div></nav></header><main><div class="grid-inverse wrap content"><article class=post_content><h1 class=post_title>FFmpeg文档</h1><div class=post_meta><span><svg class="icon"><use xlink:href="#calendar"/></svg></span><span class=post_date>May 12, 2021</span>
<span class=post_time>· 258 min read</span><span>&nbsp;· <a href=https://b9aobj.github.io/tags/ffmpeg title=ffmpeg class="post_tag button button_translucent">ffmpeg
</a><a href=https://b9aobj.github.io/tags/video title=video class="post_tag button button_translucent">video
</a><a href=https://b9aobj.github.io/tags/audio title=audio class="post_tag button button_translucent">audio</a></span>
<span class=page_only>&nbsp;·<div class=post_share>分享到:
<a href="https://twitter.com/intent/tweet?text=FFmpeg%e6%96%87%e6%a1%a3&url=https%3a%2f%2fb9aobj.github.io%2fpost%2fzh-cn%2f2020%2fffmpeg%25E6%2596%2587%25E6%25A1%25A3%2f&tw_p=tweetbutton" class=twitter title="分享到 Twitter" target=_blank rel=nofollow><svg class="icon"><use xlink:href="#twitter"/></svg></a><a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fb9aobj.github.io%2fpost%2fzh-cn%2f2020%2fffmpeg%25E6%2596%2587%25E6%25A1%25A3%2f&t=FFmpeg%e6%96%87%e6%a1%a3" class=facebook title="分享到 Facebook" target=_blank rel=nofollow><svg class="icon"><use xlink:href="#facebook"/></svg></a><a href=#linkedinshare id=linkedinshare class=linkedin title="分享到 LinkedIn" rel=nofollow><svg class="icon"><use xlink:href="#linkedin"/></svg></a><a href=https://b9aobj.github.io/post/zh-cn/2020/ffmpeg%E6%96%87%E6%A1%A3/ title="Copy Link" class="link link_yank"><svg class="icon"><use xlink:href="#copy"/></svg></a></div></span></div><p><strong>目录</strong></p><p><a href=#_Toc32313>第一章 多媒体概念介绍 6</a></p><p><a href=#_Toc17137>1.1视频格式 6</a></p><p><a href=#_Toc12689>1.1.1常见格式 6</a></p><p><a href=#_Toc2251>1.2音频格式 9</a></p><p><a href=#_Toc19841>1.2.1常见格式 9</a></p><p><a href=#_Toc17696>1.2.2比较 15</a></p><p><a href=#_Toc24108>1.3字幕格式 15</a></p><p><a href=#_Toc24511>1.3.1外挂字幕与内嵌字幕的阐述 15</a></p><p><a href=#_Toc20370>1.3.2外挂字幕视频与内嵌字幕视频的画面比较 15</a></p><p><a href=#_Toc21096>1.3.3外挂字幕的三种格式 15</a></p><p><a href=#_Toc811>1.4采集录制和播放渲染 16</a></p><p><a href=#_Toc29826>1.4.1视频采集 16</a></p><p><a href=#_Toc18251>1.4.2视频录制 17</a></p><p><a href=#_Toc1398>1.4.3视频渲染 17</a></p><p><a href=#_Toc26258>1.5编解码器 18</a></p><p><a href=#_Toc29396>1.6容器和协议 19</a></p><p><a href=#_Toc30715>1.6.1容器格式和编码格式 19</a></p><p><a href=#_Toc175>1.6.2协议 26</a></p><p><a href=#_Toc7240>1.6.2.1 视频协议 26</a></p><p><a href=#_Toc28117>1.6.2.2 音频协议. 26</a></p><p><a href=#_Toc31701>1.6.2.3 上层通讯协议 27</a></p><p><a href=#_Toc15054>1.7常用概念介绍 27</a></p><p><a href=#_Toc12325>1.7.1硬解 27</a></p><p><a href=#_Toc12743>1.7.2 IBP帧 28</a></p><p><a href=#_Toc24222>1.7.3 DTS和PTS 31</a></p><p><a href=#_Toc32463>1.7.4 分辨率 31</a></p><p><a href=#_Toc13900>1.7.5 码率 32</a></p><p><a href=#_Toc25366>1.7.6 帧率 32</a></p><p><a href=#_Toc20649>1.7.7 RGB和YUV 32</a></p><p><a href=#_Toc8973>1.7.8 实时和非实时 32</a></p><p><a href=#_Toc13755>1.7.9 复合视频和s-video 32</a></p><p><a href=#_Toc3733>1.7.10 硬件加速 32</a></p><p><a href=#_Toc1541>1.7.11 FFmpeg Device 32</a></p><p><a href=#_Toc15271>第二章 FFmpeg框架 34</a></p><p><a href=#_Toc8480>2.1 FFmpeg概述 34</a></p><p><a href=#_Toc3851>2.1.1简介 34</a></p><p><a href=#_Toc5621>2.1.2功能 34</a></p><p><a href=#_Toc19495>2.1.3模块组成 35</a></p><p><a href=#_Toc20974>2.1.4命令集 35</a></p><p><a href=#_Toc27630>2.2 媒体播放器三大底层框架 37</a></p><p><a href=#_Toc28320>第三章 编译及简单应用 41</a></p><p><a href=#_Toc15462>3.1 FFmpeg库编译和入门介绍 41 41</a></p><p><a href=#_Toc14769>3.2 流媒体数据流程讲解 49</a></p><p><a href=#_Toc5486>3.3 简单应用 51</a></p><p><a href=#_Toc12554>3.4 SDL（ Simple Direct Layer） 55</a></p><p><a href=#_Toc5290>3.4.1 SDL显示视频 55</a></p><p><a href=#_Toc15775>3.4.2 SDL显示音频 55</a></p><p><a href=#_Toc8630>3.5 ffmpeg程序的使用（ffmpeg.exe，ffplay.exe，ffprobe.exe） 56</a></p><p><a href=#_Toc2371>3.5.1 ffmpeg.exe 56</a></p><p><a href=#_Toc17682>3.5.2 ffplay.exe 56</a></p><p><a href=#_Toc28783>3.5.3 ffprobe.exe 56</a></p><p><a href=#_Toc28526>第四章 数据结构 57</a></p><p><a href=#_Toc22239>4.1 AVCodec结构体 59</a></p><p><a href=#_Toc31796>4.2 AVCodecContext结构体 59</a></p><p><a href=#_Toc7790>4.3 AVInputFormat结构体 60</a></p><p><a href=#_Toc20868>4.4 AVFormatContext结构体 61</a></p><p><a href=#_Toc14757>4.5 MovContext结构体 62</a></p><p><a href=#_Toc20740>4.6 URLProtocol结构体 62</a></p><p><a href=#_Toc24527>4.7 URLContext结构体 63</a></p><p><a href=#_Toc10284>4.8 AVIOContext结构体(老版本为：ByteIOContext) 63</a></p><p><a href=#_Toc22156>4.9 AVStream结构体 64</a></p><p><a href=#_Toc17400>4.10 MOVStreamContext 结构体 65</a></p><p><a href=#_Toc9538>4.11 AVPacket 结构体 66</a></p><p><a href=#_Toc2853>4.12 AVPacketList 结构体 67</a></p><p><a href=#_Toc26851>4.13 AVFrame结构体 67</a></p><p><a href=#_Toc23401>第五章 重要模块 76</a></p><p><a href=#_Toc29385>5.1 libavutil公共模块 76</a></p><p><a href=#_Toc26942>1 文件列表 76</a></p><p><a href=#_Toc29647>2 common.h 文件 76</a></p><p><a href=#_Toc24381>3 bswap.h 文件 78</a></p><p><a href=#_Toc15559>4 rational.h 文件 79</a></p><p><a href=#_Toc16666>5 mathematics.h 文件 80</a></p><p><a href=#_Toc10234>6 avutil.h 文件 80</a></p><p><a href=#_Toc30659>5.2 libavcodec编解码模块 82</a></p><p><a href=#_Toc7002>1 文件列表 82</a></p><p><a href=#_Toc22320>2 avcodec.h 文件 82</a></p><p><a href=#_Toc20874>3 allcodec.c 文件 87</a></p><p><a href=#_Toc13278>4 dsputil.h 文件 87</a></p><p><a href=#_Toc18411>5 dsputil.c 文件 88</a></p><p><a href=#_Toc3349>6 utils_codec.c 文件 88</a></p><p><a href=#_Toc25168>7 imgconvert_template.h 文件 99</a></p><p><a href=#_Toc14950>8 imgconvert.c 文件 121</a></p><p><a href=#_Toc6404>9 msrle.c 文件 164</a></p><p><a href=#_Toc15870>10 turespeech_data.h 文件 171</a></p><p><a href=#_Toc27714>11 turespeech.c 文件 174</a></p><p><a href=#_Toc10955>5.3 libavformat容器模块 184</a></p><p><a href=#_Toc28769>1 文件列表 184</a></p><p><a href=#_Toc17537>2 avformat.h 文件 184</a></p><p><a href=#_Toc8236>3 allformat.c 文件 190</a></p><p><a href=#_Toc28923>4 cutils.c 文件 190</a></p><p><a href=#_Toc20297>5 file.c 文件 192</a></p><p><a href=#_Toc3483>6 avio.h 文件 194</a></p><p><a href=#_Toc9378>7 avio.c 文件 196</a></p><p><a href=#_Toc4230>8 aviobuf.c 文件 200</a></p><p><a href=#_Toc1311>9 utils_format.c 文件 209</a></p><p><a href=#_Toc23799>10 avidec.c 文件 220</a></p><p><a href=#_Toc22841>5.4 libswscale视频色彩空间转换 243</a></p><p><a href=#_Toc11008>5.5 libswresample音频重采样 243</a></p><p><a href=#_Toc11316>5.6 libavfilter音视频滤器 243</a></p><p><a href=#_Toc9837>5.7 libavdevice设备输入和输出容器 243</a></p><p><a href=#_Toc23031>5.8 libpostproc视频后期处理 243</a></p><p><a href=#_Toc17832>第六章 播放器 243</a></p><p><a href=#_Toc26847>6.1 视频播放器 243</a></p><p><a href=#_Toc8394>6.1.1 ffmpeg库的配置 243</a></p><p><a href=#_Toc22279>6.1.2 一个简单的视频播放器 244</a></p><p><a href=#_Toc4678>6.2 音频播放器 247</a></p><p><a href=#_Toc7888>6.3 一个完整的播放器--ffplay 253</a></p><p><a href=#_Toc30159>6.3.1 ffplay流程图 253</a></p><p><a href=#_Toc5297>6.3.2 ffplay源码剖析 254</a></p><p><a href=#_Toc16218>第七章 应用开发 275</a></p><p><a href=#_Toc4257>7.1 ffmpeg库的使用：编码 275</a></p><p><a href=#_Toc13180>第八章 关键函数介绍 280</a></p><p><a href=#_Toc10122>8.1 avformat_open_input 280</a></p><p><a href=#_Toc4978>8.2 avcodec_register_all() 281</a></p><p><a href=#_Toc7598>8.3 av_read_frame() 283</a></p><p><a href=#_Toc25230>8.4 avcodec_decode_video2() 283</a></p><p><a href=#_Toc16616>8.5 transcode_init() 283</a></p><p><a href=#_Toc22492>8.6 transcode() 294</a></p><p><a href=#_Toc4647>第九章 ffmpeg相关工程 301</a></p><p><a href=#_Toc26182>9.1 ffdshow 301</a></p><p><a href=#_Toc8089>ffdshow 源代码分析1 ： 整体结构 302</a></p><p><a href=#_Toc22141>ffdshow 源代码分析 2： 位图覆盖滤镜（对话框部分Dialog） 304</a></p><p><a href=#_Toc15715>ffdshow 源代码分析 3： 位图覆盖滤镜（设置部分Settings） 312</a></p><p><a href=#_Toc2412>ffdshow 源代码分析 4： 位图覆盖滤镜（滤镜部分Filter） 317</a></p><p><a href=#_Toc30933>ffdshow 源代码分析 5： 位图覆盖滤镜（总结） 322</a></p><p><a href=#_Toc28417>ffdshow 源代码分析 6： 对解码器的dll的封装（libavcodec） 322</a></p><p><a href=#_Toc17015>ffdshow 源代码分析 8： 视频解码器类（TvideoCodecDec） 344</a></p><p><a href=#_Toc23700>ffdshow 源代码分析 9： 编解码器有关类的总结 352</a></p><p><a href=#_Toc28016>9.2 LAV filters 357</a></p><p><a href=#_Toc1845>LAV Filter 源代码分析 1： 总体结构 357</a></p><p><a href=#_Toc22280>LAV Filter 源代码分析 2： LAV Splitter 358</a></p><p><a href=#_Toc18848>LAV Filter 源代码分析 3： LAV Video （1） 382</a></p><p><a href=#_Toc24404>LAV Filter 源代码分析 4： LAV Video （2） 400</a></p><p><a href=#_Toc23216>9.3 MPlayer 427</a></p><p><a href=#_Toc25693>9.3.1 Mplayer支持的格式 427</a></p><p><a href=#_Toc134>9.3.2 Mplayer 中头文件的功能分析 427</a></p><p><a href=#_Toc15151>9.3.3 MPlayer.main 主流程简要说明 428</a></p><p><a href=#_Toc28089>9.3.4 Mplayer源码分析 429</a></p><p><a href=#_Toc16056>第十章 开发实例 436</a></p><p><a href=#_Toc8531>第十一章 mp4文件封装协议分析 436</a></p><p><a href=#_Toc2665>11.1 概述 436</a></p><p><a href=#_Toc10085>11.2 mp4的物理结构 436</a></p><p><a href=#_Toc26343>11.3 数据的组织结构 437</a></p><p><a href=#_Toc18288>11.4 mp4的时间结构 437</a></p><p><a href=#_Toc24921>11.5 文件结构分析 438</a></p><p><a href=#_Toc22272>11.5.1 File Type Box（ftyp） 438</a></p><p><a href=#_Toc2582>11.5.2 Movie Box（moov） 438</a></p><p><a href=#_Toc23076>第十二章 flv 文件格式分析 457</a></p><p><a href=#_Toc32184>12.1 概述 457</a></p><p><a href=#_Toc10414>12.2 文件总体结构 457</a></p><p><a href=#_Toc13287>12.3 文件结构分析 458</a></p><p><a href=#_Toc18011>12.3.1 flv文件头的结构 458</a></p><p><a href=#_Toc10582>12.3.2 body主体结构 459</a></p><p><a href=#_Toc19794>附录A：常见问题 465</a></p><p><a href=#_Toc26309>1 ffmpeg 从内存中读取数据 465</a></p><p><a href=#_Toc1446>2 MFC中使用SDL播放音频没有声音的解决方法 465</a></p><p><a href=#_Toc13579>附录B：经典代码示例 466</a></p><p><a href=#_Toc22959>附录c：ffmpeg参数中文详细解释 477</a></p><p><a href=#_Toc3701>附录D：ffplay的快捷键以及选项 479</a></p><p><a href=#_Toc5762>附录E： ffmpeg处理rtmp流媒体 481</a></p><h1 id=第一章-多媒体概念介绍><strong>第一章 多媒体概念介绍</strong></h1><h2 id=11视频格式><strong>1.1视频格式</strong></h2><p>视频格式可以分为适合本地播放的本地影像视频和适合在网络中播放的网络流媒体影像视频两大类。尽管后者在播放的稳定性和播放画面质量上可能没有前者优秀，但网络流媒体影像视频的广泛传播性使之正被广泛应用于视频点播、网络演示、远程教育、网络视频广告等等互联网信息服务领域。</p><p>注：原始的视频数据可以理解为通过摄像头等驱动获取的没有经过编码的数据，市面上usb摄像头输出格式常见的有：RGB24、YUV2、YV2（这些都是没有编码的原始数据），MJPEG（经过编码的数据）。摄像头捕捉的数据也是可以设置的，比如windows下用cap来设置。</p><h3 id=111常见格式><strong>1.1.1常见格式</strong></h3><p><a href=http://baike.baidu.com/view/7689.htm>**MPEG</a><strong>/<a href=http://baike.baidu.com/view/7711.htm>MPG</a>/<a href=http://baike.baidu.com/view/387002.htm>DAT**</a></strong></p><p><a href=http://baike.baidu.com/view/7689.htm>MPEG</a>（运动图像专家组）是Motion Picture Experts Group 的缩写。这类格式包括了<a href=http://baike.baidu.com/view/7739.htm>MPEG-1</a>,<a href=http://baike.baidu.com/view/7747.htm>MPEG-2</a>和<a href=http://baike.baidu.com/view/7754.htm>MPEG-4</a>在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为其正在被广泛地应用在VCD 的制作和一些视频片段下载的网络应用上面，大部分的<a href=http://baike.baidu.com/view/7313.htm>VCD</a>都是用MPEG1 格式压缩的( 刻录软件自动将MPEG1转换为DAT格式 ) ，使用MPEG-1 的压缩算法，可以把一部120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2 则是应用在DVD 的制作，同时在一些<a href=http://baike.baidu.com/view/8295.htm>HDTV</a>（高清晰电视广播）和一些高要求<a href=http://baike.baidu.com/view/2795688.htm>视频编辑</a>、处理上面也有相当多的应用。使用MPEG-2 的压缩算法压缩一部120 分钟长的电影可以压缩到5-8 GB 的大小（MPEG2的图像质量是MPEG-1 无法比拟的）。MPEG系列标准已成为国际上影响最大的<a href=http://baike.baidu.com/view/3323.htm>多媒体</a><a href=http://baike.baidu.com/view/9164.htm>技术标准</a>，其中MPEG-1和MPEG-2是采用相同原理为基础的<a href=http://baike.baidu.com/view/1051749.htm>预测编码</a>、变换编码、<a href=http://baike.baidu.com/view/182718.htm>熵编码</a>及运动补偿等第一代数据压缩编码技术；MPEG-4（ISO/IEC 14496）则是基于第二代压缩编码技术制定的国际标准，它以视听媒体对象为<a href=http://baike.baidu.com/view/693012.htm>基本单元</a>，采用基于内容的压缩编码，以实现数字视音频、图形合成应用及交互式多媒体的集成。MPEG系列标准对VCD、DVD等视听消费电子及数字电视和<a href=http://baike.baidu.com/view/70858.htm>高清晰度电视</a>（DTV&&HDTV）、<a href=http://baike.baidu.com/view/3323.htm>多媒体</a>通信等信息产业的发展产生了巨大而深远的影响。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.001.jpeg alt=视频格式 title=cc11728b4710b912cd01005cc3fdfc039345224b></p><p><a href=http://baike.baidu.com/view/7697.htm><strong>AVI</strong></a></p><p><a href=http://baike.baidu.com/view/7697.htm>AVI</a>，音频视频交错(Audio Video Interleaved)的英文缩写。AVI这个由<a href=http://baike.baidu.com/view/39784.htm>微软公司</a>发表的视频格式，在视频领域可以说是最悠久的格式之一。AVI格式调用方便、图像质量好，压缩标准可任意选择，是应用最广泛、也是应用时间最长的格式之一。</p><p><a href=http://baike.baidu.com/view/7723.htm>MOV</a></p><p>使用过<a href=http://baike.baidu.com/view/32702.htm>Mac</a>机的朋友应该多少接触过<a href=http://baike.baidu.com/view/196819.htm>QuickTime</a>。QuickTime原本是<a href=http://baike.baidu.com/view/14874.htm>Apple</a>公司用于Mac<a href=http://baike.baidu.com/view/3314.htm>计算机</a>上的一种图像<a href=http://baike.baidu.com/view/2792642.htm>视频处理</a>软件。Quick-Time提供了两种标准图像和<a href=http://baike.baidu.com/view/257435.htm>数字视频</a>格式, 即可以支持静态的*.PIC和*.JPG图像格式，动态的基于Indeo压缩法的*.MOV和基于MPEG压缩法的*.MPG视频格式。</p><p><a href=http://baike.baidu.com/view/7704.htm><strong>ASF</strong></a></p><p><a href=http://baike.baidu.com/view/7704.htm>ASF</a>(Advanced Streaming format高级流格式)。ASF 是MICROSOFT 为了和的Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件<a href=http://baike.baidu.com/view/2954654.htm>压缩格式</a>。ASF使用了MPEG4 的压缩算法，压缩率和图像的质量都很不错。因为ASF 是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD 差一点点并不出奇，但比同是视频“流”格式的RAM 格式要好。</p><p><a href=http://baike.baidu.com/view/66019.htm><strong>WMV</strong></a></p><p>一种独立于编码方式的在Internet上实时传播<a href=http://baike.baidu.com/view/3323.htm>多媒体</a>的<a href=http://baike.baidu.com/view/9164.htm>技术标准</a>，<a href=http://baike.baidu.com/view/2422.htm>Microsoft</a>公司希望用其取代<a href=http://baike.baidu.com/view/196819.htm>QuickTime</a>之类的技术标准以及WAV、AVI之类的文件扩展名。<a href=http://baike.baidu.com/view/66019.htm>WMV</a>的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。</p><p><a href=http://baike.baidu.com/view/45888.htm><strong>NAVI</strong></a></p><p>如果发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm 的地下组织发展起来的一种新视频格式。它是由Microsoft ASF 压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以 NAVI 为了追求这个目标，改善了原始的ASF 格式的一些不足，让NAVI 可以拥有更高的帧率。可以这样说，NAVI 是一种去掉视频流特性的改良型ASF 格式。</p><p><a href=http://baike.baidu.com/view/7077.htm><strong>3GP</strong></a></p><p><a href=http://baike.baidu.com/view/7077.htm>3GP</a>是一种3G流媒体的<a href=http://baike.baidu.com/view/746807.htm>视频编码</a>格式，主要是为了配合3G网络的高传输速度而开发的，也是目前手机中最为常见的一种视频格式。</p><p>简单的说，该格式是“第三代合作伙伴项目”(3GPP)制定的一种<a href=http://baike.baidu.com/view/3323.htm>多媒体</a>标准，使用户能使用手机享受高质量的视频、音频等多媒体内容。其核心由包括高级<a href=http://baike.baidu.com/view/1531030.htm>音频编码</a>(AAC)、自适应多速率 (AMR) 和MPEG-4 和H.263<a href=http://baike.baidu.com/view/746807.htm>视频编码</a><a href=http://baike.baidu.com/view/1079.htm>解码器</a>等组成，目前大部分支持视频拍摄的手机都支持3GPP格式的视频播放。其特点是网速占用较少，但画质较差。</p><p><a href=http://baike.baidu.com/view/18083.htm><strong>REAL VIDEO</strong></a></p><p><a href=http://baike.baidu.com/view/18083.htm>REAL VIDEO</a>（<a href=http://baike.baidu.com/view/288774.htm>RA</a>、<a href=http://baike.baidu.com/view/3558.htm>RAM</a>）格式由一开始就是定位在<a href=http://baike.baidu.com/view/2722588.htm>视频流</a>应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，当然，其图像质量和<a href=http://baike.baidu.com/view/89020.htm>MPEG2</a>、<a href=http://baike.baidu.com/view/7716.htm>DIVX</a>等比是不敢恭维的啦。毕竟要实现在网上传输不间断的视频是需要很大的<a href=http://baike.baidu.com/view/632842.htm>频宽</a>的，这方面是<a href=http://baike.baidu.com/view/7704.htm>ASF</a>的有力竞争者。</p><p><a href=http://baike.baidu.com/view/91917.htm><strong>MKV</strong></a></p><p>一种后缀为<a href=http://baike.baidu.com/view/91917.htm>MKV</a>的视频文件频频出现在网络上，它可在一个文件中集成多条不同类型的音轨和字幕轨，而且其<a href=http://baike.baidu.com/view/746807.htm>视频编码</a>的自由度也非常大，可以是常见的<a href=http://baike.baidu.com/view/7716.htm>DivX</a>、<a href=http://baike.baidu.com/view/30246.htm>XviD</a>、3IVX，甚至可以是RealVideo、QuickTime、WMV 这类流式视频。实际上，它是一种全称为Matroska的新型<a href=http://baike.baidu.com/view/3323.htm>多媒体</a><a href=http://baike.baidu.com/view/1942911.htm>封装格式</a>，这种先进的、开放的封装格式已经给我们展示出非常好的应用前景。</p><p><a href=http://baike.baidu.com/view/364757.htm><strong>FLV</strong></a></p><p><a href=http://baike.baidu.com/view/364757.htm>FLV</a>是FLASH VIDEO的简称，FLV<a href=http://baike.baidu.com/view/794.htm>流媒体</a>格式是一种新的视频格式。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入<a href=http://baike.baidu.com/view/7641.htm>Flash</a>后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。</p><p><a href=http://baike.baidu.com/view/2302577.htm><strong>F4V</strong></a></p><p>作为一种更小更清晰，更利于在网络传播的格式，<a href=http://baike.baidu.com/view/2302577.htm>F4V</a>已经逐渐取代了传统<a href=http://baike.baidu.com/view/364757.htm>FLV</a>，也已经被大多数主流播放器兼容播放，而不需要通过转换等复杂的方式。F4V是<a href=http://baike.baidu.com/view/7578.htm>Adobe</a>公司为了迎接<a href=http://baike.baidu.com/view/752328.htm>高清</a>时代而推出继FLV格式后的支持H.264的F4V<a href=http://baike.baidu.com/view/794.htm>流媒体</a>格式。它和FLV主要的区别在于，FLV格式采用的是H263编码，而F4V则支持H.264编码的高清晰视频，码率最高可达50Mbps。也就是说F4V和FLV在同等体积的前提下，能够实现更高的分辨率，并支持更高比特率，就是我们所说的更清晰更流畅。另外，很多主流媒体网站上下载的F4V文件后缀却为FLV，这是F4V格式的另一个特点，属正常现象，观看时可明显感觉到这种实为F4V的FLV有明显更高的清晰度和流畅度。</p><p><a href=http://baike.baidu.com/view/8680.htm><strong>RMVB</strong></a></p><p>RMVB的前身为RM格式，它们是<a href=http://baike.baidu.com/view/1617391.htm>Real Networks</a>公司所制定的音频视频压缩规范，根据不同的<a href=http://baike.baidu.com/view/2381438.htm>网络传输速率</a>，而制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放，具有体积小，画质也还不错的优点。</p><p>早期的RM格式为了能够实现在有限带宽的情况下，进行视频在线播放而被研发出来，并一度红遍整个互联网。而为了实现更优化的体积与画面质量，Real Networks公司不久又在RM的基础上，推出了<a href=http://baike.baidu.com/view/656405.htm>可变比特率</a>编码的RMVB格式。RMVB的诞生，打破了原先RM格式那种平均压缩采样的方式，在保证平均压缩比的基础上，采用浮动比特率编码的方式，将较高的比特率用于复杂的动态画面（如歌舞、飞车、战争等），而在静态画面中则灵活地转为较低的采样率，从而合理地利用了比特率资源，使RMVB最大限度地压缩了影片的大小，最终拥有了近乎完美的接近于DVD品质的视听效果。我们可以做个简单对比，一般而言一部120分钟的dvd体积为4GB，而rmvb格式来压缩，仅400MB左右，而且清晰度流畅度并不比原DVD差太远。</p><p>人们为了缩短视频文件在网络进行传播的下载时间，为了节约用户<a href=http://baike.baidu.com/view/2074271.htm>电脑硬盘</a>宝贵的空间容量，已越来越多的视频被压制成了RMVB格式，并广为流传。到如今，可能每一位电脑使用者（或许就包括正在阅读这篇文章的您）电脑中的视频文件，超过80%都会是RMVB格式。</p><p>RMVB由于本身的优势，成为目前PC中最广泛存在的视频格式，但在<a href=http://baike.baidu.com/view/42387.htm>MP4播放器</a>中，RMVB格式却长期得不到重视。MP4发展的整整七个年头里，虽然早就可以做到完美支持<a href=http://baike.baidu.com/view/725802.htm>AVI格式</a>，但却久久未有能够完全兼容RMVB格式的机型诞生。对于MP4，尤其是容量小价格便宜的<a href=http://baike.baidu.com/view/1371.htm>闪存</a>MP4而言，怎样的视频格式才将会是其未来的主流呢？我们不妨来探讨一番。</p><p><a href=http://baike.baidu.com/view/3655243.htm><strong>WebM</strong></a></p><p>由Google提出，是一个开放、免费的媒体<a href=http://baike.baidu.com/view/1066926.htm>文件格式</a>。WebM 影片格式其实是以 Matroska（即 MKV）容器格式为基础开发的新容器格式，里面包括了 VP8 影片轨和 Ogg Vorbis 音轨，其中Google将其拥有的VP8<a href=http://baike.baidu.com/view/746807.htm>视频编码</a>技术以类似BSD授权开源，Ogg Vorbis 本来就是开放格式。 WebM标准的<a href=http://baike.baidu.com/view/94301.htm>网络视频</a>更加偏向于开源并且是基于HTML5标准的，WebM 项目旨在为对每个人都开放的网络开发高质量、开放的视频格式，其重点是解决视频服务这一核心的网络用户体验。Google 说 WebM 的格式相当有效率，应该可以在 netbook、tablet、手持式装置等上面顺畅地使用。</p><p>Ogg Vorbis 本来就是开放格式，大家应该都知道，至于 VP8 则是 Google 当年买下一间叫 On2 的公司的时候，取得的 Video Codec， Google 也把这个 Codec 以类似 BSD 授权放出来，因此 WebM 应该是不会有 H.264 的那些潜在的专利问题。</p><p>Youtube 也会支持 WebM 的播放。来自产业界的有 Adobe -- Flash Player 将会支持 WebM 格式的播放 -- AMD、ARM、Broadcom、Freescale、NVIDIA、Qualcomm、TI 等。谁不在上头？Intel。在 Browser 方面，Chrome 不要说，Firefox、Opera 都已经表态将会支持这个新格式。微软IE9 的支持就没这么直接，出厂时仅会支持 H.264 影片的播放，但如果你另外下载并安装了 VP8，那当然你也可以播放 HTML / VP8 的影片。 　要推动一个新格式进入主流，甚至成为龙头老大，是非常不容易的。但 WebM 和 VP8 的推动者是 Google，而且是在 H.264 正因为其非开放性而备受质疑的时候，或许 WebM 真有机会迅速地站稳脚跟，一举成为新一代的影片通用格式呢！</p><h2 id=12音频格式><strong>1.2音频格式</strong></h2><p>音频格式是指要在计算机内播放或是处理音频文件，也就是要对声音文件进行数、模转换，这个过程同样由采样和量化构成，人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，20KHz以上人耳是听不到的，因此音频文件格式的最大带宽是20KHZ，故而采样速率需要介于40~50KHZ之间，而且对每个样本需要更多的量化比特数。音频数字化的标准是每个样本16位-96dB的信噪比，采用线性脉冲编码调制PCM，每一量化步长都具有相等的长度。在音频文件的制作中，正是采用这一标准。</p><h3 id=121常见格式><strong>1.2.1常见格式</strong></h3><p>常见的音频格式有：CD格式、WAVE（*.WAV）、AIFF、AU、MP3、MIDI、WMA、RealAudio、VQF、OggVorbis、AAC、APE。</p><p><strong>CD</strong></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.002.png alt></p><p>CD格式的音质是比较高的音频格式。因此要讲音频格式，CD自然是打头阵的先锋。在大多数播放软件的“打开文件类型”中，都可以看到*.cda格式，这就是CD音轨了。标准CD格式也就是44.1K的采样频率，速率88K/秒，16位量化位数，因为CD音轨可以说是近似无损的，因此它的声音基本上是忠于原声的，因此如果你是一个音响发烧友的话，CD是你的首选。它会让你感受到天籁之音。CD光盘可以在CD唱机中播放，也能用电脑里的各种播放软件来重放。一个CD音频文件是一个*.cda文件，这只是一个索引信息，并不是真正的包含声音信息，所以不论CD音乐的长短，在电脑上看到的“*.cda文件”都是44字节长。注意：不能直接的复制CD格式的*.cda文件到硬盘上播放，需要使用象EAC这样的抓音轨软件把CD格式的文件转换成WAV，这个转换过程如果光盘驱动器质量过关而且EAC的参数设置得当的话，可以说是基本上无损抓音频。推荐大家使用这种方法。</p><p><strong>WAVE</strong></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.003.png alt></p><p>WAVE（*.WAV）是微软公司开发的一种声音文件格式，它符合PIFFResource Interchange File Format 文件规范，用于保存WINDOWS平台的音频信息资源，被WINDOWS平台及其应用程序所支持。“*.WAV”格式支持MSADPCM、CCITT A LAW等多种压缩算法，支持多种音频位数、采样频率和声道，标准格式的WAV文件和CD格式一样，也是44.1K的采样频率，速率88K/秒，16位量化位数，看到了吧，WAV格式的声音文件质量和CD相差无几，也是目前PC机上广为流行的声音文件格式，几乎所有的音频编辑软件都“认识”WAV格式。</p><p><strong>AIFF</strong></p><p>AIFF（Audio Interchange File Format）格式和AU格式，它们都和WAV非常相像，在大多数的音频编辑软件中也都支持它们这几种常见的音乐格式。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.004.png alt></p><p>AIFF是音频交换文件格式的英文缩写。是APPLE公司开发的一种音频文件格式，被MACINTOSH平台及其应用程序所支持，NETSCAPE浏览器中LIVEAUDIO也支持AIFF格式。所以大家都不常见。AIFF是Apple苹果电脑上面的标准音频格式，属于QuickTime技术的一部分。这一格式的特点就是格式本身与数据的意义无关，因此受到了Microsoft的青睐，并据此搞出来WAV格式。AIFF虽然是一种很优秀的文件格式，但由于它是苹果电脑上的格式，因此在PC平台上并没有得到很大的流行。不过由于Apple电脑多用于多媒体制作出版行业，因此几乎所有的音频编辑软件和播放软件都或多或少地支持AIFF格式。只要苹果电脑还在，AIFF就始终还占有一席之地。由于AIFF的包容特性，所以它支持许多压缩技术。</p><p><strong>AU</strong></p><p>AUDIO文件是SUN公司推出的一种数字音频格式。AU文件原先是UNIX操作系统下的数字声音文件。由于早期INTERNET上的WEB服务器主要是基于UNIX的，所以，AU格式的文件在如今的INTERNET中也是常用的声音文件格式。</p><p>MPEG</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.005.png alt></p><p>MPEG是动态图象专家组的英文缩写。这个专家组始建于1988年，专门负责为CD建立视频和音频压缩标准。MPEG音频文件指的是MPEG标准中的声音部分即MPEG音频层。目前INTERNET上的音乐格式以MP3最为常见。虽然它是一种有损压缩，但是它的最大优势是以极小的声音失真换来了较高的压缩比。MPEG含有格式包括：MPEG-1、MPEG-2、MPEG-Layer3、MPEG-4</p><p><strong>MP3</strong></p><p>MP3格式诞生于八十年代的德国，所谓的MP3也就是指的是MPEG标准中的音频部分，也就是MPEG音频层。根据压缩质量和编码处理的不同分为3层，分别对应“*.mp1"/“*.mp2”/“*.mp3”这3种声音文件。需要提醒大家注意的地方是：MPEG音频文件的压缩是一种有损压缩，MPEG3音频编码具有10：1~12：1的高压缩率，同时基本保持低音频部分不失真，但是牺牲了声音文件中12KHz到16KHz高音频这部分的质量来换取文件的尺寸，相同长度的音乐文件，用*.mp3格式来储存，一般只有*.wav文件的1/10，而音质要次于CD格式或WAV格式的声音文件。由于其文件尺寸小，音质好；所以在它问世之初还没有什么别的音频格式可以与之匹敌，因而为*.mp3格式的发展提供了良好的条件。直到现在，这种格式还是风靡一时，作为主流音频格式的地位难以被撼动。但是树大招风，MP3音乐的版权问题也一直是找不到办法解决，因为MP3没有版权保护技术，说白了也就是谁都可以用。</p><p>MP3格式压缩音乐的采样频率有很多种，可以用64Kbps或更低的采样频率节省空间，也可以用320Kbps的标准达到极高的音质。用装有Fraunhofer IIS Mpeg Lyaer3的 MP3编码器（现在效果最好的编码器）MusicMatch Jukebox 6.0在128Kbps的频率下编码一首3分钟的歌曲，得到2.82MB的MP3文件。采用缺省的CBR（固定采样频率）技术可以以固定的频率采样一首歌曲，而VBR（可变采样频率）则可以在音乐“忙”的时候加大采样的频率获取更高的音质，不过产生的MP3文件可能在某些播放器上无法播放。把VBR的级别设定成为与前面的CBR文件的音质基本一样，生成的VBR MP3文件为2.9MB。</p><p>MP3是到2008年止使用用户最多的有损压缩数字音频格式了。它的全称是MPEG(MPEG：MovingPictureExpertsGroup)AudioLayer-3，刚出现时它的编码技术并不完善，它更像一个编码标准框架，留待人们去完善。早期的MP3编码采用的的是固定编码率的方式（CBR），看到的128KBPS，就是代表它是以128KBPS固定数据速率编码——你可以提高这个编码率，最高可以到320KBPS，音质会更好，自然，文件的体积会相应增大。</p><p>因为MP3的编码方式是开放的，可以在这个标准框架的基础上自己选择不同的声学原理进行压缩处理，所以，很快由Xing公司推出可变编码率的压缩方式（VBR）。它的原理就是利用将一首歌的复杂部分用高bitrate编码，简单部分用低bitrate编码，通过这种方式，进一步取得质量和体积的统一。当然，早期的Xing编码器的VBR算法很差，音质与CBR（固定码率）相去甚远。但是，这种算法指明了一种方向，其他开发者纷纷推出自己的VBR算法，使得效果一直在改进。目前公认比较好的首推LAME，它完美地实现了VBR算法，而且它是是完全免费的软件，并且由爱好者组成的开发团队一直在不断的发展完善。</p><p>而在VBR的基础上，LAME更加发展出ABR算法。ABR（AverageBitrate）平均比特率，是VBR的一种插值参数。LAME针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR在指定的文件大小内，以每50帧（30帧约1秒）为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量，可以做为VBR和CBR的一种折衷选择。</p><p>MP3问世不久，就凭这较高的压缩比12:1和较好的音质创造了一个全新的音乐领域，然而MP3的开放性却最终不可避免的导致了版权之争，在这样的背景之下，文件更小，音质更佳，同时还能有效保护版权的MP4就应运而生了。MP3和MP4之间其实并没有必然的联系，首先MP3是一种音频压缩的国际技术标准，而MP4却是一个商标的名称。</p><p><strong>MPEG-4</strong></p><p>MPEG-4标准是由国际运动图像专家组于2000年10月公布的一种面向多媒体应用的视频压缩标准。它采用了基于对象的压缩编码技术，在编码前首先对视频序列进行分析，从原始图像中分割出各个视频对象，然后再分别对每个视频对象的形状信息、运动信息、纹理信息单独编码，并通过比MPEG-2更优的运动预测和运动补偿来去除连续帧之间的时间冗余。其核心是基于内容的尺度可变性(Content-basedscalability)，可以对图像中各个对象分配优先级，对比较重要的对象用高的空间和时间分辨率表示，对不甚重要的对象(如监控系统的背景)以较低的分辨率表示，甚至不显示。因此它具有自适应调配资源能力，可以实现高质量低速率的图像通信和视频传输。 MPEG-4以其高质量、低传输速率等优点已经被广泛应用到网络多媒体、视频会议和多媒体监控等图像传输系统中。中国内外大部分成熟的MPEG-4应用均为基于PC层面的客户端和服务器模式，应用在嵌入式系统上的并不多，且多数嵌入式MPEG-4解码系统大多使用商业的嵌入式操作系统，如WindowsCE、VxWorks等，成本高、灵活性差。如以嵌入式Linux作为操作系统不仅开发方便，且可以节约成本，并可以根据实际情况进行裁减，占用资源少、灵活性强，网络性能好，适用范围更广。</p><p><strong>MIDI</strong></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.006.png alt></p><p>MIDI（Musical Instrument Digital Interface）格式被经常玩音乐的人使用，MIDI允许数字合成器和其他设备交换数据。MID文件格式由MIDI继承而来。MID文件并不是一段录制好的声音，而是记录声音的信息，然后在告诉声卡如何再现音乐的一组指令。这样一个MIDI文件每存1分钟的音乐只用大约5～10KB。MID文件主要用于原始乐器作品，流行歌曲的业余表演，游戏音轨以及电子贺卡等。*.mid文件重放的效果完全依赖声卡的档次。*.mid格式的最大用处是在电脑作曲领域。*.mid文件可以用作曲软件写出，也可以通过声卡的MIDI口把外接音序器演奏的乐曲输入电脑里，制成*.mid文件。</p><p><strong>WMA</strong></p><p>WMA (Windows Media Audio) 格式是来自于微软的重量级选手，后台强硬，音质要强于MP3格式，更远胜于RA格式，它和日本YAMAHA公司开发的VQF格式一样，是以减少数据流量但保持音质的方法来达到比MP3压缩率更高的目的，WMA的压缩率一般都可以达到1：18左右，WMA的另一个优点是内容提供商可以通过DRM（Digital Rights Management）方案如Windows Media Rights Manager 7加入防拷贝保护。这种内置了版权保护技术可以限制播放时间和播放次数甚至于播放的机器等等，这对被盗版搅得焦头乱额的音乐公司来说可是一个福音，另外WMA还支持音频流(Stream)技术，适合在网络上在线播放，作为微软抢占网络音乐的开路先锋可以说是技术领先、风头强劲，更方便的是不用象MP3那样需要安装额外的播放器，而Windows操作系统和Windows Media Player的无缝捆绑让你只要安装了windows操作系统就可以直接播放WMA音乐，新版本的Windows Media Player7.0更是增加了直接把CD光盘转换为WMA声音格式的功能，在新出品的操作系统Windows XP中，WMA是默认的编码格式，大家知道Netscape的遭遇，现在“狼”又来了。WMA这种格式在录制时可以对音质进行调节。同一格式，音质好的可与CD媲美，压缩率较高的可用于网络广播。虽然现在网络上还不是很流行，但是在微软的大规模推广下已经是得到了越来越多站点的承认和大力支持，在网络音乐领域中直逼*.mp3，在网络广播方面，也正在瓜分Real打下的天下。因此，几乎所有的音频格式都感受到了WMA格式的压力。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.007.png alt></p><p>微软官方宣布的资料中称WMA格式的可保护性极强，甚至可以限定播放机器、播放时间及播放次数，具有相当的版权保护能力。应该说，WMA的推出，就是针对MP3没有版权限制的缺点而来——普通用户可能很欢迎这种格式，但作为版权拥有者的唱片公司来说，它们更喜欢难以复制拷贝的音乐压缩技术，而微软的WMA则照顾到了这些唱片公司的需求。</p><p>除了版权保护外，WMA还在压缩比上进行了深化，它的目标是在相同音质条件下文件体积可以变的更小（当然，只在MP3低于192KBPS码率的情况下有效，实际上当采用LAME算法压缩MP3格式时，高于192KBPS时普遍的反映是MP3的音质要好于WMA）。</p><p><strong>RealAudio</strong></p><p>RealAudio主要适用于在网络上的在线音乐欣赏，现在大多数的用户仍然在使用56Kbps或更低速率的Modem，所以典型的回放并非最好的音质。有的下载站点会提示你根据你的Modem速率选择最佳的Real文件。real的的文件格式主要有这么几种：有RA（RealAudio）、RM（RealMedia，RealAudio G2）、RMX（RealAudio Secured），还有更多。这些格式的特点是可以随网络带宽的不同而改变声音的质量，在保证大多数人听到流畅声音的前提下，令带宽较富裕的听众获得较好的音质。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.008.png alt></p><p>近来随着网络带宽的普遍改善，Real公司正推出用于网络广播的、达到CD音质的格式。如果你的RealPlayer软件不能处理这种格式，它就会提醒你下载一个免费的升级包。许多音乐网站 提供了歌曲的Real格式的试听版本。现在最新的版本是RealPlayer 9.0，第39期《电脑报》也对RealPlayer 9.0作了详细的介绍，这里不再赘述。</p><p><strong>VQF</strong></p><p>雅马哈公司另一种格式是*.vqf，它的核心是减少数据流量但保持音质的方法来达到更高的压缩比，VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。相同情况下压缩后VQF的文件体积比MP3小30%～50%，更便利于网上传播，同时音质极佳，接近CD音质(16位44.1kHz立体声)。可以说技术上也是很先进的，但是由于宣传不力，这种格式难有用武之地。*.vqf可以用雅马哈的播放器播放。同时雅马哈也提供从*.wav文件转换到*.vqf文件的软件。 此文件缺少特点外加缺乏宣传。</p><p>当VQF以44KHz、80kbit/s的音频采样率压缩音乐时，它的音质优于44KHz、128kbit/s的MP3，当VQF以44KHz、96kbit/s的频率压缩时，它的音质几乎等于44KHz、256kbit/s的MP3。经SoundVQ压缩后的音频文件在进行回放效果试听时，几乎没有人能听出它与原音频文件的差异。</p><p>VQF音频文件个格式</p><p>播放VQF对计算机的配置要求仅为奔腾75或更高，当然如果您用奔腾100或以上的机器，VQF能够运行得更加出色。实际上，播放VQF对CPU的要求仅比Mp3高5～10%左右。</p><p>VQF即TwinVQ技术虽然是由NTT和YAMAHA开发的，但它们的应用软件都是免费的。只是NTT和YAMAHA并没有公布VQF的源代码。</p><p><strong>OggVorbis</strong></p><p>OggVorbis是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。Vorbis是这种音频压缩机制的名字，而Ogg则是一个计划的名字，该计划意图设计一个完全开放性的多媒体系统。目前该计划只实现了OggVorbis这一部分。</p><p>OggVorbis文件的扩展名是*.OGG。这种文件的设计格式是非常先进的。这种文件格式可以不断地进行大小和音质的改良，而不影响旧有的编码器或播放器。</p><p>VORBIS采用有损压缩，但通过使用更加先进的声学模型去减少损失，因此，同样位速率(BitRate)编码的OGG与MP3相比听起来更好一些。另外，还有一个原因，MP3格式是受专利保护的。如果你想使用MP3格式发布自己的作品，则需要付给Fraunhofer（发明MP3的公司）专利使用费。而VORBIS就完全没有这个问题。</p><p>对于乐迷来说，使用OGG文件的显著好处是可以用更小的文件获得优越的声音质量。而且，由于OGG是完全开放和免费的，制作OGG文件将不受任何专利限制，可望可以获得大量的编码器和播放器。这也是为何现在MP3编码器如此少而且大多是商业软件的原因，因为Fraunhofer要收取专利使用费。Vorbis使用了与MP3相比完全不同的数学原理，因此在压缩音乐时受到的挑战也不同。同样位速率编码的Vorbis和MP3文件具有同等的声音质量。Vorbis具有一个设计良好、灵活的注释，避免了象MP3文件的ID3标记那样烦琐的操作；Vorbis还具有位速率缩放：可以不用重新编码便可调节文件的位速率。Vorbis文件可以被分成小块并以样本粒度进行编辑；Vorbis支持多通道；Vorbis文件可以以逻辑方式相连接等。</p><p><strong>AMR</strong></p><p>AMR全称Adaptive Multi-Rate，自适应多速率编码，主要用于移动设备的音频，压缩比比较大，但相对其他的压缩格式质量比较差，由于多用于人声，通话，效果还是很不错的。</p><p>分类</p><ol><li><p>AMR: 又称为AMR-NB，相对于下面的WB而言，语音带宽范围：300－3400Hz，8KHz抽样</p></li><li><p>AMR-WB:AMR WideBand，</p></li></ol><p>语音带宽范围： 50－7000Hz 16KHz抽样</p><p>“AMR-WB”全称为“Adaptive Multi-rate - Wideband”，即“自适应多速率宽带编码”，采样频率为16kHz，是一种同时被国际标准化组织ITU-T和3GPP采用的宽带语音编码标准，也称为G722.2标准。AMR-WB提供语音带宽范围达到50～7000Hz，用户可主观感受到话音比以前更加自然、舒适和易于分辨。</p><p>与之作比较，现在GSM用的EFR(Enhenced Full Rate，增强型全速率编码)采样频率为8kHz，语音带宽为200～3400Hz。</p><p>AMR-WB应用于窄带GSM(全速信道16k，GMSK)的优势在于其可采用从6.6kb/s, 8.85kb/s和12.65kb/s三种编码，当网络繁忙时C/I恶化，编码器可以自动调整编码模式，从而增强QoS。在这种应用中，AMR-WB抗扰度优于AMR-NB。</p><p>AMR-WB应用于EDGE、3G可充分体现其优势。足够的传输带宽保证AMR-WB可采用从 6.6kb/s到23.85kb/s共九种编码，语音质量超越PSTN固定电话。</p><h3 id=122比较><strong>1.2.2比较</strong></h3><p>作为数字音乐文件格式的标准，WAV格式容量过大，因而使用起来很不方便。因此，一般情况下我们把它压缩为MP3或WMA格式。压缩方法有无损压缩，有损压缩，以及混成压缩。MPEG,JPEG就属于混成压缩，如果把压缩的数据还原回去，数据其实是不一样的。当然，人耳是无法分辨的。因此，如果把MP3，OGG格式从压缩的状态还原回去的话，就会产生损失。然而，APE格式即使还原，也能毫无损失地保留原有音质。所以，APE可以无损失高音质地压缩和还原。在完全保持音质的前提下，APE的压缩容量有了适当的减小。拿一个最为常见的38MBWAV文件为例，压缩为APE格式后为25MB左右，比开始足足少了13MB。而且MP3容量越来越大的今天，25M的歌曲已经算不上什么庞然大物了。以1GB的mp3来说可以放入4张CD，那就是40多首歌曲，已经足够了！</p><p>MP3支持格式有MP3和WMA。MP3由于是有损压缩，因此讲求采样率，一般是44.1KHZ。另外，还有比特率，即数据流，一般为8---320KBPS。在MP3编码时，还看看它是否支持可变比特率（VBR），现在出的MP3机大部分都支持，这样可以减小有效文件的体积。WMA则是微软力推的一种音频格式，相对来说要比MP3体积更小。</p><h2 id=13字幕格式><strong>1.3字幕格式</strong></h2><h3 id=131外挂字幕与内嵌字幕的阐述><strong>1.3.1外挂字幕与内嵌字幕的阐述</strong></h3><p>外挂字幕：是视频文件和字幕文件分离，在播放的时候要导入字幕文件。比如DVD就会自动导入字幕。外挂字幕的好处是：可以导入自己国家的语言。</p><p>内嵌字幕：视频文件和字幕文件已经集成到了一起，没有办法改变和去掉了。</p><h3 id=132外挂字幕视频与内嵌字幕视频的画面比较><strong>1.3.2外挂字幕视频与内嵌字幕视频的画面比较</strong></h3><p>外挂字幕相对于内嵌字幕来说对视频的质量损害就会小很多，外挂的意思就是在视频之外单独运行的一种字幕文件，对视频本身的分辨率损害很小甚至为零。而内嵌的字面意思就是将视频连带外挂字幕用专有的录制软件重新将视频录制一遍，成为一个新的视频；这种方法虽然解决了视频体积过大和播放器不兼容等问题，但是在重新录制视频过程当中会无意识的损害原视频本身的码率，使重新录制出来的视频分辨率大大不如原视频，所以在选择外挂与内嵌字幕时需结合自身情况考虑视频需要进行选择。</p><h3 id=133外挂字幕的三种格式><strong>1.3.3外挂字幕的三种格式</strong></h3><p>1、srt格式：这是最好的，体积小，用<a href=http://baike.baidu.com/view/152865.htm>记事本</a>可以打开编辑。</p><p>2、sub+idx：这种是图形字幕，只能用字幕转换<a href=http://baike.baidu.com/view/37.htm>软件</a>；体积较大。</p><p>3、ass字幕：网上比较少，比srt多一些特效。</p><p>外挂字幕的一些基本注意事项：</p><p>使用外挂字幕的时候，要保证字幕文件和视频文件放置在同一个文件夹下，并且保证两者的文件名相同，但是不要修改后缀和标识（常见的标识有chs、GB，cht，Big5，eng五种；其中chs和GB表示简体中文，cht和Big5表示繁体中文，eng表示英文）：</p><p>例如：</p><p>视频的文件名为：越狱（13）.avi</p><p>外挂字幕的文件名就应为：越狱（13）.chs.srt</p><p>当然，能在视频中显示字幕的前提是你的电脑里安装有字幕插件。否则建议安装能够<a href=http://baike.baidu.com/view/1395585.htm>完美解码</a>的万能播放器。</p><h2 id=14采集录制和播放渲染><strong>1.4采集录制和播放渲染</strong></h2><h3 id=141视频采集><strong>1.4.1视频采集</strong></h3><p>视频采集（Video Capture）把模拟视频转换成数字视频，并按数字视频文件的格式保存下来。所谓视频采集就是将模拟摄像机、录像机、LD视盘机、电视机输出的视频信号，通过专用的模拟、数字转换设备，转换为二进制数字信息的过程。在视频采集工作中，视频采集卡是主要设备，它分为专业和家用两个级别。专业级视频采集卡不仅可以进行视频采集，并且还可以实现硬件级的视频压缩和视频编辑。家用级的视频采集卡只能做到视频采集和初步的硬件级压缩，而更为“低端”的电视卡，虽可进行视频的采集，但它通常都省却了硬件级的视频压缩功能。</p><p><strong>视频保存格式</strong></p><p>影片拍好了，可以直接放在DV带上保存，以后就用DV机回放，也可以采集到计算机里，编辑后回录到DV带上，还可以采集到计算机里，直接把DVAVI文件刻到CDR上去保存，也可以压缩成MPG，刻成VCD或者SVCD，DVD和CD保存。MPG是有损压缩，不管是压缩成什么格式，对画质都有损失，但是刻MPG盘保存还是最常用的方式。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.009.jpeg alt=视频采集设备 title=728da9773912b31ba22d0fb38618367adbb4e1e3></p><p>DV影片的回放在电视机上的表现远强于在CRT上的表现，尽管CRT的分辨率要高得多，主要是因为电视的设计就是为了显示动态画面，所以在亮度、色彩鲜艳上都比显示静态为主的CRT要好，而普通电视的显示分辨率只有320线，那么DV的高达720×576的分辨率根本用不着，不管是VCD的352×288还是SVCD的480×576都够了，所以尽管压缩成MPG画质有损失，但是在电视上基本是看不出来的。在电脑上看，SVCD的分辨率也足够清晰了。</p><p><strong>保存格式的优劣性</strong></p><p>DV带的保存是个问题，毕竟是磁带，DV带还用得时间不长，但是以前的录音机磁带时间长了粘连和发霉大家估计都见过的。而CDR光盘蓝盘、绿盘在一般情况下不磨损光盘一般是保存30~50年，金盘号称能保存100年，虽然光盘也有发霉的可能，但是毕竟好得多。</p><p>播放的方便性上，也是光盘强，DV带就得把DV机搬出来，还只能在电视上看，对磁头也是个磨损，倒带也很麻烦，而VCD，SVCD光盘方便。</p><h3 id=142视频录制><strong>1.4.2视频录制</strong></h3><h3 id=143视频渲染><strong>1.4.3视频渲染</strong></h3><p>渲染，英文为Render,也有的把它称为着色，但我更习惯把Shade称为着色，把Render称为渲染。因为Render和Shade这两个词在三维软件中是截然不同的两个概念，虽然它们的功能很相似，但却有不同。Shade是一种显示方案，一般出现在三维软件的主要窗口中，和三维模型的线框图一样起到辅助观察模型的作用。很明显，着色模式比线框模式更容易让我们理解模型的结构，但它只是简单的显示而已，数字图像中把它称为明暗着色法。在像Maya这样的高级三维软件中，还可以用Shade显示出简单的灯光效果、阴影效果和表面纹理效果，当然，高质量的着色效果是需要专业三维图形显示卡来支持的，它可以加速和优化三维图形的显示。但无论怎样优化，它都无法把显示出来的三维图形变成高质量的图像，这是因为Shade采用的是一种实时显示技术，硬件的速度限制它无法实时地反馈出场景中的反射、折射等光线追踪效果。而现实工作中我们往往要把模型或者场景输出成图像文件、视频信号或者电影胶片，这就必须经过Render程序。</p><p>Shade窗口，提供了非常直观、实时的表面基本着色效果，根据硬件的能力，还能显示出纹理贴图、光源影响甚至阴影效果，但这一切都是粗糙的，特别是在没有硬件支持的情况下，它的显示甚至会是无理无序的。Render效果就不同了，它是基于一套完整的程序计算出来的，硬件对它的影响只是一个速度问题，而不会改变渲染的结果，影响结果的是看它是基于什么程序渲染的，比如是光影追踪还是光能传递。</p><p><strong>渲染过程</strong></p><p>首先，必须定位三维场景中的摄像机，这和真实的摄影是一样的。一般来说，三维软件已经提供了四个默认的摄像机，那就是软件中四个主要的窗口，分为顶视图、正视图、侧视图和<a href=http://baike.baidu.com/view/1142999.htm>透视图</a>。我们大多数时候渲染的是透视图而不是其它视图，透视图的摄像机基本遵循真实摄像机的原理，所以我们看到的结果才会和真实的三维世界一样，具备立体感。接下来，为了体现空间感，渲染程序要做一些“特殊”的工作，就是决定哪些物体在前面、哪些物体在后面和哪些物体被遮挡等。空间感仅通过物体的遮挡关系是不能完美再现的，很多初学三维的人只注意立体感的塑造而忽略了空间感。要知道空间感和光源的衰减、环境雾、景深效果都是有着密切联系的。</p><p>渲染程序通过摄像机获取了需要渲染的范围之后，就要计算光源对物体的影响，这和真实世界的情况又是一样的。许多三维软件都有默认的光源，否则，我们是看不到透视图中的着色效果的，更不要说渲染了。因此，渲染程序就是要计算我们在场景中添加的每一个光源对物体的影响。和真实世界中光源不同的是，渲染程序往往要计算大量的辅助光源。在场景中，有的光源会照射所有的物体，而有的光源只照射某个物体，这样使得原本简单的事情又变得复杂起来。在这之后，还要是使用深度贴图阴影还是使用光线追踪阴影？这往往取决于在场景中是否使用了透明材质的物体计算光源投射出来的阴影。另外，使用了面积光源之后，渲染程序还要计算一种特殊的阴影－－软阴影（只能使用光线追踪），场景中的光源如果使用了光源特效，渲染程序还将花费更多的<a href=http://baike.baidu.com/view/53557.htm>系统资源</a>来计算特效的结果，特别是体积光，也称为灯光雾，它会占用大量的系统资源，使用的时候一定要注意。</p><p>在这之后，渲染程序还要根据物体的材质来计算物体表面的颜色，材质的类型不同，属性不同，纹理不同都会产生各种不同的效果。而且，这个结果不是独立存在的，它必须和前面所说的光源结合起来。如果场景中有<a href=http://baike.baidu.com/view/85873.htm>粒子系统</a>，比如火焰、烟雾等，渲染程序都要加以“考虑”。</p><p><strong>数字影片的后期处理</strong></p><p>对录制完成的数字影片进行了剪接、加效果、加字幕、音乐等后期制作，当生成影片时需要将后加入的素材融合到影片中并压缩成为影片最终格式。这个一般都是这样，只是因环境的不同而不同。</p><p><strong>渲染滤镜</strong></p><p>“<strong>渲染</strong>”滤镜在图像中创建云彩图案、折射图案和模拟的光反射。也可在 3D 空间中操纵对象，并从灰度文件创建纹理填充以产生类似 3D 的光照效果。</p><p>1、分层云彩</p><p>使用随机生成的介于前景色与背景色之间的值，生成云彩图案。此滤镜将云彩数据和现有的像素混合，其方式与“差值”模式混合颜色的方式相同。第一次选取此滤镜时，图像的某些部分被反相为云彩图案。应用此滤镜几次之后，会创建出与大理石的纹理相似的凸缘与叶脉图案。</p><p>2、光照效果</p><p>使您可以通过改变 17 种光照样式、3 种光照类型和 4 套光照属性，在 RGB 图像上产生无数种光照效果。还可以使用灰度文件的纹理（称为凹凸图）产生类似 3D 的效果，并存储您自己的样式以在其它图像中使用。</p><p>3、镜头光晕</p><p>模拟亮光照射到像机镜头所产生的折射。通过点按图像缩览图的任一位置或拖移其十字线，指定光晕中心的位置。</p><p>4、纹理填充</p><p>用灰度文件或其中的一部分填充选区。若要将纹理添加到文档或选区，请打开要用作纹理填充的灰度文档。并将它装入要进行纹理填充的图像的某一通道中（新建），执行完效果后，可以看到灰度图浮凸在该图像中的效果。</p><p>5、云彩</p><p>使用介于前景色与背景色之间的随机值，生成柔和的云彩图案。若要生成色彩较为分明的云彩图案，请按住 Alt 键并选取“滤镜/渲染/云彩”命令。</p><p>【Proe中的渲染】</p><p>Pro / E 提供了制作高质量图像的渲染工具，能使零件或装配的显现近乎于照片。使用Pro/E的渲染功能，给予各零件色彩及相应的透明度，可是所设计的产品立体分明，更具视觉效果。而不必通过产生样机或<a href=http://baike.baidu.com/view/2226052.htm>实物模型</a>来比较外观。特别是值入了 CDRS2001 里的高级渲染功能 Photolux，增加渲染的特殊效果而设的指令，可以做出雾效和透镜闪光等效果。可以将产品模型置于特定的环境，比如室内，你可以在此设置地板、四壁和天花板的背景，可对背景进行预览、尺寸和位置的调整；可以在特征或某个表面上设置材质，定义表面颜色、透明度、粗糙度和纹理等；另外，运用贴图功能在产品和包装上生成和附加常规的标记和图案，指定每个图案的大小、位置和透明度；指定光线类型颜色和强度，方便地选择和控制阴影的形式。</p><h2 id=15编解码器><strong>1.5编解码器</strong></h2><p>编解码器（codec）指的是一个能够对一个信号或者一个数据流进行变换的设备或者程序。这里指的变换既包括将信号或者数据流进行编码（通常是为了传输、存储或者加密）或者提取得到一个编码流的操作，也包括为了观察或者处理从这个编码流中恢复适合观察或操作的形式的操作。编解码器经常用在视频会议和流媒体等应用中，通常主要还是用在广电行业，作前端应用。</p><p>经过编码的音频或者视频原始码流经常被叫做“Essence”（有译作“本体”，“精”），以区别于之后加入码流的元信息和其它用以帮助访问码流和增强码流鲁棒性的数据。</p><p>大多数编解码器是有损的，目的是为了得到更大的压缩比和更小的文件大小。当然也有无损的编解码器，但是通常没有必要为了一些几乎注意不到的的质量损失而大大增加编码后文件的大小。除非该编码的结果还将在以后进行下一步的处理，此时连续的有损编码通常会带来较大的质量损失。</p><p>很多多媒体数据流需要同时包含音频数据和视频数据，这时通常会加入一些用于音频和视频数据同步的元数据。这三种数据流可能会被不同的程序，进程或者硬件处理，但是当它们传输或者存储的时候，这三种数据通常是被封装在一起的。通常这种封装是通过视频文件格式来实现的，例如常见的*.mpg, *.avi, *.mov, *.mp4, *.rm, *.ogg or *.tta. 这些格式中有些只能使用某些编解码器，而更多可以以容器的方式使用各种编解码器。</p><p>编解码器对应的英文“codec”（coder和decoder简化而成的合成词语）和decode通常指软件，当特指硬件的时候，通常使用“endec”这个单词。</p><p>硬件编解码器有标清编解码器和高清编解码器。所谓标清，英文为“Standard Definition”，是物理分辨率在720p以下的一种视频格式。720p是指视频的垂直分辨率为720线逐行扫描。具体的说，是指分辨率在400线左右的VCD、DVD、电视节目等“标清”视频格式，即标准清晰度。而物理分辨率达到720p以上则称作为高清,（英文表述High Definition）简称HD。关于高清的标准，国际上公认的有两条：视频垂直分辨率超过720p或1080i；视频宽纵比为16：9。</p><h2 id=16容器和协议><strong>1.6容器和协议</strong></h2><h3 id=161容器格式和编码格式><strong>1.6.1容器格式和编码格式</strong></h3><h4 id=1611-简介><strong>1.6.1.1 简介</strong></h4><p>音频视频编码及文件格式（容器）是一个很庞大的知识领域，完整的说清楚，那就需要些写成一本教材了。这里先就几个简单的概念问题作以介绍：</p><p><code></code>首先要分清楚媒体文件和编码的区别：</p><p>l 文件是既包括视频又包括音频、甚至还带有脚本的一个集合，也可以叫容器；</p><p>l 文件当中的视频和音频的压缩算法才是具体的编码。</p><p><code></code>也就是说一个.avi文件，当中的视频可能是编码a，也可能是编码b，音频可能是编码5，也可能是编码6，具体的用那种编码的解码器，则由播放器按照avi文件格式读取信息去调用了。</p><p>音频视频编码方案有很多，用百家争鸣形容不算过分，目前常见的音频视频编码有以下几类：</p><ul><li>MPEG系列：（由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发 ）</li></ul><p><code></code>视频编码方面主要是Mpeg1（vcd用的就是它）、Mpeg2（DVD使用）、Mpeg4（现在的DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC（现在正热门）；</p><p><code></code>音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（大名鼎鼎的mp3）、MPEG-2 AAC 、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的</p><ul><li>H.26X系列：（由ITU[国际电传视讯联盟]主导，侧重网络传输，注意：只是视频编码）</li></ul><p><code></code>包括H261、H262、H263、H263+、H263++、H264（就是MPEG4 AVC-合作的结晶）</p><ul><li>微软windows media系列：（公司牛，能自己定标准啊...）</li></ul><p><code></code>视频编码有Mpeg-4 v1/v2/v3（基于MPEG4，DIVX3的来源，呵呵）、Windows Media Video 7/8/9/10</p><p><code></code>音频编码有Windows Media audeo v1/v2/7/8/9</p><ul><li>Real Media系列：（注意，这里说的Real的编码，可不是rm、rmvb文件，呵呵）</li></ul><p><code></code>视频编码有RealVideo G2（早期）、RealVideo 8/9/10</p><p><code></code>音频编码有RealAudio cook/sipro（早期）、RealAudio AAC/AACPlus等</p><ul><li>QuickTime系列：（是一个平台，有很多编码器）</li></ul><p><code></code>视频编码有Sorenson Video 3（用于QT5，成标准了）、Apple MPEG-4、Apple H.264</p><p><code></code>音频编码有QDesign Music 2、Apple MPEG-4 AAC （这个不错）</p><p>其它，如：Ogg、On2-vpx、flash vidio：不详述啦。</p><p>特殊说明的，是DVD这种媒介的音频编码，采用了相对独立的几种，就列2个常见的吧：AC3（杜比公司开发）、DTS文件格式（容器）：</p><ul><li>AVI</li></ul><p><code></code>音视频交互存储，最常见的音频视频容器。支持的视频音频编码也是最多的。</p><ul><li>MPG</li><li>MPEG编码采用的音频视频容器，具有流的特性。里面又分为 PS，TS 等，PS 主要用于 DVD 存储，TS 主要用于 HDTV。</li><li>VOB</li></ul><p>DVD采用的音频视频容器格式（即视频MPEG-2，音频用AC3或者DTS），支持多视频多音轨多字幕章节等。</p><ul><li>MP4</li></ul><p>MPEG-4编码采用的音频视频容器，基于QuickTime MOV开发，具有许多先进特性。</p><ul><li>3GP</li></ul><p><code></code>3GPP视频采用的格式，主要用于流媒体传送。</p><ul><li>ASF</li></ul><p><code></code>Windows Media 采用的音频视频容器，能够用于流传送，还能包容脚本等。</p><ul><li>RM</li></ul><p><code></code>RealMedia 采用的音频视频容器，用于流传送。</p><p><code></code>注意：RMVB，是视频编码部分采用可变码率压缩的文件格式（容器）</p><ul><li>MOV</li></ul><p>QuickTime 的音频视频容器，恐怕也是现今最强大的容器，甚至支持虚拟现实技术，Java 等，它的变种 MP4,3GP都没有这么厉害。</p><ul><li>MKV</li></ul><p>MKV 它能把 Windows Media Video，RealVideo，MPEG-4 等视频音频融为一个文件，而且支持多音轨，支持章节字幕等。</p><ul><li>WAV</li></ul><p>一种音频容器（注意：只是音频），大家常说的 WAV 就是没有压缩的 PCM 编码，其实 WAV 里面还可以包括 MP3 等其他 ACM 压缩编码。</p><ul><li>MP3</li></ul><p>如前所述，不用多说了吧？就是MPEG Audio Layer 3（Mpeg 1 的音频编码的一种）</p><p>文件转换（实际上也是编码转换）</p><h4 id=1612-多媒体容器文件格式><strong>1.6.1.2 多媒体容器文件格式</strong></h4><p>多媒体容器文件格式一般都包括文件头部分、索引部分和多媒体数据部分（如图1所示）。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.010.png alt></p><p><code></code>文件头部分</p><p><code></code>索引部分</p><p>多媒体数据部分文件头部分说明了多媒体数据符合的压缩标准及规范信息，多媒体数据符合的规范信息可以包括视频的分辨率、帧率，音频的采样率等。</p><p>索引部分:由于多媒体数据通常会被分成若干块，各块数据之间也可能是不连续存储的，因此需要再索引部分建立多媒体数据的存储位置索引（如图2所示），其详细显示了视频数据存储位置索引，用来记录相应数据块的存储位置的偏移量，由于各数据块的大小可能不同，因此也可能需要在索引部分建立各种多媒体数据块的尺寸大小索引，用来记录相应数据块的尺寸大小。此外在索引部分还建立了其他索引，比如音视频同步索引等等。PC上播放这些多媒体容器文件时，一般是将索引一次性的全部放到内存中，然后在播放中根据操作（快进、快退等）来通过数据索引得到所需的数据。这个貌似和项目里面的视频信息文件的作用类似~~~</p><p>多媒体数据部分就是经过压缩的多媒体数据，包括视频数据、音频数据、文本数据及其他多媒体数据。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.011.png alt></p><h4 id=1613-音频编解码格式><strong>1.6.1.3 音频编解码格式</strong></h4><ol><li>音频编解码格式</li></ol><p><code></code>*MPEG Audio Layer 1/2</p><p><code>　　</code>*MPEG Audio Layer 3(MP3)</p><p><code>　　</code>*MPEG2 AAC</p><p><code>　　</code>*MPEG4 AAC</p><p><code>　　</code>*Windows Media audeo v1/v2/7/8/9</p><p><code>　　</code>*RealAudio cook/sipro(real media array)</p><p><code>　　</code>*RealAudio AAC/AACPlus(real media series)</p><p><code>　　</code>*QDesign Music 2(apple series)</p><p><code>　　</code>是QDesign 公司开发的用于高保真高压缩率的编码方式，类似于MP3，不过比MP3要先进。支持流式播放.</p><p><code>　　</code>*Apple MPEG-4 AAC(apple series)</p><p><code>　　</code>*ogg(ogg vorbis音频)</p><p><code>　　</code>*AC3(DVD 专用音频编码)</p><p><code>　　</code>*DTS(DVD 专用音频编码)</p><p><code>　　</code>*APE(monkey’s 音频)</p><p><code>　　</code>*AU(sun 格式)</p><p><code>　　</code>*FLAC(fress lossless 音频)</p><p><code>　　</code>*M4A(mpeg-4音频)（苹果改用的名字，可以改成.mp4）</p><p><code>　　</code>*MP2(mpeg audio layer2音频)</p><p><code>　　</code>*WMA</p><ol><li>视频编解码格式</li></ol><p><code>　　</code>*MPEG1(VCD)</p><p><code>　　</code>*MPEG2(DVD)</p><p><code>　　</code>*MPEG4(divx,xvid)</p><p><code>　　</code>*MPEG4 AVC/h.264</p><p><code>　　</code>*h.261</p><p><code>　　</code>*h.262</p><p><code>　　</code>*h.263</p><p><code>　　</code>*h.263+</p><p><code>　　</code>*h.263++</p><p><code>　　</code>*MPEG-4 v1/v2/v3(微软windows media系列)</p><p><code>　　</code>*Windows Media Video 7/8/9/10</p><p><code>　　</code>*Sorenson Video 3（用于QT5，成标准了）(apple series)</p><p><code>　　</code>*RealVideo G2(real media series)</p><p><code>　　</code>*RealVideo 8/9/10(real media series)</p><p><code>　　</code>*Apple MPEG-4(apple series)</p><p><code>　　</code>*Apple H.264(apple series)</p><p><code>　　</code>*flash video</p><ol><li>音视频文件格式</li></ol><p><code>　　 </code>首先要分清楚媒体文件和编码的区别：文件是既包括视频又包括音频、甚至还带有脚本的一个集合，也可以叫容器；文件当中的视频和音频的压缩算法才是具体的编码。</p><p><code>　　</code>*AVI</p><p><code>　　</code>音视频交互存储，最常见的音频视频容器。支持的视频音频编码也是最多的</p><p><code>　　</code>*MPG</p><p><code>　　</code>MPEG编码采用的音频视频容器，具有流的特性。里面又分为 PS，TS 等，PS 主要用于 DVD 存储，TS 主要用于 HDTV。</p><p><code>　　</code>*VOB</p><p><code>　　</code>DVD采用的音频视频容器格式（即视频MPEG-2，音频用AC3或者DTS），支持多视频多音轨多字幕章节等。</p><p><code>　　</code>*MP4</p><p><code>　　</code>MPEG-4编码采用的音频视频容器，基于 QuickTime MOV 开发，具有许多先进特性。</p><p><code>　　</code>*3GP</p><p><code>　　</code>3GPP视频采用的格式，主要用于流媒体传送。</p><p><code>　　</code>*ASF</p><p><code>　　</code>Windows Media 采用的音频视频容器，能够用于流传送，还能包容脚本等。</p><p><code>　　</code>*RM</p><p><code>　　</code>RealMedia 采用的音频视频容器，用于流传送。</p><p><code>　　</code>*MOV</p><p><code>　　</code>QuickTime 的音频视频容器，恐怕也是现今最强大的容器，甚至支持虚拟现实技术，Java 等，它的变种 MP4,3GP都没有这么厉害。</p><p><code>　　</code>*MKV</p><p><code>　　</code>MKV 它能把 Windows Media Video，RealVideo，MPEG-4 等视频音频融为一个文件，而且支持多音轨，支持章节字幕等。</p><p><code>　　</code>*WAV</p><p><code>　　</code>一种音频容器（注意：只是音频），大家常说的 WAV 就是没有压缩的 PCM 编码，其实 WAV 里面还可以包括 MP3 等其他 ACM 压缩编码。</p><ol><li>音视频技术</li></ol><p><code>　　</code>VCD</p><p><code>　　</code>DVD</p><p><code>　　</code>DVD目录是如何工作的</p><p><code>　　</code>Audio CD</p><p><code>　　</code>*标准CD格式也就是44.1K的采样频率，速率88K/秒，16位量化位数</p><p><code>　　</code>*＊.cda格式，这就是CD音轨了，一个CD音频文件是一个＊.cda文件，这只是一个索引信息，并不是真正的包含声音信息，所以不论CD音乐的长短，在电脑上看到的“＊.cda文件”都是44字节长</p><p><code>　　</code>MP3</p><p><code>　　</code>*MPEG音频文件的压缩是一种有损压缩，MPEG3音频编码具有10：1~12：1的高压缩率，同时基本保持低音频部分不失真，但是牺牲了声音文件中12KHz到16KHz高音频这部分的质量来换取文件的尺寸，相同长度的音乐文件，用＊.mp3格式来储存，一般只有＊.wav文件的1/10，而音质要次于CD格式或WAV格式的声音文件</p><p><code>　　</code>*MP3格式压缩音乐的采样频率有很多种，可以用64Kbps或更低的采样频率节省空间，也可以用320Kbps的标准达到极高的音质</p><p><code>　　</code>*每分钟音乐的MP3格式只有1MB左右大小</p><p><code>　　</code>MIDI：</p><p><code>　　</code>经常玩音乐的人应该常听到MIDI（Musical Instrument Digital Interface）这个词，MIDI允许数字合成器和其他设备交换数据。MID文件格式由MIDI继承而来。MID文件并不是一段录制好的声音，而是记录声音的信息，然后在告诉声卡如何再现音乐的一组指令。这样一个MIDI文件每存1分钟的音乐只用大约5～10KB。今天，MID文件主要用于原始乐器作品，流行歌曲的业余表演，游戏音轨以及电子贺卡等。＊.mid文件重放的效果完全依赖声卡的档次。＊.mid格式的最大用处是在电脑作曲领域。＊.mid文件可以用作曲软件写出，也可以通过声卡的MIDI口把外接音序器演奏的乐曲输入电脑里，制成＊.mid文件。</p><p><code>　　</code>WMA:</p><p><code>　　</code>*WMA的压缩率一般都可以达到1：18左右，WMA的另一个优点是内容提供商可以通过DRM（Digital Rights Management）方案如Windows Media Rights Manager 7加入防拷贝保护。这种内置了版权保护技术可以限制播放时间和播放次数甚至于播放的机器等等，这对被盗版搅得焦头乱额的音乐公司来说可是一个福音，另外WMA还支持音频流(Stream)技术，适合在网络上在线播放</p><p><code>　　</code>* WMA这种格式在录制时可以对音质进行调节。同一格式，音质好的可与CD媲美，压缩率较高的可用于网络广播</p><ol><li>以文件名标识识别音频编码格式</li></ol><p><code>　　</code>*.aac</p><p><code>　　</code>音频编码：aac</p><p><code>　　</code>*.ac3</p><p><code>　　</code>音频编码：ac3</p><p><code>　　</code>*.ape</p><p><code>　　</code>*.au</p><p><code>　　</code>音频编码：pcm_s16be</p><p><code>　　</code>*.m4a</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>*.mp2</p><p><code>　　</code>*.mp3</p><p><code>　　</code>*.ogg</p><p><code>　　</code>音频编码：vorbis</p><p><code>　　</code>*.wav</p><p><code>　　</code>音频编码：pcm_s16le</p><p><code>　　</code>*.flav</p><p><code>　　</code>*.wma</p><p><code>　　</code>音频编码：wma7x</p><p><code>　　</code>以文件名标识识别音视频编码格式</p><p><code>　　</code>1．*.MP4 (MP4 MPEG-4视频)</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>２．*.3gp (3GPP 第三代合作项目)</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：amr_nb((mono, 8000 Hz, Sample Depth 16 morsel, bitrate 12 kbps)</p><p><code>　　</code>３．*.3g2 (3GPP 第三代合作项目2)</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>4．*.asf (ASF 高级流格式)</p><p><code>　　</code>视频编码：msmpeg4</p><p><code>　　</code>音频编码：mp3</p><p><code>　　</code>5．*.avi （AVI 音视频交错格式）</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：pcm_s161e</p><p><code>　　</code>6．*.avi （divx 影片）</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：mp3</p><p><code>　　</code>7．*.avi（xvid 视频）</p><p><code>　　</code>视频编码：Xvid</p><p><code>　　</code>音频编码：mp3</p><p><code>　　</code>8．*.vob （DVD）</p><p><code>　　</code>视频编码：mpeg2 video</p><p><code>　　</code>音频编码：ac3</p><p><code>　　</code>9．*.flv (flash 视频格式)</p><p><code>　　</code>视频编码：</p><p><code>　　</code>音频编码：mp3</p><p><code>　　</code>10．*.mp4 (iPod 320*240 MPEG-4 视频格式)</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>11．*.mp4(iPod video2 640*480 MPEG-4 视频格式)</p><p><code>　　</code>视频编码：mpeg4</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>12．*.mov (MOV 苹果quicktime 格式)</p><p><code>　　</code>视频编码：mpeg4_qt</p><p><code>　　</code>音频编码：mpeg4 aac_qt</p><p><code>　　</code>13．*.mpg （mpeg1影片）</p><p><code>　　</code>视频编码：mpeg1 video</p><p><code>　　</code>音频编码：mp2</p><p><code>　　</code>14．*.mpg （mpeg2 影片）</p><p><code>　　</code>视频编码：mpeg2 video</p><p><code>　　</code>音频编码：mp2</p><p><code>　　</code>15．*.mp4 （mpeg4 avc 视频格式）</p><p><code>　　</code>视频编码：h.264</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>16．*.mp4 （PSP mpeg4 影片）</p><p><code>　　</code>视频编码：Xvid</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>17．*.mp4 （PSP AVC 视频格式）</p><p><code>　　</code>视频编码：h.264</p><p><code>　　</code>音频编码：mpeg4 aac</p><p><code>　　</code>18．*.rm （RM realvideo）</p><p><code>　　</code>视频编码：rv10</p><p><code>　　</code>音频编码：ac3</p><p><code>　　</code>19．*.mpg (超级VCD)</p><p><code>　　</code>视频编码：mpeg2 video</p><p><code>　　</code>音频编码：mp2</p><p><code>　　</code>20．*.swf (SWF 格式)</p><p><code>　　</code>视频编码：</p><p><code>　　</code>音频编码：mp3</p><p><code>　　</code>21．*.mpg （video CD 格式）</p><p><code>　　</code>视频编码：mpeg1 video</p><p><code>　　</code>音频编码：mp2</p><p><code>　　</code>22．*.vob （mpeg2 ps格式）</p><p><code>　　</code>视频编码：mpeg2 video</p><p><code>　　</code>音频编码：ac3</p><p><code>　　</code>23．*.wmv（windows 视频格式）</p><p><code>　　</code>视频编码：wmv3x</p><p>音频编码：wma7x</p><h3 id=162协议><strong>1.6.2协议</strong></h3><p>两大标准制定组织</p><p>这里的标准，主要指的是音视频压缩标准。两大组织分别是国际标准化组织（iso）和国际电信联盟（itu），相信it行业的从业者没听说过这两个行业的人很少。</p><p>在音视频压缩标准方面，mpeg系列的协议是iso制定的标准，而h系列的协议则是itu制定的标准。</p><h3 id=1621-视频协议><strong>1.6.2.1 视频协议</strong></h3><p>目前主要的视频压缩协议有：h.261、h.263、h.264和mpeg-1、mpeg-2和mpeg-4。第一个视频压缩标准是h.261，它的算法 现 在来看，非常简单，但是，它的很多视频压缩的思想，一直影响到现在最新的压缩标准h.264。h.264单看名字，感觉是itu组织制定的，其实它还有一 个名字叫mpeg-4 part 10，翻译过来叫mpeg-4 第十部分，这是因为h.264是iso和itu组织共同制定的，版权共享。其实，一直以来，h系列的标准制定者和mpeg系列的标准制定者基本上就是同一 群人，而且，这两个系列的算法思想基本上都差不多，唯一有一点不同的协议是mpeg-4，它在它的高级profile中提出了小波变换等算法来实现视频压 缩，从实际发展看，个人感觉不是很成功，采用小波变换的商用codec很少，这可能和这些算法的达不到实时性有关系。</p><p>从应用的角度看，mpeg 系列在消费类应用更广些，大家也更熟悉些，我们熟悉的vcd格式视频主要是mpeg-1，dvd的视频则是mpeg-2，早期大家看的电影在电脑上存盘文 件格式都是*.mpg，基本上也都是mpeg做的压缩了。在行业上，国内的监控行业，也是从mpeg-1到mpeg-2，到前两三年的mpeg-4，再到 最近的h.264。而h系列的标准，用得最多的是视频会议，从h.261到h.263，再到h.263+、h.263++等，再到现在的h.264。</p><p>从技术角度说，h系列的协议对网络的支持更好些，这点mpeg系列要差一些，但是，mpeg它每一代都比h系列同一代的协议要出得晚些，算法也相对更先进 些，因此，它用来做存储协议是很合适的，这也就是为什么普通消费类产品用户很少了解到h系列协议的原因。</p><p>h.264是两大组织最新的算法成果，它在算法层面应该说是非常先进了，有人评价，h.264是视频压缩技术的一个里程碑，在可预见的5到10年内，出现新的视频压缩协议可能性很小，除非压缩理论有重大突破。</p><p>中国也有自己的视频压缩协议，叫做avs，搞了好多年了，不过搞得不是很好。从市场分析，消费类电子、视频会议和流媒体行业，现在要再想进去可能很困难 了。不过最近听说avs又有点火起来了，有消息称，iptv指定要支持avs，这可能是它的最后机会了吧。</p><p>除了上面说的协议，还有很多公司也有自己的压缩算法，不过基本上都是不公开的了，他们这些算法也都非常好，不过和开发人员关系倒不是很大了，典型的是微软 的wmv、realplay公司的rm和rmvb等，他们的使用者也很多，而且他们都偏向流媒体应用。</p><h3 id=1622-音频协议><strong>1.6.2.2 音频协议.</strong></h3><p>音频协议也分两大类，itu组织的主要是用于视频会议的g系列协议，包括g.711、g.722、g.723、g.726、g.728、g.729等。这些 协议主要有两大特点，第一是比较关注语音压缩，毕竟开会主要是要听人讲话；对音乐的压缩效果可能就不是太好了；第二是压缩率都比较大，码率都比较低，典型 的g.723支持5.9k/s这样的码率，而且语音音质还很不错。iso的音频可能更为人熟知一些，最流行的就是mp3，它的全称是mpeg-1 audio layer 3，意思是mpeg-1的音频第三层；另外，最新的音频算法被称为aac（也称为mp4），它定义在mpeg-2或mpeg-4的音频部分。他们的特点是 音质好，支持多声道，高采样精度和采样频率，尤其对音乐的压缩效果比g系列要好太多。当然，这也是因为它们的应用领域侧重点不同造成的。</p><p>同样的，很多大公司也有自己的语音压缩标准，效果也非常好。不过都是他们自己的知识产权和算法，通用市场用的还是少。</p><h3 id=1623-上层通讯协议><strong>1.6.2.3 上层通讯协议</strong></h3><p>在视频会议系统中，目前最流行的有h.323和sip协议，在流媒体应用中，isma rtsp应用得比较多，它属于开源项目，而很多流媒体产商有自己的流媒体传输协议，比如微软的mms等。</p><p>h.323 主要用于视频会议，被称为协议簇，我们前面提到的h系列视频压缩协议和g系列音频压缩协议都属于它的子协议。除了音视频编解码器外；它还定义了各种数据应 用，包括t.120、t.84、t.434等；另外还包括h.245控制信道、h.225.0呼叫信令信道以及ras信道。详细的h.323的知识，这里 就不深入介绍了。</p><p>sip是由ietf提出来的一个应用控制（信令）协议。正如名字所隐含的--用于发起会话。它可用来创建、修改以及终结多个参与者参加的多媒体会话进程。参与会话的成员可以通过组播方式、单播连网或者两者结合的形式进行通信。</p><p>h.323 和sip分别是通信领域与因特网两大阵营推出的建议。h.323企图把ip电话当作是众所周知的传统电话，只是传输方式发生了改变，由电路交换变成了分组交换。而sip协议侧重于将ip电话作为因特网上的一 个应用，较其实应用（如ftp，e-mail等）增加了信令和qos的要求，它们支持的业务基本相同，也都利用rtp作为媒体传输的协议。但h.323是 一个相对复杂的协议。</p><p>rtsp主要用于流媒体传输，它的英文全称是real time streaming protocol。典型的应用就是网络电视的应用，由客户向服务器进行点播，如果在监控行业应用的话，建议当用户进行远程回放录像时，可采用rtsp协议。</p><h2 id=17常用概念介绍><strong>1.7常用概念介绍</strong></h2><h3 id=171硬解><strong>1.7.1硬解</strong></h3><p>硬件解码：</p><p>视频解码分为软解和硬解。</p><p>所谓“软解”就是通过软件让CPU进行视频解码处理；而“硬解”是指不依赖于CPU，通过专用的设备（子卡）单独完成视频解码，比如曾经的VCD/DVD解压卡、视频压缩卡都被冠以“硬解”的称号。现在实现高清硬解不需要额外的子卡，也不需要额外的投入，因为硬解码模块被整合在了GPU内部，而目前主流的显卡（包括整合显卡）都能支持硬解码。</p><p>“硬解”其实更需要软件的支持，只是基本不需要CPU参与运算，从而为系统节约了很多资源开销。通过降低CPU占用率，可以给用户带来很多实惠：</p><p>● GPU硬解码高清视频的优势：</p><p>\1. 不需要太好的CPU，单核足矣，CPU方面节约不少资金；</p><p>\2. 硬解码基本相当于免费附送，不到500元的整合主板都能完美支持；</p><p>\3. 硬解码让CPU占用率超低，系统有能力在看HDTV的同时进行多任务操作；</p><p>\4. CPU需要倾尽全力才能解码HDTV，而GPU只需动用0.1亿晶体管的解码模块就能完成任务，功耗控制更好；</p><p>● GPU硬解码高清视频的劣势：</p><p>\1. 起步较晚，软件支持度无法与软解相提并论；</p><p>\2. 面对杂乱无章的视频编码、封装格式，硬解码无法做到全面兼容；</p><p>\3. 软解拥有大量画面输出补偿及画质增强技术，而硬解这方面做得还远远不够；</p><p>\4. 硬解码软件设置较为复杂，很多朋友根本不知道该如何正确使用GPU硬件解码。</p><p>虽然硬解码拥有种种缺点，但依然倍受广大用户追捧，因为低成本和节能环保这两大致命诱惑让人难以抗拒。随着时间的推移，现在硬解码的缺点基本被改进，只是很多人还不懂得如何用好硬解码，本文就通过大量应用案例来释放出硬解码真正的威力！</p><p><strong>解码芯片</strong>(又叫<a href=http://baike.baidu.com/view/845020.htm>解压缩</a>芯片). 手机播放视频要依赖于解码芯片把画面和声音还原成可以播放的信号， 交由显示屏和喇叭(耳机)输出。 解码芯片的性能是有局限的, 类似于汽车的发动机功率是有极限的. 它能够流畅解码的数据，主要受限于以下几个参数和条件。</p><h3 id=172-ibp帧><strong>1.7.2 IBP帧</strong></h3><p>帧——就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。而在实际压缩时，会采取各种算法减少数据的容量，其中IPB就是最常见的。</p><p>1、基本概念</p><p>I frame ：帧内编码帧 又称intra picture，I 帧通常是每个 GOP（MPEG 所使用的一种视频压缩技术）的第一个帧，经过适度地压缩，做为随机访问的参考点，可以当成图象。I帧可以看成是一个图像经过压缩后的产物。P frame: 前向预测编码帧 又称predictive-frame，通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧；</p><p>B frame: 双向预测内插编码帧 又称bi-directional interpolated prediction frame，既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧；</p><p>PTS：Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来</p><p>DTS：Decode Time Stamp。DTS主要是标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码。</p><p>ps:在没有B帧存在的情况下DTS的顺序和PTS的顺序应该是一样的。</p><p>2、I、B、P的特点</p><p>I帧特点:</p><p>1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;</p><p>2.解码时仅用I帧的数据就可重构完整图像;</p><p>3.I帧描述了图像背景和运动主体的详情;</p><p>4.I帧不需要参考其他画面而生成;</p><p>5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);</p><p>6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;</p><p>7.I帧不需要考虑运动矢量;</p><p>8.I帧所占数据的信息量比较大。</p><p>P帧:前向预测编码帧。</p><p>P帧的预测与重构:P 帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,</p><p>取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测</p><p>值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p><p>P帧特点:</p><p>1.P帧是I帧后面相隔1~2帧的编码帧;</p><p>2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</p><p>3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</p><p>4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;</p><p>5.P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</p><p>6.由于P帧是参考帧,它可能造成解码错误的扩散;</p><p>7.由于是差值传送,P帧的压缩比较高。</p><p>B帧:双向预测内插编码帧。</p><p>B帧的预测与重构</p><p>B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢</p><p>量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测</p><p>值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。</p><p>B帧特点</p><p>1.B帧是由前面的I或P帧和后面的P帧来进行预测的;</p><p>2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;</p><p>3.B帧是双向预测编码帧;</p><p>4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</p><p>5.B帧不是参考帧,不会造成解码错误的扩散。</p><p>注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像</p><p>中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列</p><p><code></code>从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。</p><p><code></code>但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p><p><code></code>一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p><p>3、GOP</p><p>GOP：Group of Pictures 画面组</p><p><code></code>GOP（Group of Pictures）策略影响编码质量：所谓GOP，意思是画面组，一个GOP就是一组连续的画面。MPEG编码将画面（即帧）分为I、P、B三种，I是内部编码帧，P是前向预测帧，B是双向内插帧。简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。没有I帧，P帧和B帧就无法解码，这就是MPEG格式难以精确剪辑的原因，也是我们之所以要微调头和尾的原因。 MPEG-2 帧结构</p><p><code></code>MPEG-2压缩的帧结构有两个参数，一个是GOP（Group Of Picture）图像组的长度，一般可按编码方式从1－15；另一个是I帧和P帧之间B帧的数量，一般是1－2个。前者在理论上记录为N，即多少帧里面出现一次I帧；后者描述为多少帧里出现一次P帧，记录为M。</p><p>下面举例说明：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.012.jpeg alt></p><p>在如上图中，GOP (Group of Pictures)长度为13，S0~S7 表示 8个视点，T0~T12 为 GOP的 13个时刻。每个 GOP包含帧数为视点数 GOP 长度的乘积。在该图中一个 GOP 中，包含94 个 B帧。B 帧占一个 GOP 总帧数的 90.38%。GOP 越长，B 帧所占比例更高，编码的率失真性能越高。下图测试序列 Race1 在不同 GOP 下的率失真性能对比。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.013.jpeg alt></p><p>4、mpeg4视频中IBP的判定</p><p><code></code>mpeg4的每一帧开头是固定的：00 00 01 b6，那么我们如何判断当前帧属于什么帧呢？在接下来的2bit，将会告诉我们答案。注意：是2bit，不是byte，下面是各类型帧与2bit的对应关系：</p><p><code>　　</code>00: I Frame</p><p><code>　　</code>01: P Frame</p><p><code>　　</code>10: B Frame　</p><p>为了更好地说明，我们举几个例子，以下是16进制显示的视频编码：</p><p><code>　　</code>00 00 01 b6 10 34 78 97 09 87 06 57 87 …… I帧</p><p><code>　　</code>00 00 01 b6 50 78 34 20 cc 66 b3 89 …… P帧</p><p><code>　　</code>00 00 01 b6 96 88 99 06 54 34 78 90 98 …… B帧</p><p>下面我们来分析一下为什么他们分别是I、P、B帧</p><p><code>　　</code>0x10 = 0001 0000</p><p><code>　　</code>0x50 = 0101 0000</p><p><code>　　</code>0x96 = 1001 0100　</p><p>大家看红色的2bit，再对照开头说的帧与2bit的对应关系，是不是符合了呢？</p><p>下面给出一段c++代码供大家参考：</p><p><strong>[cpp]</strong> <a href=http://blog.csdn.net/ameyume/article/details/6722450#>view plain</a><a href=http://blog.csdn.net/ameyume/article/details/6722450#>copy</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln> 1</span><span class=cl>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=k>switch</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>BYTE</span><span class=p>)</span><span class=mh>0xc0</span><span class=p>)</span>   
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=ln> 4</span><span class=cl>	<span class=k>case</span> <span class=mh>0x00</span><span class=o>:</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>		<span class=c1>//I Frame  
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1></span>		<span class=k>break</span><span class=p>;</span>  
</span></span><span class=line><span class=ln> 7</span><span class=cl>	<span class=k>case</span> <span class=mh>0x40</span><span class=o>:</span>  
</span></span><span class=line><span class=ln> 8</span><span class=cl>		<span class=c1>//P Frame  
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span>		<span class=k>break</span><span class=p>;</span>  
</span></span><span class=line><span class=ln>10</span><span class=cl>	<span class=k>case</span> <span class=mh>0x80</span><span class=o>:</span>  
</span></span><span class=line><span class=ln>11</span><span class=cl>		<span class=c1>//B Frame  
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=c1></span>		<span class=k>break</span><span class=p>;</span>  
</span></span><span class=line><span class=ln>13</span><span class=cl>	<span class=k>default</span><span class=o>:</span>  
</span></span><span class=line><span class=ln>14</span><span class=cl>		<span class=k>break</span><span class=p>;</span> 
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><h3 id=173-dts和pts><strong>1.7.3 DTS和PTS</strong></h3><h3 id=174-分辨率><strong>1.7.4 分辨率</strong></h3><p>这里有2个概念， 分别是：</p><p>a. 物理分辨率, 即手机屏幕能显示的像素数， 用W x H个像素表示。常见的手机屏幕分辨率为320x240(QVGA), 随着大屏幕手机的普及， 更高的分辨率也开始出现. 例如: 480x320(iphone),640x360(nHD, 诺基亚触屏系列常见),640x480(VGA, 多普达系列常见), 甚至高达852x480(夏普高端手机常见).</p><p>b. 视频文件的分辨率， 这个是指视频画面的实际分辨率, 如， 320x240, 480x272, 640x480等等。</p><p>一般来说， 大部分手机的解码芯片不支持超过其屏幕物理分辨率的视频, 部分可以支持超过其屏幕物理分辨率的视频， 例如, 虽然iphone的屏幕物理分辨率为480x320, 但它支持640x480的视频， 此时播放的画面实际是把原视频缩小的.</p><h3 id=175-码率><strong>1.7.5 码率</strong></h3><p>一般用多少kbps(千比特/秒)或者<a href=http://baike.baidu.com/view/496716.htm>mbps</a>(<a href=http://baike.baidu.com/view/1094167.htm>兆比特</a>/秒)来表示。 手机解码芯片所支持的码率一般都在1Mbps以下.</p><h3 id=176-帧率><strong>1.7.6 帧率</strong></h3><p>(FPS, 帧/秒), 就是视频画面刷新的速度， 作为参考, 国内电视机一般是25FPS, 电影标准为24FPS. 手机芯片， 最高支持30FPS, 早期型号最大只能15fps。</p><h3 id=177-rgb和yuv><strong>1.7.7 RGB和YUV</strong></h3><p>RGB指的是红绿蓝，应用还是很广泛的，比如显示器显示，bmp文件格式中的像素值等；而yuv主要指亮度和两个色差信号，被称为luminance和 chrominance他们的转化关系可以自己去查一下，我们视频里面基本上都是用yuv格式。</p><p>YUV文件格式又分很多种，如果算上存储格式，就更多了，比如yuv444、yuv422、yuv411、yuv420等等，视频压缩用到的是420格式，这是 因为人眼对亮度更敏感些，对色度相对要差些。另外要注意几个英文单词的意思，比如：packet、planar、interlace、 progressive等。</p><h3 id=178-实时和非实时><strong>1.7.8 实时和非实时</strong></h3><p>实时与非实时 主要用来形容编码器，它含有两个意思，一个是要保证帧率，也就是每秒25帧，另一个是“live”的意思，意味着直播，所谓的“实况转播”的“实”。</p><h3 id=179-复合视频和s-video><strong>1.7.9 复合视频和s-video</strong></h3><p>ntsc 和pal彩色视频信号是这样构成的--首先有一个基本的黑白视频信号，然后在每个水平同步脉冲之后，加入一个颜色脉冲和一个亮度信号。因为彩色信号是由多 种数据“叠加”起来的，故称之为“复合视频”。s-video则是一种信号质量更高的视频接口，它取消了信号叠加的方法，可有效避免一些无谓的质量损失。 它的 功能是将rgb三原色和亮度进行分离处理。</p><h3 id=1710-硬件加速><strong>1.7.10 硬件加速</strong></h3><p>VDA/vaspi/DX等等。</p><h3 id=1711-ffmpeg-device><strong>1.7.11 FFmpeg Device</strong></h3><p>硬件方式：CDIO / DC1394 （输入设备）</p><p>非扩展硬件：DSHOW（输入设备）、SDL（输出设备）、X11（输入）、VFWCAP（输入）、DV1394（输入）等等。</p><p>第二章 FFmpeg框架</p><h2 id=21-ffmpeg概述><strong>2.1 FFmpeg概述</strong></h2><h3 id=211简介><strong>2.1.1简介</strong></h3><p>Open-source multimedia library， 遵从GPL/LGPL协议，ffmpeg只是一个商标，它的所有权属于ffmpeg org。</p><p>由Fabrice Bellard（法国著名程序员Born in 1972）于2000年发起创建的开源项目，同时也是TinyCC(1996)、发现最快速计算圆周率算法(1997)、 TinyGL(1998)、QEMU(2003)、 Jslinux(2011)等等的发起人或作者。</p><p>FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。</p><p>这个项目最早由Fabrice Bellard发起，现在由Michael Niedermayer维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的"FF"代表"Fast Forward"。</p><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了目前领先的音/视频编码库libavcodec。 FFmpeg是在Linux下开发出来的，但它可以在包括Windows在内的大多数操作系统中编译。这个项目是由Fabrice Bellard发起的，现在由Michael Niedermayer主持。可以轻易地实现多种视频格式之间的相互转换，例如可以将摄录下的视频avi等转成现在视频网站所采用的flv格式。</p><h3 id=212功能><strong>2.1.2功能</strong></h3><p>多媒体视频处理工具FFmpeg有非常强大的功能[2]包括视频采集功能、视频格式转换、视频抓图、给视频加水印等。</p><p>视频采集功能</p><p>FFmpeg是在Linux下开发出来的，但它可以在包括Windows在内的大多数操作系统中编译。这个项目是由Fabrice Bellard发起的，现在由Michael Niedermayer主持。</p><p>ffmpeg视频采集功能非常强大，不仅可以采集视频采集卡或USB摄像头的图像，还可以进行屏幕录制，同时还支持以RTP方式将视频流传送给支持RTSP的流媒体服务器，支持直播应用。</p><p>ffmpeg在Linux下的视频采集</p><p>在Linux平台上，ffmpeg对V4L2的视频设备提高了很好的支持，如：</p><p>./ffmpeg -t 10 -f video4linux2 -s 176*144 -r 8 -i /dev/video0 -vcodec h263 -f rtp rtp://192.168.1.105:5060 > /tmp/ffmpeg.sdp</p><p>以上命令表示：采集10秒钟视频，对video4linux2视频设备进行采集，采集QCIF(176*144)的视频，每秒8帧，视频设备为/dev/video0，视频编码为h263，输出格式为RTP，后面定义了IP地址及端口，将该码流所对应的SDP文件重定向到/tmp/ffmpeg.sdp中，将此SDP文件上传到流媒体服务器就可以实现直播了。</p><p>ffmpeg在windows下的视频采集</p><p>在windows下关于ffmpeg视频采集的资料非常少，但是ffmpeg还是支持windows下视频采集的。ffmpeg支持windows下video for windows(VFW)设备的视频采集，不过VFW设备已经过时，正在被WDM的视频设备所取代，但是ffmpeg还没有支持WDM的计划，不过好像有将WDM转为VFW的工具，因此ffmpeg还是可以在windows下进行视频采集的。</p><p>视频格式转换功能</p><p>ffmpeg视频转换功能。视频格式转换，比如可以将多种视频格式转换为flv格式，可不是视频信号转换 。</p><p>ffmpeg可以轻易地实现多种视频格式之间的相互转换(wma,rm,avi,mod等)，例如可以将摄录下的视频avi等转成现在视频网站所采用的flv格式。</p><p>视频截图功能</p><p>对于选定的视频，截取指定时间的缩略图。视频抓图，获取静态图和动态图，不提倡抓gif文件;因为抓出的gif文件大而播放不流畅</p><p>给视频加水印功能</p><p>使用ffmpeg 视频添加水印(logo)。</p><h3 id=213模块组成><strong>2.1.3模块组成</strong></h3><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的音/视频编码库libavcodec等。</p><p>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；音视频的格式解析协议，为libavcodec分析码流提供独立的音频或视频码流源。</p><p>libavcodec：用于各种类型声音/图像编解码；该库是音视频编解码核心，实现了市面上可见的绝大部分解码器的功能，libavcodec库被其他各大解码器ffdshow，Mplayer等所包含或应用。</p><p>libavdevice：硬件采集、加速、显示。操作计算机中常用的音视频捕获或输出设备：ALSA,AUDIO_BEOS,JACK,OSS,1394，VFW。</p><p>libavfilter:filter（FileIO、FPS、DrawText）音视频滤波器的开发，如宽高比 裁剪 格式化 非格式化 伸缩。</p><p>libavutil：包含一些公共的工具函数的使用库，包括算数运算 字符操作；</p><p>libavresample：音视频封转编解码格式预设等。</p><p>libswscale：（原始视频格式转换）用于视频场景比例缩放、色彩映射转换；图像颜色空间或格式转换，如rgb565 rgb888等与yuv420等之间转换。</p><p>libswresample：原始音频格式转码</p><p>libpostproc：（同步、时间计算的简单算法）用于后期效果处理；音视频应用的后处理，如图像的去块效应。</p><p>ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；</p><p>ffsever：一个 HTTP 多媒体即时广播串流服务器；</p><p>ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；</p><h3 id=214命令集><strong>2.1.4命令集</strong></h3><p>ffmpeg 命令集举例</p><p>1.获取视频的信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video.avi
</span></span></code></pre></div><p>2.将图片序列合成视频</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -f image2 -i image%d.jpg video.mpg
</span></span></code></pre></div><p>上面的命令会把当前目录下的图片（名字如：image1.jpg. image2.jpg. 等...）合并成video.mpg</p><p>3.将视频分解成图片序列</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video.mpg image%d.jpg
</span></span></code></pre></div><p>上面的命令会生成image1.jpg. image2.jpg. ...</p><p>支持的图片格式有：PGM. PPM. PAM. PGMYUV. JPEG. GIF. PNG. TIFF. SGI</p><p>4.为视频重新编码以适合在iPod/iPhone上播放</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i source\_video.avi input -acodec aac -ab 128kb -vcodec mpeg4 -b 1200kb -mbd 2 -flags +4mv+trell -aic 2 -cmp 2 -subcmp 2 -s 320x180 -title X final\_video.mp4
</span></span></code></pre></div><p>说明：</p><p>* 源视频：source_video.avi</p><p>* 音频编码：aac</p><p>* 音频位率：128kb/s</p><p>* 视频编码：mpeg4</p><p>* 视频位率：1200kb/s</p><p>* 视频尺寸：320 X 180</p><p>* 生成的视频：final_video.mp4</p><p>5.为视频重新编码以适合在PSP上播放</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i source\_video.avi -b 300 -s 320x240 -vcodec xvid -ab 32 -ar 24000 -acodec aac final\_video.mp4
</span></span></code></pre></div><p>说明：</p><p>* 源视频：source_video.avi</p><p>* 音频编码：aac</p><p>* 音频位率：32kb/s</p><p>* 视频编码：xvid</p><p>* 视频位率：1200kb/s</p><p>* 视频尺寸：320 X 180</p><p>* 生成的视频：final_video.mp4</p><p>6.从视频抽出声音.并存为Mp3</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i source\_video.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 sound.mp3
</span></span></code></pre></div><p>说明：</p><p>* 源视频：source_video.avi</p><p>* 音频位率：192kb/s</p><p>* 输出格式：mp3</p><p>* 生成的声音：sound.mp3</p><p>7.将wav文件转成Mp3</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i son\_origine.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 son\_final.mp3
</span></span></code></pre></div><p>8.将.avi视频转成.mpg</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi video\_finale.mpg
</span></span></code></pre></div><p>9.将.mpg转成.avi</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.mpg video\_finale.avi
</span></span></code></pre></div><p>10.将.avi转成gif动画（未压缩）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi gif\_anime.gif
</span></span></code></pre></div><p>11.合成视频和音频</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i son.wav -i video\_origine.avi video\_finale.mpg
</span></span></code></pre></div><p>12.将.avi转成.flv</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -ab 56 -ar 44100 -b 200 -r 15 -s 320x240 -f flv video\_finale.flv
</span></span></code></pre></div><p>13.将.avi转成dv</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -s pal -r pal -aspect 4:3 -ar 48000 -ac 2 video\_finale.dv
</span></span></code></pre></div><p>或者：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -target pal-dv video\_finale.dv
</span></span></code></pre></div><p>14.将.avi压缩成divx</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -s 320x240 -vcodec msmpeg4v2 video\_finale.avi
</span></span></code></pre></div><p>15.将Ogg Theora压缩成Mpeg dvd</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i film\_sortie\_cinelerra.ogm -s 720x576 -vcodec mpeg2video -acodec mp3 film\_terminate.mpg
</span></span></code></pre></div><p>16.将.avi压缩成SVCD mpeg2</p><p>NTSC格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -target ntsc-svcd video\_finale.mpg
</span></span></code></pre></div><p>PAL格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -target pal-svcd video\_finale.mpg
</span></span></code></pre></div><p>17.将.avi压缩成VCD mpeg2</p><p>NTSC格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -target ntsc-vcd video\_finale.mpg
</span></span></code></pre></div><p>PAL格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i video\_origine.avi -target pal-vcd video\_finale.mpg
</span></span></code></pre></div><p>18.多通道编码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i fichierentree -pass 2 -passlogfile ffmpeg2pass fichiersortie-2
</span></span></code></pre></div><p>19.从flv提取mp3</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>ffmpeg -i source.flv -ab 128k dest.mp3
</span></span></code></pre></div><h2 id=22-媒体播放器三大底层框架><strong>2.2 媒体播放器三大底层框架</strong></h2><p>媒体播放工具，这里主要指视频播放，因为要面临庞大的兼容性和纷繁复杂的算法，从架构上看，能脱颖而出的体系屈指可数。大体来说业界主要有3大架构：MPC、MPlayer和VLC。这3大架构及其衍生品占领了90%的市场，凡是用户能看到的免费媒体播放软件，无一不是源自这3大架构。</p><p><strong>MPC/HC架构</strong></p><p><code></code>MPC（Media Player Classic）和它的后续者MPC-HC应该并列而说。MPC基于DirectShow架构，是Windows系统下元祖级别的播放器。包括KMP之流最早也就是抄来MPC的代码再换个界面。MPCHC则在MPC的原作者Gabest渐渐退出开发后的继承者，MPCHC有很多创新特性，包括开始融入ffmpeg和支持更多DirectX特性和DXVA等等。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.014.png alt></p><p>优点：更直接的支持DXVA，对一些稀奇古怪的Windows平台上的格式可以通过调用第三方的Filter组件等，拥有更好的兼容性</p><p>缺点：有人说DirectShow是Windows中最难掌握的SDK，开发复杂；DirectShow允许第三方封装的特点也让兼容性和稳定性问题复杂化；第三方Filter出现异常时非常难以分析处理，更难以复用；</p><p>射手播放器的架构主要来自MPC-HC，但更多的融合了FFmpeg的优势，对DirectShow Filter进行了多处改写，大大加强了对ffmpeg的利用，提高了解码稳定性，同时扩展了解码能力和兼容性。</p><p><strong>mplayer架构</strong></p><p>如果说MPC是Windows上的元祖，那么mplayer就是linux上媒体播放的元祖了。mplayer使用ffmpeg作为解码核心，也是与ffmpeg结合最紧密的项目，ffmpeg的代码就是由mplayer来host，开发者群也有非常大的交集。借助linux开发/使用者的强大实力，mplayer建立了要比DirectShow稳定的多的工作流程。超越ffmpeg本身的功能外，后来又通过反向工程使之可以调用Windows上的DirectShow Filter DLL，让mplayer架构越来越吸引人，成为兼具稳定性和性能的优秀作品。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.015.png alt></p><p>优点：稳定，兼容性也可以说相当不错</p><p>缺点：代码结构不清晰；纯C语言开发，难于阅读；显卡硬件加速还需要越过更多障碍</p><p><strong>VLC架构</strong></p><p>VLC是个后起之秀，开发速度的进展可以说是一只奇葩。虽然同样基于ffmpeg，但可能是相对于“左三年右三年缝缝补补又三年”的mplayer架构来说，VLC的架构在设计之初就很好的考虑到模块化开发，所以使它更吸引年轻的开发人员。成为近年发展非常快的架构。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.016.png alt></p><p>优点：稳定，兼容性也可以说相当不错</p><p>缺点：纯C语言开发，难于阅读；硬件加速略有障碍</p><p>很多人都会发现，3大架构中都可以看到ffmpeg的名字。说起ffmpeg，那真是”One Ring to rule them all，One Ring to find them, One Ring to bring them all“。在#ffmpeg有人和我说过，想不用ffmpeg去写媒体播放器，就像是造汽车而不用车轮。但是ffmpeg本身仅作为命令行工具或类库（常见的如libavcodec）出现。终端用户很少能直接接触到ffmpeg，所以知名度也较小。</p><h1 id=第三章-编译及简单应用><strong>第三章 编译及简单应用</strong></h1><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.017.png alt></p><h2 id=31-ffmpeg库编译和入门介绍-41><strong>3.1 FFmpeg库编译和入门介绍 41</strong></h2><p>FFmpeg的编译主要有linux和windows下面两种，linux下面简单，此处着重讲解windows下面的交叉编译：</p><ol start=0><li>官网直接获取exe</li></ol><p>ffmpeg的官方网站是：http://ffmpeg.org/</p><p>编译好的windows可用版本的下载地址（官网中可以连接到这个网站，和官方网站保持同步）： <a href=http://ffmpeg.zeranoe.com/builds/>http://ffmpeg.zeranoe.com/builds/</a></p><p>该网站中的FFMPEG分为3个版本：Static，Shared，Dev。</p><p>前两个版本可以直接在命令行中使用，他们的区别在于：Static里面只有3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe，每个exe的体积都很大，相关的Dll已经被编译到exe里面去了。Shared里面除了3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe之外，还有一些Dll，比如说avcodec-54.dll之类的。Shared里面的exe体积很小，他们在运行的时候，到相应的Dll中调用功能。</p><p>Dev版本是用于开发的，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。</p><p>打开系统命令行接面，切换到ffmpeg所在的目录，就可以使用这3个应用程序了。</p><p>ps ：建议大家跳过第0步，学会自己从源码开始编译调试</p><p>1、获取ffmpeg源码</p><p>下载网址：svn://svn.mplayerhq.hu/ffmpeg/trunk</p><p>首先需要安装svn客户端，我用的是TortoiseSVN，应该是可以很方便地从网上下载，下载之后安装。</p><p>安装之后，在你要保存ffmpeg源代码的位置上点右键，然后选择check out，输入以上的网址，包括前面的“svn:”，然后点OK按钮，它会把整个源代码下到本地，根据网速，可能几秒钟到几十分钟不等。</p><p>#tar -xvf ffmpeg-0.10.x.tar.bz2</p><p>#cd</p><p>#./configure</p><p>#make</p><p>#make install</p><p>2、搭建windows下的编译环境</p><p>2.1 mingw和msys</p><p>下载地址http://sourceforge.net/projects/mingw/</p><p>执行下载文件：mingw-get-setup.exe，选择下一步----安装路径：C:\MinGW（我直接采用默认路径，未做修改）</p><p><code></code>（提示：msys此处就不用下载了，mingw-get-setup.exe中已经包含了msys1.0,后面安装的时候就可以看到该选项。 ）</p><p><code></code>安装后会启用MinGW Installer，在Installation Package Settings中选择：</p><p><code></code>√ Basic Setup</p><p><code></code>√ All Packages</p><p><code></code>√ MinGW</p><p><code></code>MinGW Base System</p><p><code></code>MinGW Libraries</p><p><code></code>MinGW Contributed</p><p><code></code>MinGW Autotools</p><p><code></code>√ MSYS</p><p><code></code>MSYS Base System</p><p><code></code>MinGW Developer ToolKit</p><p><code></code>MSYS System Builder</p><p>等待安装完成（去倒杯水，或者听两首歌吧）！我的选择是把看上去有点熟悉的、会用到的package都装上！</p><p>也可以通过Installation Package Settings随时添加/删除需要的库文件，所以无需太过担心。</p><p>安装完成后，在C:\MinGW目录下可以看到 msys 文件夹，msys也已经安装。</p><p>ps：windows下MinGW-w64安装，这个我没有试过，有兴趣的朋友可以去试下 链接地址：http://blog.csdn.net/ayw_hehe/article/details/11761755</p><p>2.2 下载 yasm(汇编编译器)，也可以直接下载源码包进行编译安装</p><p>ffmpeg编译的时候里面的汇编代码需要yasm.exe</p><p>去官网：http://yasm.tortall.net/Download.html 下载</p><p>在Latest Release栏，直接下载：Win32 .exe (for general use on 32-bit Windows)</p><p>文件名类似为：yasm-1.2.0-win32.exe</p><p>2.3准备一个线程库（不准备编译x264的可以跳过）</p><p>下载 pthreadGC2.dll</p><p>pthreadgc2.dll是功能强大的处理数字化影视作品编辑软件premiere6运行所需的一个DLL文件。这是一个无威胁文件。属于Open Source Software community project的文件。</p><p><code></code>直接去baidu或google搜索下载就可以了。</p><p>3、配置 msys.bat 批处理文件</p><p>此处为了方便VS2010调用ffmpeg的动态库，可以通过配置让ffmpeg编译时产生windows下调用dll对应的lib，当然，如果你没有这个需要，那么就可以省略以下处理，直接进入步骤4。</p><p><code></code>进入：C:\MinGW\msys\1.0\文件夹，使用UltraEdit打开msys.bat文件，在文件的最最前面加入如下一行：</p><p><code></code>call "D:\Program Files\Microsoft Visual Studio 10.0\VC\bin\vcvars32.bat"</p><p><code></code>添加后效果如下：</p><p><code></code>call "D:\Program Files\Microsoft Visual Studio 10.0\VC\bin\vcvars32.bat"</p><p><code></code>@echo off</p><p><code></code>rem Copyright (C): 2001, 2002, 2003, 2004, 2005 Earnie Boyd</p><p><code></code>rem mailto:earnie@users.sf.net</p><p><code></code>rem This file is part of Minimal SYStem</p><p><code></code>rem <a href=http://www.mingw.org/msys.shtml>http://www.mingw.org/msys.shtml</a></p><p><code></code>rem</p><p><code></code>rem File: msys.bat</p><p><code></code>rem Revision: 2.4</p><p><code></code>rem Revision Date: December 8th, 2005</p><p><code></code>rem ember to set the "Start in:" field of the shortcut.</p><p><code></code>rem A value similar to C:\msys\1.0\bin is what the "Start in:" field needs</p><p><code></code>rem to represent.</p><p><code></code>其中“D:\Program Files\Microsoft Visual Studio 10.0”为你机器上安装VS200X或VS2010的目录，我的电脑安装的是VS2010，并且安装在了D盘。文件修改后保存即可。）</p><p><code></code>ps:不要告诉我 / 和 \ 的区别你不知道？！</p><p>4、系统整合</p><p>将fstab.sample改为fstab，用文本编辑器（需要使用一个支持Unix换行风格的编辑器，比如Notepad++，强烈推荐UltraEdit），把下面这行：</p><p>c:/MinGW/msys/1.0/mingw/mingw</p><p>改为：</p><p>c:/MinGW /mingw</p><p>完成以上步骤，MSys+MinGW系统就配置完成了。</p><p>**************************************************************************************</p><p>此处可以通过gcc -v进行判断，如果修改成功gcc将从版本3.4.4变为4.8.1，如果使用gcc3（低版本），编译安装的时候会报错的！！</p><p>ps:如果gcc版本过低，编译SDL的时候报错很头疼，虽然我通过在网上查找修改源代码通过了，但是坑太大！！</p><p>5、基本库</p><p>视情况而定，初次测试编译安装的时候，安装一个SDL就差不多了（有多少人不想要ffplay的？O(∩_∩)O~），其他的库可以后期再弄！</p><p>编译 mp3lame(可选项)</p><p><code></code>为了让编译出来的ffmpeg支持对mp3格式的编解码，您需要先下载lame。</p><p><code></code>到：http://sourceforge.net/projects/lame/files/ 下载</p><p><code></code>文件名类似为：lame-3.99.2.tar.gz 的包。</p><p><code></code>$ tar -zxvf lame-3.99.2.tar.gz</p><p><code></code>$ cd lame-3.99.2</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-shared (首选)</p><p>或: $./configure --disable-static --enable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译 x264(可选项)</p><p><code></code>为了让编译出来的ffmpeg支持对x264格式的编解码，您需要先下载x264。</p><p><code></code>到：http://www.videolan.org/developers/x264.html下载</p><p><code></code>文件名类似为：last_x264.tar.bz2 的包。</p><p><code></code>$ tar -xvf last_x264.tar.bz2</p><p><code></code>$ cd x264-20111124-2245</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --enable-shared --disable-asm</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译 Xvid(可选项)</p><p><code></code>为了让编译出来的ffmpeg支持对Xvid格式的编解码，您需要先下载Xvid。</p><p><code></code>到：http://www.xvid.org/ 下载</p><p><code></code>文件名类似为：xvidcore-1.3.2.tar.gz 的包。</p><p><code></code>$ tar -zxvf xvidcore-1.3.2.tar.gz</p><p><code></code>$ cd xvidcore/build/generic</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --prefix=C:/MinGW/msys/1.0/local</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下。</p><p><code></code>需要注意的就是：此处编译加上了路径</p><p><code></code>如果make时出现：cc1.exe: error: unrecognized command line option '-mno-cygwin' 错误，请在./configure后make之前修改xvidcore\build\generic里的 platform.inc文件，直接删除里面的“-mno-cygwin”。</p><p><code></code>具体可以参考：http://ffmpeg.zeranoe.com/forum/viewtopic.php?f=5&t=111里2楼的回答，如果按他说的：I recommend re running ./bootstrap.sh after you do this.，我发现不太行，一运行bootstrap.sh后，platform.inc文件会被还原，并且./configure时也会还原该文件，所以我选择在./configure后make前修改，可以编译通过，目前没检验Xvid是否可用。</p><p>编译 faad2(可选项)</p><p><code></code>到：http://www.audiocoding.com/downloads.html 下载：Version 2.7 bootstrapped TAR.GZ Package</p><p><code></code>文件名类似为：faad2-2.7.tar.gz 的包。</p><p><code></code>$ tar -zxvf faad2-2.7.tar.gz</p><p><code></code>$ cd faad2-2.7</p><p><code></code>再执行以下命令：</p><p><code></code>$./bootstrap</p><p><code></code>$./configure --disable-static --enable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译faac(可选项)</p><p><code></code>到：http://www.audiocoding.com/downloads.html 下载：Version 1.28 bootstrapped TAR.GZ Package</p><p><code></code>文件名类似为：faac-1.28.tar.gz 的包。</p><p><code></code>$ tar -zxvf faac-1.28.tar.gz</p><p><code></code>$ cd faac-1.28</p><p><code></code>再执行以下命令：</p><p><code></code>$./bootstrap</p><p><code></code>$./configure --disable-static --enable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译vo-aacenc (可选项)</p><p><code></code>到：http://sourceforge.net/projects/opencore-amr/files/ 下载：vo-aacenc</p><p><code></code>文件名类似为：vo-aacenc-0.1.1.tar.gz 的包。</p><p><code></code>$ tar -zxvf vo-aacenc-0.1.1.tar.gz</p><p><code></code>$ cd vo-aacenc-0.1.1</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译amr-nb和amr-wb (早期ffmpeg版本，可选项)</p><p><code></code>在编译amrnb和amrwb之前还需要做点其它的准备工作：</p><p><code></code>A 先到网上搜索下载wget工具，解压后放到C:\MinGW\bin目录下，此工具是个网络下载工具，用来在编译时自动下载3gpp源码。</p><p><code></code>B 再先到http://downloads.sourceforge.net/gnuwin32/unzip-5.51-1-bin.zip 下载unzip-5.51-1-bin.zip后进行解压，并把unzip-5.51-1-bin\bin中的unzip.exe拷贝到C:\MinGW\bin目录下，此工具用来在编译时自动解压3gpp源码。</p><p><code></code>到：http://www.penguin.cz/%7Eutx/amr 下载：amrnb-7.0.0.2.tar.bz2与amrwb-7.0.0.4.tar.bz2</p><p><code></code>$ tar -xvf amrnb-7.0.0.2.tar.bz2</p><p><code></code>$ cd amrnb-7.0.0.2</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-static --enable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p><code></code>$ tar -xvf amrwb-7.0.0.4.tar.bz2</p><p><code></code>$ cd amrwb-7.0.0.4</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-static --enable-shared</p><p><code></code>$ make</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译opencore-amr 和vo-amrwbenc (可选项)</p><p><code></code>到：http://sourceforge.net/projects/opencore-amr/files/ 下载：opencore-amr 与 vo-amrwbenc</p><p><code></code>文件名类似为：opencore-amr-0.1.2.tar.gz 与vo-amrwbenc-0.1.1.tar.gz 的包。</p><p><code></code>如果是opencore-amr-0.1.1.tar.gz请注释掉以下Makefile中的几行</p><p><code></code>文件: ./opencore-amr/amrnb/Makefile</p><p><code></code>install: libopencore-amrnb.a $(SHLIB)</p><p><code></code>install -d $(DESTDIR)$(PREFIX)/lib</p><p><code></code>install -m 644 libopencore-amrnb.a $(DESTDIR)$(PREFIX)/lib</p><p><code></code># install $(SHLIB) $(DESTDIR)$(PREFIX)/lib</p><p><code></code>ifneq ($(shell uname), Darwin)</p><p><code></code># ln -sf $(SHLIB) $(DESTDIR)$(PREFIX)/lib/$(SONAME)</p><p><code></code># ln -sf $(SONAME) $(DESTDIR)$(PREFIX)/lib/libopencore-amrnb.so</p><p><code></code>endif</p><p><code></code>文件: ./opencore-amr/amrwb/Makefile</p><p><code></code>install: libopencore-amrwb.a $(SHLIB)</p><p><code></code>install -d $(DESTDIR)$(PREFIX)/lib</p><p><code></code>install -m 644 libopencore-amrwb.a $(DESTDIR)$(PREFIX)/lib</p><p><code></code># install $(SHLIB) $(DESTDIR)$(PREFIX)/lib</p><p><code></code>ifneq ($(shell uname), Darwin)</p><p><code></code># ln -sf $(SHLIB) $(DESTDIR)$(PREFIX)/lib/$(SONAME)</p><p><code></code># ln -sf $(SONAME) $(DESTDIR)$(PREFIX)/lib/libopencore-amrwb.so</p><p><code></code>endif</p><p><code></code>$ tar -zxvf opencore-amr-0.1.2.tar.gz</p><p><code></code>$ cd opencore-amr-0.1.2</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-shared</p><p><code></code>$ make CC=gcc</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p><code></code>$ tar -zxvf vo-amrwbenc-0.1.1.tar.gz</p><p><code></code>$ cd vo-amrwbenc-0.1.1</p><p><code></code>再执行以下命令：</p><p><code></code>$./configure --disable-shared</p><p><code></code>$ make CC=gcc</p><p><code></code>$ make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p>编译SDL(可选项)</p><p><code></code>SDL下载可以到：http://www.libsdl.org/download-1.2.php</p><p><code></code>在Source Code栏选择类似：SDL-1.2.14.tar.gz - GPG signed 进行下载，</p><p><code></code>文件名类似为：SDL-1.2.14.tar.tar，此文件需要编译才能生成lib库。</p><p><code></code>也可以直接下载 SDL-devel-1.2.14-mingw32.tar.gz (Mingw32)，文件名类似为：SDL-devel-1.2.14-mingw32.tar.tar，此文件带有编译好的lib，在编译ffmpeg时可以直接使用。</p><p><code></code>$ tar -zxvf SDL-1.2.14.tar.gz</p><p><code></code>$ cd SDL-1.2.14</p><p><code></code>再执行以下命令：</p><p><code></code>./configure</p><p><code></code>make</p><p><code></code>make install</p><p><code></code>编译结果在：C:\MinGW\msys\1.0\local 目录下</p><p><code></code>注意：如果是使用编译好的SDL-devel-1.2.14-mingw32.tar.tar，那么就可以省掉上面的编译工作，直接解压SDL-devel-1.2.14-mingw32.tar.tar文件即可。自己编译或直接使用编译好的都需要做下面的修改和拷贝工作。</p><p><code></code>使用UltraEdit打开C:\MinGW\msys\1.0\local\bin下的 sdl-config文件</p><p><code></code>把 prefix=/usr 该成： prefix=c:/mingw</p><p><code></code>其中：c:/mingw 为 mingw的安装路径，请根据你的安装进行修改。为了编译时msys能识别sdl并开启 SDL support yes 进行编译，请把C:\MinGW\msys\1.0\local编译结果bin、include和lib中有关sdl的拷贝一份到C:\MinGW\的对应目录中。</p><p>6、编译安装ffmpeg</p><p>lib 动态链接库位置</p><p>include 编程要用到头文件</p><p>bin 执行文件所在的目录</p><p>(为了以后方便编程，我们把lib中的三个链接库libavcodec.so libavformat.so libavutil.so复制到/usr/lib下。把include目录下的ffmpeg目录复制到/usr/include下)</p><p>***************************************************************************</p><p><code></code>但是我编译完没有ffserver.exe,网上说是因为MinGW里面少了关于ffserver用的网络的相关的包。</p><p>参考http://bbs.chinavideo.org/viewthread.php?tid=95。</p><p>单独使用ffplay，需要将c:/msys/1.0/mingw/bin/SDL.dll和ffplay.exe放到相同的目录下。</p><p>6.1 编译静态库</p><p><code></code>配置</p><p>在shell提示符下输入：</p><p>./configure --enable-static --enable-memalign-hack --prefix=c:/msys/1.0 --extra-cflags="-fno-common"</p><p>这个过程要花费较长的时间，开始会有较长的时间没有反应。其中的prefix是msys的安装路径</p><p><code></code>编译</p><p>make</p><p>安装</p><p>make install</p><p>安装只是把要开发使用的库文件拷贝到c:/msys/1.0/lib/目录中，头文件拷贝到c:/msys/1.0/include/目录中。</p><p>产生的库文件为.a文件</p><p>6.2 编译动态库</p><p>动态库和静态库只在配置上的差别，配置如下：</p><p>./configure --enable-shared --disable-static --enable-memalign-hack --prefix=c:/msys/1.0 --extra-cflags="-fno-common"</p><p>后面的步骤一样：</p><p>make</p><p>make install</p><p>在开始编译之前，可以把原来编译的目标 文件清除掉：</p><p>make clean</p><p>动态编译应该是会产生lib文件，但是我编译之后一直没有产生</p><p>编译之后的dll文件被放到了ffmpeg目录下，可以搜索查看它们</p><p>7、开发</p><p>如果写了一个test.c文件，要包含ffmpeg的头文件，可以这样写：</p><p>#include</p><p>编译：gcc -o test test.c -lavformat -lavcodec -lavtuil (前提是有第6步的操作)</p><p>如果没有第6步的操作，则编译的时候如下：</p><p>gcc -o test test.c -I/usr/local/ffmpeg/include -L/usr/local/ffmpeg/lib -lavformat -lavcodec -lavtuil</p><p>编译成功之后，执行的时候还是需要动态库的支持，还是要把那三个动态库文件复制到/usr/lib或者/lib中，不然执行的时候会说找不到动态库链接。</p><p>还有一个方法可以解决这个问题，就是把/usr/local/ffmpeg/lib这个目录加入到/etc/ld.so.config中，然后执行ldconfig，或者重启电脑，这样执行</p><p>的时候系统就可以从/usr/local/ffmpeg/lib这个目录下去找这三个动态库文件了。</p><p>以上的方式是采用动态库编译ffmpeg的，如果在configure的时候不加上--enable-shared的，则采用静态链接的方式，不会生成那三个动态库。同时</p><p>生成的ffplay、ffmpeg的执行文件也比较的大，因为他们不需要动态库的支持，就可以执行。但是不利于再次开发，所以我采用动态链接的方式。</p><p>configure中还有很多的选项，可以通过./configure --help查看，也可以直接查看configure文件。这在配置的时候很重要。</p><h2 id=32-流媒体数据流程讲解><strong>3.2 流媒体数据流程讲解</strong></h2><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.018.png alt></p><p>FFMpeg 的 output_example.c 例子分析</p><p>该例子讲了如何输出一个 libavformat 库所支持格式的媒体文件。</p><p>（1）av_regis ter_all()，初始化 libavcodec 库，并注册所有的编解码器和格式。</p><p>（2）guess_form at()，根据文件名来获取输出文件格式，默认为 mpeg。</p><p>（3）av_alloc_form at_context()分配输出媒体内容。</p><p>ov->oform at = fm t;</p><p>s nprintf( oc->filename, sizeof(oc->filename), “%s ”, filenam e );</p><p>（4）add_video_s tream ()使用默认格式的编解码器来增加一个视频流，并初始化编解码器。</p><p>（4.1）av_new_s tream ()增加一个新的流到一个媒体文件。</p><p>（4.2）初始化编解码器：</p><p>c = s t->codec;</p><p>c->codec_id = codec_id;</p><p>c->codec_type = CODEC_TYPE_ VIDEO;</p><p>c->bit_rate = 400000;</p><p>c->width = 352;</p><p>c->height = 288;</p><p>c->tim e_base.den = STREAM_FR AME_RATE ; //每秒 25 副图像</p><p>c->tim e_base.num = 1;</p><p>c->gop_size = 12;</p><p>c->pix_fm t = STREAM_PIX_FMT; //默认格式为 P IX_FMT_ YUV420P</p><p>…… ……</p><p>（5）av_s et_parameters ()设置输出参数，即使没有参数，该函数也必须被调用。</p><p>（6）dum p_form at()输出格式信息，用于调试。</p><p>（7）open_video()打开视频编解码器并分配必要的编码缓存。</p><p>（7.1）avcodec_find_encoder()寻找 c->codec_id 指定的视频编码器。</p><p>（7.2）avcodec_open()打开编码器。</p><p>（7.3）分配视频输出缓存：</p><p>video_outbuf_s ize = 200000;</p><p>video_outbuf = av_m alloc( video_outbuf_s ize );</p><p>（7.4）picture = alloc_picture()分配原始图像。</p><p>（7.4.1）avcodec_alloc_frame()分配一个 AVFram e 并设置默认值。</p><p>（7.4.2）s ize = avpicture_get_s ize()计算对于给定的图片格式以及宽和高，所需占用多少 内存。</p><p>（7.4.3）picture_buf = av_malloc( s ize )分配所需内存。</p><p>（7.4.4）avpicture_fill()填充 AVPicture 的域。</p><p>（7.5）可选。如果输出格式不是 YUV420P，那么临时的 YU V420P 格式的图像也是需要的，由 此再转换为我们所需的格式，因此需要为临时的 YU V420P 图像分配缓存：</p><p>tm p_picture = alloc_picture()</p><p>说明：tm p_picture，picture，video_outbuf。如果输出格式为 YUV420P，则直接通过 avcodec_</p><p>encode_video()函数将 picture 缓存中的原始图像编码保存到 video_outbuf 缓存中；如果输出格式不 是 YU V420P，则需要先通过 sws _s cale()函数，将 YUV420P 格式转换为目标格式，此时 tm p_picture 缓 存存放的是 YU V420P 格式的图像，而 picture 缓存为转换为目标格式后保存的图像，进而再将 picture 缓</p><p>存中的图像编码保存到 video_outbuf 缓存中。</p><p>（8）url_fopen()打开输出文件，如果需要的话。</p><p>（9）av_write_header()写流动头部。</p><p>（10）LOOP 循环{</p><p>计算当前视频时间 video_pts 是否超时退出循环？ write_video_fram e()视频编码</p><p>}</p><p>（10.1）write_video_frame()</p><p>如果图片不是 YU V420P，则需要用 sws _s cale()函数先进行格式转换。 若需要原始图像：</p><p>av_init_packet()初始化一个包的选项域。</p><p>av_write_fram e()向输出媒体文件写一个包，该包会包含一个视频帧。 若需要编码图像：</p><p>avcodec_encode_video()编码一视频帧。</p><p>av_init_packet()</p><p>av_write_fram e()</p><p>（11）close_video()关闭每个编解码器。</p><p>（12）av_write_trailer()写流的尾部。</p><p>（13）释放资源</p><p>av_freep()释放 AVForm atContext 下的 AVS tream ->AVCodecContext 和 AVStream ：</p><p>for( i = 0; i &lt; oc->nb_s treams ; i++ ){</p><p>av_freep( &oc->s treams [i]->codec );</p><p>av_freep( &oc->s treams [i] );</p><p>}</p><p>url_fclose()关闭输出文件。</p><p>av_free()释放 AVForm atContext。</p><h2 id=33-简单应用><strong>3.3 简单应用</strong></h2><p>PS:此处举tutorial的例子是为了更好的引出一个循序渐进的例程。条件适当的话添加output_example.c实例并进行说明。</p><p>FFmpeg tutorial对初级的掌握以及使用ffmpeg有重要指导作用，但是里面的一些函数没有实时更新了，tutorial01~08是一个播放器开发的由浅入深的过程，下面介绍tutorial01（tutorial 02~08详见附录）使用源码：</p><p>/************************************************************************/</p><p><code></code>/* tutorial1 制作屏幕录像</p><p><code></code>执行后，将视频文件按照一定的格式保存为.ppm文件 */</p><p>/************************************************************************/</p><p>#include "libavcodec/avcodec.h"</p><p>#include "libavformat/avformat.h"</p><p>#include "libswscale/swscale.h"</p><p>#include &lt;windows.h></p><p>#include &lt;stdio.h></p><p>void SaveFrame(AVFrame *pFrame, int width, int height, int iFrame) {</p><p><code></code>FILE *pFile;</p><p><code></code>char szFilename[32];</p><p><code></code>int y;</p><p><code></code>// Open file</p><p><code></code>sprintf(szFilename, "frame%d.ppm", iFrame);</p><p><code></code>pFile=fopen(szFilename, "wb");</p><p><code></code>if(pFile==NULL)</p><p><code></code>return;</p><p><code></code>// Write header</p><p><code></code>fprintf(pFile, "P6\n%d %d\n255\n", width, height);</p><p><code></code>// Write pixel data</p><p><code></code>for(y=0; y&lt;height; y++)</p><p><code></code>fwrite(pFrame->data[0]+y*pFrame->linesize[0], 1, width*3, pFile);</p><p><code></code>// Close file</p><p><code></code>fclose(pFile);</p><p>}</p><p>int main(int argc, char *argv[])</p><p>{</p><p><code></code>AVFormatContext *pFormatCtx;</p><p><code></code>int i,videoStream;</p><p><code></code>AVCodecContext *pCodecCtx;</p><p><code></code>AVCodec *pCodec;</p><p><code></code>AVFrame *pFrame;</p><p><code></code>AVFrame *pFrameRGB;</p><p><code></code>AVPacket packet;</p><p><code></code>int frameFinished;</p><p><code></code>int numBytes;</p><p><code></code>uint8_t *buffer;</p><p><code></code>if (argc &lt; 2)</p><p><code></code>{</p><p><code></code>printf("please provide a movie file\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>//register all formats and codes</p><p><code></code>av_register_all();</p><p><code></code>//support network stream input</p><p><code></code>avformat_network_init();</p><p><code></code>pFormatCtx = avformat_alloc_context();</p><p><code></code>//Open the media file and read the header</p><p><code></code>if(avformat_open_input(&pFormatCtx,argv[1],NULL,NULL) != 0)</p><p><code></code>{</p><p><code></code>printf("couldn't open file \n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>//retrieve stream information</p><p><code></code>if (av_find_stream_info(pFormatCtx) &lt; 0 )</p><p><code></code>return -1;</p><p><code></code>//dump information about file into standard error</p><p><code></code>av_dump_format(pFormatCtx,-1,argv[1],0);</p><p><code></code>// Find the first video stream</p><p><code></code>videoStream = -1;</p><p><code></code>for (int i = 0 ;i &lt; pFormatCtx->nb_streams; i++ )</p><p><code></code>if (pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)</p><p><code></code>{</p><p><code></code>videoStream = i ;</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>if (videoStream == -1)</p><p><code></code>return -1;</p><p><code></code>//get a pointer to the codec context for the video stream</p><p><code></code>pCodecCtx = pFormatCtx ->streams[videoStream]->codec;</p><p><code></code>pCodec = avcodec_find_decoder(pCodecCtx->codec_id);</p><p><code></code>if (pCodec == NULL)</p><p><code></code>{</p><p><code></code>fprintf(stderr,"unsupported codec \n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>//open codec</p><p><code></code>if(avcodec_open2(pCodecCtx,pCodec,NULL) &lt; 0 )</p><p><code></code>return -1;</p><p><code></code>//allocate video frame</p><p><code></code>pFrame = avcodec_alloc_frame();</p><p><code></code>if(NULL == pFrame )</p><p><code></code>return -1;</p><p><code></code>//allocate an avframe structure</p><p><code></code>pFrameRGB = avcodec_alloc_frame();</p><p><code></code>if (pFrameRGB == NULL)</p><p><code></code>return -1;</p><p><code></code>//determine required buffer size and allocate buffer</p><p><code></code>numBytes = avpicture_get_size(PIX_FMT_RGB24,pCodecCtx->width,pCodecCtx->height);</p><p><code></code>//buffer = (uint8_t *)av_malloc_attrib(numBytes * sizeof(uint8_t));</p><p><code></code>buffer = (uint8_t *)av_malloc(numBytes * sizeof(uint8_t));</p><p><code></code>avpicture_fill((AVPicture *)pFrameRGB,buffer,PIX_FMT_RGB24,pCodecCtx->width,pCodecCtx->height);</p><p><code></code>i = 0;</p><p><code></code>while (av_read_frame(pFormatCtx,&packet)>=0)</p><p><code></code>{</p><p><code></code>if (packet.stream_index == videoStream)</p><p><code></code>{</p><p><code></code>avcodec_decode_video2(pCodecCtx,pFrame,&frameFinished,&packet);</p><p><code></code>if( frameFinished )</p><p><code></code>{</p><p><code></code>struct SwsContext *img_convert_ctx = NULL;</p><p><code></code>img_convert_ctx =sws_getCachedContext(img_convert_ctx, pCodecCtx->width,pCodecCtx->height, \</p><p><code></code>pCodecCtx->pix_fmt,pCodecCtx->width, pCodecCtx->height,PIX_FMT_RGB24, SWS_BICUBIC,NULL, NULL, NULL);</p><p><code></code>if( !img_convert_ctx )</p><p><code></code>{</p><p><code></code>fprintf(stderr, "Cannot initialize sws conversion context\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/*</p><p><code></code>int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],</p><p><code></code>const int srcStride[], int srcSliceY, int srcSliceH,</p><p><code></code>uint8_t *const dst[], const int dstStride[]);</p><p><code></code>*/</p><p><code></code>sws_scale(img_convert_ctx, pFrame->data,\</p><p><code></code>pFrame->linesize, 0, pCodecCtx->height, pFrameRGB->data,pFrameRGB->linesize);</p><p><code></code>if( i++ &lt; 50 )</p><p><code></code>SaveFrame(pFrameRGB, pCodecCtx->width, pCodecCtx->height, i);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>av_free_packet(&packet);</p><p><code></code>}</p><p><code></code>//free the RGB image</p><p><code></code>av_free(buffer);</p><p><code></code>av_free(pFrameRGB);</p><p><code></code>av_free(pFrame);</p><p><code></code>avcodec_close(pCodecCtx);</p><p><code></code>av_close_input_file(pFormatCtx);</p><p>}</p><h2 id=34-sdl-simple-direct-layer><strong>3.4 SDL（ Simple Direct Layer）</strong></h2><p>它是一个出色的多媒体库，适用于 PC 平台，并且已经应用在许多工 程中，它是如此的优秀，甚至已移植到某些手机平台上。它的官方网站是 <a href=http://www.libsdl.org/>http://www.libsdl.org/，在这个网</a>站上可以下载 SDL 库的源代码自己编译库，也可以直接下载预编译库。</p><h3 id=341-sdl显示视频><strong>3.4.1 SDL显示视频</strong></h3><p>SDL 显示视频图像函数调用序列如下，忽略掉错误处理：</p><p>1):初始化 SDL 库，</p><p>SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)</p><p>2):创建显示表面，</p><p>SDL_Surface *screen = SDL_SetVideoMode(width, height, 0, 0)</p><p>3):创建Overlay表面，</p><p>SDL_Overlay *bmp = SDL_CreateYUVOverlay(width, height, SDL_YV12_OVERLAY, screen)</p><p>4):取得独占权和 Overlay 表面首地址， SDL_LockYUVOverlay(bmp);</p><p>5):填充视频数据，纹理数据</p><p>6):释放独占权， SDL_UnlockYUVOverlay(bmp);</p><p>7):刷新视频， SDL_DisplayYUVOverlay(bmp, &rect);</p><h3 id=342-sdl显示音频><strong>3.4.2 SDL显示音频</strong></h3><p>SDL 播放音频采用回调函数的方式来保证音频的连续性，在设置音频输出参数，向系统注册回调函数后，每 次写入的音频数据播放完，系统自动调用注册的回调函数，通常在此回调函数中继续往系统写入音频数据。</p><p>SDL 播放音频函数调用序列，忽略掉错误处理：</p><p>1):初始化 SDL_AudioSpec 结构，此结构包括音频参数和回调函数，比如 SDL_AudioSpec wanted_spec；</p><p>wanted_spec.userdata = is; wanted_spec.channels = 2; wanted_spec.callback = sdl_audio_callback;</p><ol start=2><li>......</li><li>:打开音频设备 SDL_OpenAudio(&wanted_spec, &spec)；</li></ol><p>3)激活 音频设备开始工作 SDL_PauseAudio(0);</p><p>4)在音频回调函数中写入音频数据，示意代码如下</p><p>void sdl_audio_callback(void *opaque, Uint8 *stream, int len)</p><p>{</p><p>memcpy(stream, (uint8_t*)audio_buf, len);</p><p>}</p><ol start=5><li>: 播放完后关闭音频 SDL_CloseAudio();</li></ol><h2 id=35-ffmpeg程序的使用ffmpegexeffplayexeffprobeexe><strong>3.5 ffmpeg程序的使用（ffmpeg.exe，ffplay.exe，ffprobe.exe）</strong></h2><h3 id=351-ffmpegexe><strong>3.5.1 ffmpeg.exe</strong></h3><p>ffmpeg是用于转码的应用程序。</p><p>一个简单的转码命令可以这样写：</p><p>将input.avi转码成output.ts，并设置视频的码率为640kbps</p><p>#ffmpeg -i input.avi -b:v 640k output.ts</p><p>具体的使用方法可以参考： ffmpeg参数中文详细解释</p><p>详细的使用说明（英文）：<a href=http://ffmpeg.org/ffmpeg.html>http://ffmpeg.org/ffmpeg.html</a></p><h3 id=352-ffplayexe><strong>3.5.2 ffplay.exe</strong></h3><p>ffplay是用于播放的应用程序。</p><p>一个简单的播放命令可以这样写：</p><p>播放test.avi</p><p>#ffplay test.avi</p><p>具体的使用方法可以参考：ffplay的快捷键以及选项</p><p>详细的使用说明（英文）：<a href=http://ffmpeg.org/ffplay.html>http://ffmpeg.org/ffplay.html</a></p><h3 id=353-ffprobeexe><strong>3.5.3 ffprobe.exe</strong></h3><p>ffprobe是用于查看文件格式的应用程序。</p><p>这个就不多介绍了。</p><p>详细的使用说明（英文）：<a href=http://ffmpeg.org/ffprobe.html>http://ffmpeg.org/ffprobe.html</a></p><h1 id=第四章-数据结构><strong>第四章 数据结构</strong></h1><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.019.png alt></p><p>注：ByteIOContext→AVIOContext</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>ffmpeg定义的数据结构很有特色:</p><p>有一些是动态与静态的关系，比如， URLProtocol 和 URLContex t ，AVInputFormat 和 AVFormatContext ， AVCodec 和 AVCodecContext。从前面播放器的一般原理我们可知，播放器内部要实现的几大功能是，读文件， 识别格式，音视频解码，音视频渲染。其中音视频渲染由 SDL 实现，我们不讨论。ffplay 把其他的每个大功能抽 象成一个相当于 C++ 中 COM 接口的数据结构，着重于功能函数，同时这些功能函数指针在编译的时候就能静态 确定。每一个大功能都要支持多种类型的广义数据，ffplay 把这多种类型的广义数据的共同的部分抽象成对应的 Context 结构，这些对应的 context 结构着重于动态性，其核心成员只能在程序运行时动态确定其值。并且 COM 接口类的数据结构在程序运行时有很多很多实例，而相应的 Context 类只有一个实例，这里同时体现了数据结构 的划分原则，如果有一对多的关系就要分开定义。</p><p>有一些是指针表述的排他性包含关系(因为程序运行时同一类型的多种数据只支持一种，所以就有排他性 )。 比如，AVCodecContex t 用 priv_dat a 包含 MsrleContex t 或 TSContext，AVFormatContext 用 priv_dat a 包含 AVIContext 或其他类 Context，AVStream 用 priv_dat a 包含 AVIStream 或其他类 Stream。由前面数据结构的动态与静态关系 可知，ffplay 把多种类型的广义数据的共同部分抽象成 context 结构，那么广义数据的各个特征不同部分就抽象成 各种具体类型的 context，然后用 priv_dat a 字段表述的指针排他性的关联起来。由于瘦身后的 ffplay 只支持有限 类型，所以 AVFormatContext 只能关联包含 AVIContext，AVStream 只能关联包含 AVIStream。</p><p>有一些是扩展包含关系，比如，ByteIOCon text 包含 URLContext ，就是在应用层把没有缓存的 URLContext</p><p>扩展有缓冲区的广义文件 ByteIOCon text ，改善程序 IO 性能。</p><p>有一些是直接包含关系，比如，AVFrame 包含 AVPicture，这两个结构共有的字段，其定义类型、大小、顺 序都一模一样，除了更准确的描述各自的意义便于阅读理解维护代码外，还可以方便的把 AVFrame 大结构强制 转换 AVPicture 小结构。</p><p>我们先来重点分析 AVCodec/AVCodecContext/MsrleContex t 这几个数据结构，这几个数据结构定义了编解码 器的核心架构，相当于 Directshow 中的各种音视频解码器 decoder。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.021.jpeg alt></p><p>解协议（http,rtsp,rtmp,mms）→解封装（flv,avi,rmvb,mp4）→解码h264,mpeg2,aac,mp3）→存数据</p><h2 id=41--avcodec结构体><strong>4.1 AVCodec结构体</strong></h2><p>typedef struct AVCodec</p><p>{</p><p>// 标示Codec 的名字, 比如，"h264" "h263" 等。</p><p>const char *name;</p><p>// 标示Codec 的类型，有video ，audio等类型。</p><p>enum CodecType type;</p><p>// 标示Codec 的ID，有CODEC_ID_H264等。</p><p>enum CodecID id;</p><p>// 标示具体的Codec 对应的Context 的size,如：H264Context。</p><p>int priv_data_size;</p><p>// 以下标示Codec 对外提供的操作,每一种解码器都会实现这些操作。</p><p>int(*init)(AVCodecContext*);</p><p>int(*encode)(AVCodecContext *, uint8_t *buf, int buf_size, void *data);</p><p>int(*close)(AVCodecContext*);</p><p>int(*decode)(AVCodecContext *, void *outdata, int *outdata_size, uint8_t *buf, int buf_size);</p><p>struct AVCodec *next;</p><p>}AVCodec;</p><p>H264的主要结构的初始化如下：</p><p>AVCodec ff_h264_decoder = {</p><p><code></code>"h264",</p><p><code></code>AVMEDIA_TYPE_VIDEO,</p><p><code></code>CODEC_ID_H264,</p><p><code></code>sizeof(H264Context),</p><p><code></code>ff_h264_decode_init,</p><p><code></code>NULL,</p><p><code></code>ff_h264_decode_end,</p><p><code></code>decode_frame</p><p>}</p><p>说明：</p><p>AVCodec 是类似 COM 接口的数据结构，表示音视频编解码器，着重于功能函数，一种媒体类型对应一个 AVCodec 结构，在程序运行时有多个实例。next 变量用于把所有支持的编解码器连接成链表，便于遍历查找；id 确定了 唯 一编 解 码器 ； priv_data_size 表示具 体 的 Codec 对应的 Context 结构大 小 ，比 如 MsrleContext 或 TSContext，这些具体的结够定义散落于各个.c 文件中，为避免太多的 if else 类语句判断类型再计算大小，这里 就直接指明大小，因为这是一个编译时静态确定的字段，所以放在 AVCodec 而不是 AVCodecContex t 中。</p><h2 id=42--avcodeccontext结构体><strong>4.2 AVCodecContext结构体</strong></h2><p>typedef struct AVCodecContext</p><p>{</p><p>int bit_rate;</p><p>int frame_number;</p><p>//扩展数据，如mov格式中audio trak中aac格式中esds的附加解码信息。</p><p>unsigned char *extradata;</p><p>//扩展数据的size</p><p>int extradata_size;</p><p>//视频的原始的宽度与高度</p><p>int width, height; // 此逻辑段仅针对视频</p><p>//视频一帧图像的格式，如YUV420</p><p>enum PixelFormat pix_fmt;</p><p>//音频的采样率</p><p>int sample_rate;</p><p>//音频的声道的数目</p><p>int channels;</p><p>int bits_per_sample;</p><p>int block_align;</p><p>// 指向相应的解码器，如：ff_h264_decoder</p><p>struct AVCodec *codec;</p><p>//指向具体相应的解码器的context，如H264Context</p><p>void *priv_data;</p><p>//公共操作函数</p><p>int(*get_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>void(*release_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>int(*reget_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>}AVCodecContext;</p><p>说明：</p><p>AVCodecContext 结构表示程序运行的当前Codec 使用的上下文，着重于所有Codec 共有的属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。extradata 和extradata_size 两个字段表述了相应Codec 使用的私有数据；codec 字段关联相应的编解码器；priv_data 字段关联各个具体编解码器独有的属性context，和AVCodec 结构中的priv_data_size 配对使用。</p><h2 id=43--avinputformat结构体><strong>4.3 AVInputFormat结构体</strong></h2><p>typedef struct AVInputFormat</p><p>{</p><p>// 标示format的名字, 比如，“mov” “mp4” 等。</p><p>const char *name;</p><p>// 标示具体的format对应的Context 的size,如：MovContext。</p><p>int priv_data_size;</p><p>//具体的操作函数</p><p>int(*read_probe)(AVProbeData*);</p><p>int(*read_header)(struct AVFormatContext *,AVFormatParameters *ap);</p><p>int(*read_packet)(struct AVFormatContext *, AVPacket *pkt);</p><p>int(*read_close)(struct AVFormatContext*);</p><p>struct AVInputFormat *next;</p><p>} AVInputFormat;</p><p>Mov或mp4的主要结构的初始化如下：</p><p>AVInputFormat ff_mov_demuxer = {</p><p><code></code>"mov,mp4,m4a,3gp,3g2,mj2",</p><p><code></code>NULL_IF_CONFIG_SMALL("QuickTime/MPEG-4/Motion JPEG 2000 format"),</p><p><code></code>sizeof(MOVContext),</p><p><code></code>mov_probe,</p><p><code></code>mov_read_header,</p><p><code></code>mov_read_packet,</p><p><code></code>mov_read_close,</p><p><code></code>mov_read_seek,</p><p>}</p><p>说明：</p><p>AVInputFormat 是类似COM 接口的数据结构，表示输入文件容器 格式，着重于功能函数，一种文件容器格式对应一个AVInputFormat 结构，在程序运行时有多个实例。next变量用于把所有支持的输入文件容器格式连接成链表，便于遍历查找。priv_data_size 标示具体的文件容器格式对应的Context的大小，在本例中是MovContext，这些具体的结够定义散落于各个.c 文件中。</p><h2 id=44--avformatcontext结构体><strong>4.4 AVFormatContext结构体</strong></h2><p>typedef struct AVFormatContext</p><p>{</p><p>//指向AVInputFormat，如对于mp4或mov为ff_mov_demuxer</p><p>struct AVInputFormat *iformat;</p><p>// 指向具体的格式对应的Context，如：MovContext。</p><p>void *priv_data;</p><p>//指向数据读取统一接口context</p><p>ByteIOContext pb;</p><p>//流的数目</p><p>int nb_streams;</p><p>//至少2个指针元素分别指向video stream和audio stream</p><p>AVStream *streams[MAX_STREAMS];</p><p>} AVFormatContext;</p><p>说明：</p><p>AVFormatContext 结构表示程序运行的当前文件容器格式使用的上下文，着重于所有文件容器共有的属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。iformat字段关联相应的文件容器格式；pb 关联广义的输入文件；streams 关联音视频流；priv_data 字段关联各个具体文件容器独有的属性上下文，和priv_data_size 配对使用。</p><h2 id=45--movcontext结构体><strong>4.5 MovContext结构体</strong></h2><p>typedef struct MovContext</p><p>{</p><p><code></code>//临时持有AVFormatContext 的指针</p><p><code></code>AVFormatContext *fc;</p><p><code></code>//时间缩放因子</p><p>int time_scale;</p><p>//视频的时长</p><p>int64_t duration;</p><p>//拆包时是否发现”moov“头</p><p>int found_moov;</p><p>//拆包时是否发现"mdat"头</p><p>int found_mdat;</p><p>int isom;</p><p>MOVFragment fragment;</p><p>MOVTrackExt *trex_data;</p><p><code></code>unsigned trex_count;</p><p><code></code>int itunes_metadata; ///&lt; metadata are itunes style</p><p>int chapter_track;</p><p>} MOVContext;</p><p>说明：</p><p>MOVContext定义了mp4 中流的一些属性。</p><h2 id=46--urlprotocol结构体><strong>4.6 URLProtocol结构体</strong></h2><p>typedef struct URLProtocol</p><p>{</p><p>const char *name;</p><p>//用的统一的模板函数</p><p>int(*url_open)(URLContext *h, const char *filename, int flags);</p><p>int(*url_read)(URLContext *h, unsigned char *buf, int size);</p><p>int(*url_write)(URLContext *h, unsigned char *buf, int size);</p><p>offset_t(*url_seek)(URLContext *h, offset_t pos, int whence);</p><p>int(*url_close)(URLContext *h);</p><p>struct URLProtocol *next;</p><p>} URLProtocol;ffurl_connect</p><p>file的主要结构的初始化如下：</p><p>URLProtocol ff_file_protocol = {</p><p><code></code>.name = "file",</p><p><code></code>.url_open = file_open,</p><p><code></code>.url_read = file_read,</p><p><code></code>.url_write = file_write,</p><p><code></code>.url_seek = file_seek,</p><p><code></code>.url_close = file_close,</p><p><code></code>.url_get_file_handle = file_get_handle,</p><p><code></code>.url_check = file_check,</p><p>}</p><p>说明：</p><p>URLProtocol 是类似COM 接口的数据结构，表示广义的输入文件，着重于功能函数，一种广义的输入文件对应一个URLProtocol 结构，比如file，pipe，tcp 等等，定义了对file tcp等方式的通用模板函数。next 变量用于把所有支持的广义的输入文件连接成链表，便于遍历查找。</p><h2 id=47--urlcontext结构体><strong>4.7 URLContext结构体</strong></h2><p>typedef struct URLContext</p><p>{</p><p><code></code>//指向相应的协议(协议为从初始化链表中注册的),如ff_file_protocol</p><p>struct URLProtocol *prot;</p><p>int flags;</p><p>int max_packet_size;</p><p>//相应通信方式的句柄，对于文件为fd句柄，对于网络为socket句柄等</p><p>void *priv_data;</p><p>//文件的名字，不区分本地和网络</p><p>char *filename;</p><p>} URLContext</p><p>说明：</p><p>URLContext 结构表示程序运行的当前广义输入文件使用的context，着重于所有广义输入文件共有的属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。prot 字段关联相应的广义输入文件；priv_data 字段关联各个具体广义输入文件的句柄。</p><h2 id=48--aviocontext结构体老版本为byteiocontext><strong>4.8 AVIOContext结构体(老版本为：ByteIOContext)</strong></h2><p>typedef struct ByteIOContext</p><p>{</p><p>//数据缓冲区</p><p>unsigned char *buffer;</p><p>//数据缓冲size</p><p>int buffer_size;</p><p>//数据读取标记指针</p><p>unsigned char *buf_ptr, *buf_end;</p><p>//该指针指向相应的URLContext，关联URLContext</p><p>void *opaque;</p><p>int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);</p><p>int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);</p><p>offset_t(*seek)(void *opaque, offset_t offset, int whence);</p><p>//当前buffer在文件中的位置</p><p>offset_t pos;</p><p>//表示要进行seek，冲刷数据</p><p>int must_flush;</p><p>//是否到达了文件末尾</p><p>int eof_reached; // true if eof reached</p><p>int write_flag;</p><p>int max_packet_size;</p><p>int error; // contains the error code or 0 if no error happened</p><p>} ByteIOContext;</p><p>说明：</p><p>ByteIOContext 结构扩展URLProtocol 结构成内部有缓冲机制的广泛意义上的文件，改善广义输入文件的IO性能。由其数据结构定义的字段可知，主要是缓冲区相关字段，标记字段，和一个关联字段opaque 来完成广义文件读写操作。opaque 关联字段用于关联URLContext 结构，间接关联并扩展URLProtocol 结构。</p><h2 id=49--avstream结构体><strong>4.9 AVStream结构体</strong></h2><p>typedef struct AVStream</p><p>{</p><p>//指向解码器context，用于关联解码器</p><p>AVCodecContext *actx;</p><p>//codec解析器，每一种编码器在进行压缩时都会对实际负载数据进行封装，加//入头信息，如h264，需要解析nal单元，关联通过avav_find_stream_info()</p><p><code></code>struct AVCodecParserContext *parser;</p><p>//指向解复用的流的context，比如mp4的MovStreamcontext</p><p>void *priv_data;</p><p>AVRational time_base;</p><p>//用于seek时使用，用于快速索引关键帧，如flv的keyframes索引表和mp4的I</p><p>//帧的索引表都存于此，很重要</p><p>AVIndexEntry *index_entries;</p><p>//index_entries的元素的个数</p><p>int nb_index_entries;</p><p>int index_entries_allocated_size;</p><p>double frame_last_delay;</p><p>} AVStream;</p><p>说明：</p><p>AVStream 结构表示当前媒体流的上下文，着重于所有媒体流共有的属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。actx 字段关联当前音视频媒体使用的编解码器的context；priv_data 字段关联解析各个具体媒体流解复用拆包用的context；还有关键帧的索引表也存于此。</p><h2 id=410--movstreamcontext-结构体><strong>4.10 MOVStreamContext 结构体</strong></h2><p>typedef struct MOVStreamContext {</p><p><code></code>//流的索引,0或者1</p><p>int ffindex;</p><p>//临时变量，保存下一个chunk块的编号</p><p>int next_chunk;</p><p>//chunk的个数(在mp4的文件格式中,从stco中取值肯定为chunk的总数)</p><p>unsigned int chunk_count;</p><p>//chunk在文件中的偏移量数组(每个chunk中的sample在文件中的物理存储 //是连续 的),用于保存scto表</p><p>int64_t *chunk_offsets;</p><p>//stts的元素的个数</p><p>unsigned int stts_count;</p><p>//stts时间数据表</p><p>MOVStts *stts_data;</p><p>//ctts(用于在有B帧混合时进行纠正时间戳)的元素的个数</p><p>unsigned int ctts_count;</p><p><code></code>//ctts数据表</p><p>MOVStts *ctts_data;</p><p>//stsc(空间分布表)的元素的个数</p><p>unsigned int stsc_count;</p><p>//stsc数据表</p><p>MOVStsc *stsc_data;</p><p><code></code>//临时变量，记录当前使用的ctts表的索引</p><p>int ctts_index;</p><p>//记录当前的ctts元素作用的sample的索引</p><p><code></code>int ctts_sample;</p><p><code></code>//stsz表中可能smaple的size相同，如果相同使用该值</p><p>unsigned int sample_size;</p><p>//stsz中元素的个数</p><p>unsigned int sample_count;//sample的个数</p><p>//stsz数据表，记录每个sample的size，如果sample_size=0，该表才不会 //空</p><p>int *sample_sizes;</p><p>//stss(关键帧索引表)中元素的个数</p><p>unsigned int keyframe_count;</p><p>//关键帧数据表</p><p>int *keyframes;</p><p>//dref的元素的个数，一般为1</p><p>unsigned drefs_count;</p><p>//dref数据表</p><p>MOVDref *drefs;</p><p><code></code>//tkhd宽度</p><p>int width;</p><p>//tkhd高度</p><p>int height;</p><p>} MOVStreamContext;</p><p>说明：</p><p>MOVStreamContext结构用于保存从mov或mp4中进行拆包解复用从头部得到的信息。</p><h2 id=411--avpacket-结构体><strong>4.11 AVPacket 结构体</strong></h2><p>typedef struct AVPacket</p><p>{</p><p>//显示时间戳</p><p>int64_t pts;</p><p>//解码时间戳</p><p>int64_t dts;</p><p>//记录在文件或网络中的流中的字节的位置</p><p>int64_t pos;</p><p>//实际数据指针</p><p>uint8_t *data;</p><p>//实际的数据的大小</p><p>int size;</p><p>//该packet所属的流的索引，一般为0或者1</p><p>int stream_index;</p><p>int flags;</p><p>//析构函数</p><p>void(*destruct)(struct AVPacket*);</p><p>} AVPacket;</p><p>说明：</p><p>AVPacket 代表音视频数据帧，固有的属性是一些标记，时钟信息，和压缩数据首地址，大小等信息。</p><h2 id=412--avpacketlist-结构体><strong>4.12 AVPacketList 结构体</strong></h2><p>typedef struct AVPacketList</p><p>{</p><p>AVPacket pkt;</p><p>struct AVPacketList *next;</p><p>} AVPacketList;</p><p>说明：AVPacketList 把音视频AVPacket 组成一个小链表。</p><h2 id=413-avframe结构体><strong>4.13 AVFrame结构体</strong></h2><p>typedef struct AVFrame {</p><p>#define AV_NUM_DATA_POINTERS 8</p><p><code></code>uint8_t *data[AV_NUM_DATA_POINTERS];</p><p><code></code>int linesize[AV_NUM_DATA_POINTERS];</p><p>uint8_t **extended_data;</p><p><code></code>/**宽高 */</p><p><code></code>int width, height;</p><p><code></code>int nb_samples;</p><p>int format;</p><p><code></code>/**是否是关键帧*/</p><p><code></code>int key_frame;</p><p><code></code>/**帧类型（I,B,P）*/</p><p><code></code>enum AVPictureType pict_type;</p><p><code></code>uint8_t *base[AV_NUM_DATA_POINTERS];</p><p><code></code>AVRational sample_aspect_ratio;</p><p><code></code>int64_t pts;</p><p><code></code>int64_t pkt_pts;</p><p><code></code>int64_t pkt_dts;</p><p><code></code>int coded_picture_number;</p><p><code></code>int display_picture_number;</p><p><code></code>int quality;</p><p><code></code>int reference;</p><p><code></code>/**QP表*/</p><p><code></code>int8_t *qscale_table;</p><p><code></code>int qstride;</p><p><code></code>int qscale_type;</p><p><code></code>/**跳过宏块表 */</p><p><code></code>uint8_t *mbskip_table;</p><p><code></code>/**运动矢量表*/</p><p><code></code>int16_t (*motion_val[2])[2];</p><p><code></code>/**宏块类型表 */</p><p><code></code>uint32_t *mb_type;</p><p><code></code>/**DCT系数 */</p><p><code></code>short *dct_coeff;</p><p><code></code>/**参考帧列表 */</p><p><code></code>int8_t *ref_index[2];</p><p><code></code>void *opaque;</p><p><code></code>uint64_t error[AV_NUM_DATA_POINTERS];</p><p><code></code>int type;</p><p><code></code>int repeat_pict;</p><p><code></code>int interlaced_frame;</p><p><code></code>int top_field_first;</p><p><code></code>int palette_has_changed;</p><p><code></code>int buffer_hints;</p><p><code></code>AVPanScan *pan_scan;</p><p><code></code>int64_t reordered_opaque;</p><p><code></code>void *hwaccel_picture_private;</p><p><code></code>struct AVCodecContext *owner;</p><p><code></code>void *thread_opaque;</p><p><code></code>/**</p><p><code></code>* log2 of the size of the block which a single vector in motion_val represents:</p><p><code></code>* (4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2)</p><p><code></code>* - encoding: unused</p><p><code></code>* - decoding: Set by libavcodec.</p><p><code></code>*/</p><p><code></code>uint8_t motion_subsample_log2;</p><p><code></code>/**（音频）采样率 */</p><p><code></code>int sample_rate;</p><p><code></code>uint64_t channel_layout;</p><p><code></code>int64_t best_effort_timestamp;</p><p><code></code>int64_t pkt_pos;</p><p><code></code>int64_t pkt_duration;</p><p><code></code>AVDictionary *metadata;</p><p><code></code>int decode_error_flags;</p><p>#define FF_DECODE_ERROR_INVALID_BITSTREAM 1</p><p>#define FF_DECODE_ERROR_MISSING_REFERENCE 2</p><p><code></code>int64_t channels;</p><p>} AVFrame;</p><p>AVFrame结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。比如说，解码的时候存储了宏块类型表，QP表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在使用FFMPEG进行码流分析的时候，AVFrame是一个很重要的结构体。</p><p>下面看几个主要变量的作用（在这里考虑解码的情况）：</p><p>uint8_t *data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</p><p>int linesize[AV_NUM_DATA_POINTERS]：data的大小</p><p>int width, height：视频帧宽和高（1920x1080,1280x720...）</p><p>int nb_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个</p><p>int format：解码后原始数据类型（YUV420，YUV422，RGB24...）</p><p>int key_frame：是否是关键帧</p><p>enum AVPictureType pict_type：帧类型（I,B,P...）</p><p>AVRational sample_aspect_ratio：宽高比（16:9，4:3...）</p><p>int64_t pts：显示时间戳</p><p>int coded_picture_number：编码帧序号</p><p>int display_picture_number：显示帧序号</p><p>int8_t *qscale_table：QP表</p><p>uint8_t *mbskip_table：跳过宏块表</p><p>int16_t (*motion_val[2])[2]：运动矢量表</p><p>uint32_t *mb_type：宏块类型表</p><p>short *dct_coeff：DCT系数，这个没有提取过</p><p>int8_t *ref_index[2]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）</p><p>int interlaced_frame：是否是隔行扫描</p><p>uint8_t motion_subsample_log2：一个宏块中的运动矢量采样个数，取log的</p><p>其他的变量不再一一列举，源代码中都有详细的说明。在这里重点分析一下几个需要一定的理解的变量：</p><p>1.data[]</p><p>对于packed格式的数据（例如RGB24），会存到data[0]里面。</p><p>对于planar格式的数据（例如YUV420P），则会分开成data[0]，data[1]，data[2]...（YUV420P中data[0]存Y，data[1]存U，data[2]存V）</p><p>具体参见：FFMPEG 实现 YUV，RGB各种图像原始数据之间的转换（swscale）</p><p>2.pict_type</p><p>包含以下类型：</p><p>py</p><p>enum AVPictureType {</p><p><code></code>AV_PICTURE_TYPE_NONE = 0, ///&lt; Undefined</p><p><code></code>AV_PICTURE_TYPE_I, ///&lt; Intra</p><p><code></code>AV_PICTURE_TYPE_P, ///&lt; Predicted</p><p><code></code>AV_PICTURE_TYPE_B, ///&lt; Bi-dir predicted</p><p><code></code>AV_PICTURE_TYPE_S, ///&lt; S(GMC)-VOP MPEG4</p><p><code></code>AV_PICTURE_TYPE_SI, ///&lt; Switching Intra</p><p><code></code>AV_PICTURE_TYPE_SP, ///&lt; Switching Predicted</p><p><code></code>AV_PICTURE_TYPE_BI, ///&lt; BI type</p><p>};</p><p>3.sample_aspect_ratio</p><p>宽高比是一个分数，FFMPEG中用AVRational表达分数：</p><p>/**</p><p><code></code>* rational number numerator/denominator</p><p><code></code>*/</p><p>typedef struct AVRational{</p><p><code></code>int num; ///&lt; numerator</p><p><code></code>int den; ///&lt; denominator</p><p>} AVRational;</p><p>4.qscale_table</p><p>QP表指向一块内存，里面存储的是每个宏块的QP值。宏块的标号是从左往右，一行一行的来的。每个宏块对应1个QP。</p><p>qscale_table[0]就是第1行第1列宏块的QP值；qscale_table[1]就是第1行第2列宏块的QP值；qscale_table[2]就是第1行第3列宏块的QP值。以此类推...</p><p>宏块的个数用下式计算：</p><p>注：宏块大小是16x16的。</p><p>每行宏块数：</p><p>int mb_stride = pCodecCtx->width/16+1</p><p>宏块的总数：</p><p>int mb_sum = ((pCodecCtx->height+15)>>4)*(pCodecCtx->width/16+1)</p><p>5.motion_subsample_log2</p><p>1个运动矢量所能代表的画面大小（用宽或者高表示，单位是像素），注意，这里取了log2。</p><p>代码注释中给出以下数据：</p><p>4->16x16, 3->8x8, 2-> 4x4, 1-> 2x2</p><p>即1个运动矢量代表16x16的画面的时候，该值取4；1个运动矢量代表8x8的画面的时候，该值取3...以此类推</p><p>6.motion_val</p><p>运动矢量表存储了一帧视频中的所有运动矢量。</p><p>该值的存储方式比较特别：</p><p>int16_t (*motion_val[2])[2];</p><p>为了弄清楚该值究竟是怎么存的，花了我好一阵子功夫...</p><p>注释中给了一段代码：</p><p>int mv_sample_log2= 4 - motion_subsample_log2;</p><p>int mb_width= (width+15)>>4;</p><p>int mv_stride= (mb_width &lt;&lt; mv_sample_log2) + 1;</p><p>motion_val[direction][x + y*mv_stride][0->mv_x, 1->mv_y];</p><p>大概知道了该数据的结构：</p><p>1.首先分为两个列表L0和L1</p><p>2.每个列表（L0或L1）存储了一系列的MV（每个MV对应一个画面，大小由motion_subsample_log2决定）</p><p>3.每个MV分为横坐标和纵坐标（x,y）</p><p>注意，在FFMPEG中MV和MB在存储的结构上是没有什么关联的，第1个MV是屏幕上左上角画面的MV（画面的大小取决于motion_subsample_log2），第2个MV是屏幕上第1行第2列的画面的MV，以此类推。因此在一个宏块（16x16）的运动矢量很有可能如下图所示（line代表一行运动矢量的个数）：</p><p>//例如8x8划分的运动矢量与宏块的关系：</p><p><code></code>//-------------------------</p><p><code></code>//| | |</p><p><code></code>//|mv[x] |mv[x+1] |</p><p><code></code>//-------------------------</p><p><code></code>//| | |</p><p><code></code>//|mv[x+line]|mv[x+line+1]|</p><p><code></code>//-------------------------</p><p>7.mb_type</p><p>宏块类型表存储了一帧视频中的所有宏块的类型。其存储方式和QP表差不多。只不过其是uint32类型的，而QP表是uint8类型的。每个宏块对应一个宏块类型变量。</p><p>宏块类型如下定义所示：</p><p>//The following defines may change, don't expect compatibility if you use them.</p><p>#define MB_TYPE_INTRA4x4 0x0001</p><p>#define MB_TYPE_INTRA16x16 0x0002 //FIXME H.264-specific</p><p>#define MB_TYPE_INTRA_PCM 0x0004 //FIXME H.264-specific</p><p>#define MB_TYPE_16x16 0x0008</p><p>#define MB_TYPE_16x8 0x0010</p><p>#define MB_TYPE_8x16 0x0020</p><p>#define MB_TYPE_8x8 0x0040</p><p>#define MB_TYPE_INTERLACED 0x0080</p><p>#define MB_TYPE_DIRECT2 0x0100 //FIXME</p><p>#define MB_TYPE_ACPRED 0x0200</p><p>#define MB_TYPE_GMC 0x0400</p><p>#define MB_TYPE_SKIP 0x0800</p><p>#define MB_TYPE_P0L0 0x1000</p><p>#define MB_TYPE_P1L0 0x2000</p><p>#define MB_TYPE_P0L1 0x4000</p><p>#define MB_TYPE_P1L1 0x8000</p><p>#define MB_TYPE_L0 (MB_TYPE_P0L0 | MB_TYPE_P1L0)</p><p>#define MB_TYPE_L1 (MB_TYPE_P0L1 | MB_TYPE_P1L1)</p><p>#define MB_TYPE_L0L1 (MB_TYPE_L0 | MB_TYPE_L1)</p><p>#define MB_TYPE_QUANT 0x00010000</p><p>#define MB_TYPE_CBP 0x00020000</p><p>//Note bits 24-31 are reserved for codec specific use (h264 ref0, mpeg1 0mv, ...)</p><p>一个宏块如果包含上述定义中的一种或两种类型，则其对应的宏块变量的对应位会被置1。</p><p>注：一个宏块可以包含好几种类型，但是有些类型是不能重复包含的，比如说一个宏块不可能既是16x16又是8x8。</p><p>8.ref_index</p><p>运动估计参考帧列表存储了一帧视频中所有宏块的参考帧索引。这个列表其实在比较早的压缩编码标准中是没有什么用的。只有像H.264这样的编码标准才有多参考帧的概念。但是这个字段目前我还没有研究透。只是知道每个宏块包含有4个该值，该值反映的是参考帧的索引。以后有机会再进行细研究吧。</p><p>在这里展示一下自己做的码流分析软件的运行结果。将上文介绍的几个列表图像化显示了出来（在这里是使用MFC的绘图函数画出来的）</p><p>视频帧：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.022.jpeg alt></p><p>QP参数提取的结果：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.023.jpeg alt></p><p>美化过的（加上了颜色）：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.024.jpeg alt></p><p>宏块类型参数提取的结果：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.025.jpeg alt></p><p>美化过的（加上了颜色，更清晰一些，s代表skip宏块）：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.026.jpeg alt></p><p>运动矢量参数提取的结果（在这里是List0）：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.027.jpeg alt></p><p>运动估计参考帧参数提取的结果：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.028.jpeg alt></p><h1 id=第五章-重要模块><strong>第五章 重要模块</strong></h1><p>介绍几个常用模块及其函数实现，有贴代码的嫌疑。（下面分析的代码是较老版本的，新版本部分已经不适用了，但是具有一定参考价值，初期熟悉api的时候可以不理会具体的代码实现）</p><p>ps ：下列文件列表中的大小均为裁剪后的大小，非源码中实际代码带大小。</p><h2 id=51-libavutil公共模块><strong>5.1 libavutil公共模块</strong></h2><h3 id=1-文件列表><strong>1 文件列表</strong></h3><table><thead><tr><th>文件类型</th><th>文件名</th><th>大小(bytes)</th></tr></thead><tbody><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>common.h</td><td>1515</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>bswap.h</td><td>489</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>rational.h</td><td>257</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>mathematics.h</td><td>153</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>avutil.h</td><td>1978</td></tr></tbody></table><h3 id=2-commonh-文件><strong>2 common.h 文件</strong></h3><p>2.1 功能描述</p><p>ffplay 使用的工具类数据类型定义，宏定义和两个简单的内联函数,基本上是自注释的。</p><p>2.2 文件注释</p><p>1</p><p>2 #ifndef COMMON_H</p><p>3 #define COMMON_H</p><p>4</p><p>5 #include &lt;stdlib.h></p><p>6 #include &lt;stdio.h></p><p>7 #include &lt;string.h></p><p>8 #include &lt;ctype.h></p><p>9</p><p>10 #if defined(WIN32) && !defined( MINGW32 ) && !defined( CYGWIN )</p><p>11 #define CONFIG_WIN32</p><p>12 #endif</p><p>13<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.030.png alt></p><p>内联函数的关键字在 linux gcc 和 w indow s vc 中的定义是不同的，gcc 是 in line，vc 是 in line。因为代</p><p>码是从 linu x 下移植过来的，在这里做一个宏定义修改相对简单。</p><p>14 #ifdef CONFIG_WIN32</p><p>15 #define inline inline</p><p>16 #endif</p><p>17</p><p>简单的数据类型定义， linux gcc 和 w indow s vc 编译器有稍许不同，用宏开关 CONFIG_WIN32 来屏蔽 64</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.031.png alt>位整数类型的差别。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>18 typedef signed char int8_t;</p><p>19 typedef signed short int16_t;</p><p>20 typedef signed int int32_t;</p><p>21 typedef unsigned char uint8_t;</p><p>22 typedef unsigned short uint16_t;</p><p>23 typedef unsigned int uint32_t;</p><p>24</p><p>25 #ifdef CONFIG_WIN32</p><p>26 typedef signed int64 int64_t;</p><p>27 typedef unsigned int64 uint64_t;</p><p>28 #else</p><p>29 typedef signed long long int64_t;</p><p>30 typedef unsigned long long uint64_t;</p><p>31 #endif</p><p>32</p><p>64 位整数的定义语法，linux gcc 和 w indow s vc 编译器有稍许不同，用宏开关 CONFIG_WIN32 来屏蔽 64</p><p>位整数定义的差别。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.032.png alt>Linu x 用 LL/ ULL 来表示 64 位整数，VC 用 i64 来表示 64 位整数。</p><p>## 是连接符，把##前后的两个字符串连接成一个字符串。</p><p>33 #ifdef CONFIG_WIN32</p><p>34 #define int64_t_C(c) (c ## i64)</p><p>35 #define uint64_t_C(c) (c ## i64)</p><p>36 #else</p><p>37 #define int64_t_C(c) (c ## LL)</p><p>38 #define uint64_t_C(c) (c ## ULL)</p><p>39 #endif</p><p>40<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.033.png alt></p><p>定义最大的 64 位整数。</p><p>41 #ifndef INT64_MAX</p><p>42 #define INT64_MAX int64_t_C(9223372036854775807)</p><p>43 #endif</p><p>44<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.033.png alt></p><p>大小写敏感的字符串比较函数。在 ffplay 中只关心是否相等，不关心谁大谁小。</p><p>45 static int strcasecmp(char *s1, const char *s2)</p><p>46 {</p><p>47 while (toupper((unsigned char) *s1) == toupper((unsigned char) *s2++))</p><p>48 if (*s1++ == '\0')</p><p>49 return 0;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>50</p><p>51 return (toupper((unsigned char) *s1) - toupper((unsigned char) *--s2));</p><p>52 }</p><p>53</p><p>限幅函数，这个函数使用简单的比较逻辑来实现，比较语句多，容易中断 CPU 的指令流水线，导致性</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.034.png alt>能低下。如果变量 a 的取值范围比较小，可以用常规的空间换时间的查表方法来优化。</p><p>54 static inline int clip(int a, int amin, int amax)</p><p>55 {</p><p>56 if (a &lt; amin)</p><p>57 return amin;</p><p>58 else if (a > amax)</p><p>59 return amax;</p><p>60 else</p><p>61 return a;</p><p>62 }</p><p>63</p><p>64 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=3-bswaph-文件><strong>3 bswap.h 文件</strong></h3><p>3.1 功能描述</p><p>short 和 int 整数类型字节顺序交换，通常和 CPU 大端或小端有关。</p><p>对 int 型整数，小端 CPU 低地址内存存低位字节，高地址内存存高位字节。 对 int 型整数，大端 CPU 低地址内存存高位字节，高地址内存存低位字节。</p><p>常见的 CPU 中，Intel X86 序列及其兼容序列只能是小端，Motorola 68 序列只能是大端，ARM 大端小端都 支持，但默认小端。</p><p>3.2 文件注释</p><p>1 #ifndef BSWAP_H</p><p>2 #define BSWAP_H</p><p>3<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.035.png alt></p><p>Int 16 位短整数字节交换，简单的移位再或运算。</p><p>4 static inline uint16_t bswap_16(uint16_t x)</p><p>5 {</p><p>6 return (x >> 8) | (x &lt;&lt; 8);</p><p>7 }</p><p>8</p><p>Int 32 位长整数字节交换，看遍所有的开源代码，这个代码是最简洁的 C 代码，并且和上面 16 位短</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.036.png alt>整数字节交换一脉相承。</p><p>9 static inline uint32_t bswap_32(uint32_t x)</p><p>10 {</p><p>11 x = ((x &lt;&lt; 8) &0xFF00FF00) | ((x >> 8) &0x00FF00FF);</p><p>12 return (x >> 16) | (x &lt;&lt; 16);</p><p>13 }</p><p>14</p><p>15 // be2me ... BigEndian to MachineEndian</p><p>16 // le2me ... LittleEndian to MachineEndian</p><p>17</p><p>18 #define be2me_16(x) bswap_16(x)</p><p>19 #define be2me_32(x) bswap_32(x)</p><p>20 #define le2me_16(x) (x)</p><p>21 #define le2me_32(x) (x)</p><p>22</p><p>23 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=4-rationalh-文件><strong>4 rational.h 文件</strong></h3><p>4.1 功能描述</p><p>用两整数精确表示分数。常规的可以用一个 float 或 double 型数来表示分数，但不是精确表示，在需要相 对比较精确计算的时候，为避免非精确表示带来的计算误差，采用两整数来精确表示。</p><p>4.2 文件注释</p><p>1 #ifndef RATIONAL_H</p><p>2 #define RATIONAL_H</p><p>3<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.037.png alt></p><p>用分数最原始的分子和分母的定义来表示，用分子和分母的组合来表示分数。</p><p>4 typedef struct AVRational</p><p>5 {</p><p>6 int num; // numerator // 分子</p><p>7 int den; // denominator // 分母</p><p>8 } AVRational;</p><p>9<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.037.png alt></p><p>用 float 或 double 表示分数值，强制类型转换后，简单的除法运算。</p><p>10 static inline double av_q2d(AVRational a)</p><p>11 {</p><p>12 return a.num / (double)a.den;</p><p>13 }</p><p>1415 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=5-mathematicsh-文件><strong>5 mathematics.h 文件</strong></h3><p>5.1 功能描述</p><p>数学上的缩放运算。为避免计算误差，缩放因子用两整数表示做精确的整数运算。为防止计算溢出，强制转 换为 int 64 位整数后计算。</p><p>此处做了一些简化，运算精度会降低，但普通的人很难感知到计算误差。</p><p>5.2 文件注释</p><p>1 #ifndef MATHEMATICS_H</p><p>2 #define MATHEMATICS_H</p><p>3<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.038.png alt></p><p>数学上的缩放运算，此处简化了很多，虽然计算结果有稍许误差，但不影响播放效果。</p><p>4 static inline int64_t av_rescale(int64_t a, int64_t b, int64_t c)</p><p>5 {</p><p>6 return a * b / c;</p><p>7 }</p><p>9 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=6-avutilh-文件><strong>6 avutil.h 文件</strong></h3><p>6.1 功能描述</p><p>ffplay 基础工具库使用的一些常数和宏的定义。</p><p>6.2 文件注释</p><p>1 #ifndef AVUTIL_H</p><p>2 #define AVUTIL_H</p><p>3</p><p>4 #ifdef cplusplus</p><p>5 extern "C" {</p><p>6 #endif</p><p>7<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.039.png alt></p><p>代码 8 到 15 行是一些版本信息标示的宏定义，便于各位网友和原始版本比对，更深入地学习 ffmpeg。</p><p>8 #define AV_STRINGIFY(s) AV_TOSTRING(s)</p><p>9 #define AV_TOSTRING(s) #s</p><p>10</p><p>11 #define LIBAVUTIL_VERSION_INT ((49&lt;&lt;16)+(0&lt;&lt;8)+0)</p><p>12 #define LIBAVUTIL_VERSION 49.0.0</p><p>13 #define LIBAVUTIL_BUILD LIBAVUTIL_VERSION_INT</p><p>14</p><p>15 #define LIBAVUTIL_IDENT "Lavu" AV_STRINGIFY(LIBAVUTIL_VERSION)</p><p>16</p><p>17 #include "common.h"</p><p>18 #include "mathematics.h"</p><p>19 #include "rational.h"</p><p>20<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.039.png alt></p><p>像素格式的宏定义，便于代码编写和维护。把一些常数定义成有意义的宏是一个值得鼓励的好习惯。</p><p>21 enum PixelFormat</p><p>22 {</p><p>23 PIX_FMT_NONE= -1,</p><p>24 PIX_FMT_YUV420P, // Planar YUV 4:2:0 (1 Cr & Cb sample per 2x2 Y samples)</p><p>25 PIX_FMT_YUV422, // Packed pixel, Y0 Cb Y1 Cr</p><p>26 PIX_FMT_RGB24, // Packed pixel, 3 bytes per pixel, RGBRGB...</p><p>27 PIX_FMT_BGR24, // Packed pixel, 3 bytes per pixel, BGRBGR...</p><p>28 PIX_FMT_YUV422P, // Planar YUV 4:2:2 (1 Cr & Cb sample per 2x1 Y samples)</p><p>29 PIX_FMT_YUV444P, // Planar YUV 4:4:4 (1 Cr & Cb sample per 1x1 Y samples)</p><p>30 PIX_FMT_RGBA32, // Packed pixel, 4 bytes per pixel, BGRABGRA..., stored in cpu endianness<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>31 PIX_FMT_YUV410P, // Planar YUV 4:1:0 (1 Cr & Cb sample per 4x4 Y samples)</p><p>32 PIX_FMT_YUV411P, // Planar YUV 4:1:1 (1 Cr & Cb sample per 4x1 Y samples)</p><p>33 PIX_FMT_RGB565, // always stored in cpu endianness</p><p>34 PIX_FMT_RGB555, // always stored in cpu endianness, most significant bit to 1</p><p>35 PIX_FMT_GRAY8,</p><p>36 PIX_FMT_MONOWHITE, // 0 is white</p><p>37 PIX_FMT_MONOBLACK, // 0 is black</p><p>38 PIX_FMT_PAL8, // 8 bit with RGBA palette</p><p>39 PIX_FMT_YUVJ420P, // Planar YUV 4:2:0 full scale (jpeg)</p><p>40 PIX_FMT_YUVJ422P, // Planar YUV 4:2:2 full scale (jpeg)</p><p>41 PIX_FMT_YUVJ444P, // Planar YUV 4:4:4 full scale (jpeg)</p><p>42 PIX_FMT_XVMC_MPEG2_MC,// XVideo Motion Acceleration via common packet passing(xvmc_render.h)</p><p>43 PIX_FMT_XVMC_MPEG2_IDCT,</p><table><thead><tr><th>44</th><th>PIX_FMT_UYVY422,</th><th>// Packed pixel, Cb Y0 Cr Y1</th></tr></thead><tbody><tr><td>45</td><td>PIX_FMT_UYVY411,</td><td>// Packed pixel, Cb Y0 Y1 Cr Y2 Y3</td></tr><tr><td>46</td><td>PIX_FMT_NB,</td><td></td></tr><tr><td>47</td><td>};</td><td></td></tr><tr><td>48</td><td></td><td></td></tr><tr><td>49</td><td>#ifdef cplusplus</td><td></td></tr><tr><td>50</td><td>}</td><td></td></tr><tr><td>51</td><td>#endif</td><td></td></tr><tr><td>52</td><td></td><td></td></tr><tr><td>53</td><td>#endif</td><td></td></tr></tbody></table><h2 id=52-libavcodec编解码模块><strong>5.2 libavcodec编解码模块</strong></h2><h3 id=1-文件列表-1><strong>1 文件列表</strong></h3><table><thead><tr><th>文件类型</th><th>文件名</th><th>大小(bytes)</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></th><th>文件名</th><th>大小(bytes)</th></tr></thead><tbody><tr><td></td><td>avcodec.h</td><td>4943</td></tr><tr><td></td><td>allcodecs.c</td><td>310</td></tr><tr><td></td><td>dsputil.h</td><td>163</td></tr><tr><td></td><td>dsputil.c</td><td>350</td></tr><tr><td></td><td>imgconvert_template.h</td><td>22311</td></tr><tr><td></td><td>imgconvert.c</td><td>47834</td></tr><tr><td></td><td>msrle.c</td><td>8387</td></tr><tr><td></td><td>turespeech_data.h</td><td>4584</td></tr><tr><td></td><td>turespeech.c</td><td>9622</td></tr><tr><td></td><td>utils_codec.c</td><td>8973</td></tr></tbody></table><table><thead><tr><th><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></th><th>avcodec.h</th><th>4943</th></tr></thead><tbody><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>allcodecs.c</td><td>310</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>dsputil.h</td><td>163</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>dsputil.c</td><td>350</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>imgconvert_template.h</td><td>22311</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>imgconvert.c</td><td>47834</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>msrle.c</td><td>8387</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>turespeech_data.h</td><td>4584</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>turespeech.c</td><td>9622</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>utils_codec.c</td><td>8973</td></tr></tbody></table><h3 id=2-avcodech-文件><strong>2 avcodec.h 文件</strong></h3><p>2.1 功能描述</p><p>定义编解码器库使用的宏、数据结构和函数，通常这些宏、数据结构和函数在此模块内相对全局有效。</p><p>2.2 文件注释</p><p>1 #ifndef AVCODEC_H</p><p>2 #define AVCODEC_H</p><p>3</p><p>4 #ifdef cplusplus</p><p>5 extern "C"</p><p>6 {</p><p>7 #endif</p><p>8</p><p>9 #include "../libavutil/avutil.h"</p><p>10 #include &lt;sys/types.h> // size_t</p><p>11<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>和版本信息有关的几个宏定义</p><p>12 #define FFMPEG_VERSION_INT 0x000409</p><p>13 #define FFMPEG_VERSION "CVS"</p><p>14</p><p>15 #define AV_STRINGIFY(s) AV_TOSTRING(s)</p><p>16 #define AV_TOSTRING(s) #s</p><p>17<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>18 #define LIBAVCODEC_VERSION_INT ((51&lt;&lt;16)+(8&lt;&lt;8)+0)</p><p>19 #define LIBAVCODEC_VERSION 51.8.0</p><p>20 #define LIBAVCODEC_BUILD LIBAVCODEC_VERSION_INT</p><p>21</p><p>22 #define LIBAVCODEC_IDENT "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)</p><p>23</p><p>24 #define AV_NOPTS_VALUE int64_t_C(0x8000000000000000)</p><p>25 #define AV_TIME_BASE 1000000</p><p>26<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>Codec ID 宏定义，瘦身后的 ffplay 只支持这两种 codec，其他的都删掉了。</p><p>27 enum CodecID</p><p>28 {</p><p>29 CODEC_ID_TRUESPEECH,</p><p>30 CODEC_ID_MSRLE,</p><p>31 CODEC_ID_NONE</p><p>32 };</p><p>33<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>Codec 类型定义，瘦身后的 ffplay 只支持视频和音频。</p><p>34 enum CodecType</p><p>35 {</p><p>36 CODEC_TYPE_UNKNOWN = - 1,</p><p>37 CODEC_TYPE_VIDEO,</p><p>38 CODEC_TYPE_AUDIO,</p><p>39 CODEC_TYPE_DATA</p><p>40 };</p><p>41</p><p>42 #define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio</p><p>43</p><p>44 #define FF_INPUT_BUFFER_PADDING_SIZE 8</p><p>45</p><p>AVPicture 和 AVFrame 主要表示解码过程中的使用缓存，通常帧缓存是 YUV 格式，输出格式有 YUV</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.042.png alt>也有 RGB 格式，所以定义了 4 个 data 指针来表示分量。</p><p>46 typedef struct AVPicture</p><p>47 {</p><p>48 uint8_t *data[4];</p><p>49 int linesize[4];</p><p>50 } AVPicture;</p><p>51<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>52 typedef struct AVFrame</p><p>53 {</p><p>54 uint8_t *data[4]; // 有多重意义，其一用 NULL 来判断是否被占用</p><p>55 int linesize[4];</p><p>56 uint8_t *base[4]; // 有多重意义，其一用 NULL 来判断是否分配内存</p><p>57 } AVFrame;</p><p>58</p><p>程序运行时当前 Codec 使用的上下文，着重于所有 Codec 共有的属性(并且是在程序运行时才能确定其</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.042.png alt>值)，codec 和 priv_data 关联其他结构的字段，便于在数据结构间跳转。</p><p>59 typedef struct AVCodecContext</p><p>60 {</p><p>61 int bit_rate;</p><p>62 int frame_number; // audio or video frame number</p><p>63</p><p>64 unsigned char *extradata; // codec 的私有数据,对 Audio 是 WAVEFORMATEX 扩展结构。</p><p>65 int extradata_size; // 对 Video 是 BITMAPINFOHEADER 扩展结构</p><p>66</p><p>67 int width, height; // video only</p><p>68</p><p>69 enum PixelFormat pix_fmt; // 输出像素格式/视频图像格式</p><p>70</p><p>71 int sample_rate; // samples per sec // audio only</p><p>72 int channels;</p><p>73 int bits_per_sample;</p><p>74 int block_align;</p><p>75</p><p>76 struct AVCodec *codec; // 指向 Codec 的指针，</p><p>77 void *priv_data; // 具体解码器属性，在本例中指向 MsrleContext 或 TSContext</p><p>78</p><p>79 enum CodecType codec_type;// see CODEC_TYPE_xxx</p><p>80 enum CodecID codec_id; // see CODEC_ID_xxx</p><p>81</p><p>82 int(*get_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>83 void(*release_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>84 int(*reget_buffer)(struct AVCodecContext *c, AVFrame *pic);</p><p>85</p><p>86 int internal_buffer_count;</p><p>87 void *internal_buffer;</p><p>88</p><p>89 struct AVPaletteControl *palctrl;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>90 }AVCodecContext;</p><p>91</p><p>类似 COM 接口的数据结构，表示音视频编解码器，着重于功能函数，一种媒体类型对应一个 AVCodec</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.042.png alt>结构，在程序运行时有多个实例串联成链表便于查找。</p><p>92 typedef struct AVCodec</p><p>93 {</p><p>94 const char *name; // 便于阅读的友好字符串，表征编解码器名称，比如"msrle","truespeech"</p><p>95 enum CodecType type; // 编解码器类型，有效取值为 CODEC_TYPE_VIDEO 或 CODEC_TYPE_AUDIO</p><p>96 enum CodecID id; // 编解码器 ID 值，</p><p>97 int priv_data_size; // 具体编解码属性结构的大小，取代很多的 if-else 语句</p><p>98 int(*init)(AVCodecContext*);</p><p>99 int(*encode)(AVCodecContext *, uint8_t *buf, int buf_size, void *data);</p><p>100 int(*close)(AVCodecContext*);</p><p>101 int(*decode)(AVCodecContext *, void *outdata, int *outdata_size, uint8_t *buf, int buf_size);</p><p>102 int capabilities;</p><p>103</p><p>104 struct AVCodec *next; // 把所有的编解码器串联成链表便于查找</p><p>105 }AVCodec;</p><p>106<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.042.png alt></p><p>调色板大小和大小宏定义，每个调色板四字节(R,G,B,α)。有很多的视频图像颜色种类比较少，用索引 间接表示每个像素的颜色值，就可以用调色板和索引值实现简单的大约的 4:1 压缩比。</p><p>107 #define AVPALETTE_SIZE 1024</p><p>108 #define AVPALETTE_COUNT 256</p><p>109<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.043.png alt></p><p>调色板数据结构定义，保存调色板数据。</p><p>110 typedef struct AVPaletteControl</p><p>111 {</p><p>112 // demuxer sets this to 1 to indicate the palette has changed; decoder resets to 0</p><p>113 int palette_changed;</p><p>114</p><p>115 /* 4-byte ARGB palette entries, stored in native byte order; note that</p><p>116 * the individual palette components should be on a 8-bit scale; if</p><p>117 * the palette data comes from a IBM VGA native format, the component</p><p>118 * data is probably 6 bits in size and needs to be scaled */</p><p>119 unsigned int palette[AVPALETTE_COUNT];</p><p>120</p><p>121 } AVPaletteControl;</p><p>122<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.044.png alt></p><p>编解码库使用的函数声明。</p><p>123 int avpicture_alloc(AVPicture *picture, int pix_fmt, int width, int height);</p><p>124</p><p>125 void avpicture_free(AVPicture *picture);</p><p>126</p><p>127 int avpicture_fill(AVPicture *picture, uint8_t *ptr, int pix_fmt, int width, int height);</p><p>128 int avpicture_get_size(int pix_fmt, int width, int height);</p><p>129 void avcodec_get_chroma_sub_sample(int pix_fmt, int *h_shift, int *v_shift);</p><p>130</p><p>131 int img_convert(AVPicture *dst, int dst_pix_fmt, const AVPicture *src, int pix_fmt,</p><p>132 int width, int height);</p><p>133</p><p>134 void avcodec_init(void);</p><p>135</p><p>136 void register_avcodec(AVCodec *format);</p><p>137 AVCodec *avcodec_find_decoder(enum CodecID id);</p><p>138</p><p>139 AVCodecContext *avcodec_alloc_context(void);</p><p>140</p><p>141 int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);</p><p>142 void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);</p><p>143 int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);</p><p>144 void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);</p><p>145 int avcodec_check_dimensions(void *av_log_ctx, unsigned int w, unsigned int h);</p><p>146</p><p>147 int avcodec_open(AVCodecContext *avctx, AVCodec *codec);</p><p>148</p><p>149 int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr,</p><p>150 uint8_t *buf, int buf_size);</p><p>151 int avcodec_decode_video(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr,</p><p>152 uint8_t *buf, int buf_size);</p><p>153</p><p>154 int avcodec_close(AVCodecContext *avctx);</p><p>155</p><p>156 void avcodec_register_all(void);</p><p>157</p><p>158 void avcodec_default_free_buffers(AVCodecContext *s);</p><p>159</p><p>160 void *av_malloc(unsigned int size);</p><p>161 void *av_mallocz(unsigned int size);</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>162 void *av_realloc(void *ptr, unsigned int size);</p><p>163 void av_free(void *ptr);</p><p>164 void av_freep(void *ptr);</p><p>165 void *av_fast_realloc(void *ptr, unsigned int *size, unsigned int min_size);</p><p>166</p><p>167 void img_copy(AVPicture *dst, const AVPicture *src, int pix_fmt, int width, int height);</p><p>168</p><p>169 #ifdef cplusplus</p><p>170 }</p><p>171</p><p>172 #endif</p><p>173</p><p>174 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=3-allcodecc-文件><strong>3 allcodec.c 文件</strong></h3><p>3.1 功能描述</p><p>简单的注册/初始化函数，把编解码器用相应的链表串起来便于查找识别。</p><p>3.2 文件注释</p><p>1 #include "avcodec.h"</p><p>2</p><p>3 extern AVCodec truespeech_decoder;</p><p>4 extern AVCodec msrle_decoder;</p><p>5</p><p>6 void avcodec_register_all(void)</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.045.png alt>7 {</p><p>8 到 13 行，in ited 变量声明成 static，做一下比较是为了避免此函数多次调用。</p><p>编程基本原则之一，初始化函数只调用一次，不能随意多次调用。</p><p>8 static int inited = 0;</p><p>9</p><p>10 if (inited != 0)</p><p>11 return ;</p><p>12</p><p>13 inited = 1;</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt>14</p><p>把 msrle_decoder 解码器串接到解码器链表，链表头指针是 first_avcodec。</p><p>15 register_avcodec(&msrle_decoder);</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt>16</p><p>把 truespeech_decoder 解码器串接到解码器链表，链表头指针是 first_avcodec。</p><p>17 register_avcodec(&truespeech_decoder);</p><p>18 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=4-dsputilh-文件><strong>4 dsputil.h 文件</strong></h3><p>4.1 功能描述</p><p>定义 dsp 优化限幅运算使用的查找表及其初始化函数。</p><p>4.2 文件注释</p><p>1 #ifndef DSPUTIL_H</p><p>2 #define DSPUTIL_H</p><p>3</p><p>4 #define MAX_NEG_CROP 1024</p><p>5</p><p>6 extern uint8_t cropTbl[256+2 * MAX_NEG_CROP];</p><p>7</p><p>8 void dsputil_static_init(void);</p><p>9</p><p>10 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=5-dsputilc-文件><strong>5 dsputil.c 文件</strong></h3><p>5.1 功能描述</p><p>定义 dsp 优化限幅运算使用的查找表，实现其初始化函数。</p><p>5.2 文件注释</p><p>1 #include "avcodec.h"</p><p>2 #include "dsputil.h"</p><p>3</p><p>4 uint8_t cropTbl[256+2 * MAX_NEG_CROP] = {0, };</p><p>5</p><p>6 void dsputil_static_init(void)</p><p>7 {</p><p>8 int i;</p><p>9</p><p>初始化限幅运算查找表，最后的结果是：前 MAX_NEG_CROP 个数组项为 0，接着的 256 个数组项分别为</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.047.png alt>0 到 255，后面 MAX_NEG_CROP 个数组项为 255。用查表代替比较实现限幅运算。</p><p>10 for (i = 0; i &lt; 256; i++)</p><p>11 cropTbl[i + MAX_NEG_CROP] = i;</p><p>12</p><p>13 for (i = 0; i &lt; MAX_NEG_CROP; i++)</p><p>14 {</p><p>15 cropTbl[i] = 0;</p><p>16 cropTbl[i + MAX_NEG_CROP + 256] = 255;</p><p>17 }</p><p>18 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=6-utils_codecc-文件><strong>6 utils_codec.c 文件</strong></h3><p>6.1 功能描述</p><p>编解码库使用的帮助和工具函数，</p><p>6.2 文件注释</p><p>1 #include "avcodec.h"</p><p>2 #include "dsputil.h"</p><p>3</p><p>1 #include &lt;assert.h></p><p>2 #include "avcodec.h"</p><p>3 #include "dsputil.h"</p><p>4</p><p>5 #define EDGE_WIDTH 16</p><p>6 #define STRIDE_ALIGN 16</p><p>7</p><p>8 #define INT_MAX 2147483647</p><p>9</p><p>10 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))</p><p>11<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>内存动态分配函数，做一下简单参数校验后调用系统函数</p><p>12 void *av_malloc(unsigned int size)</p><p>13 {</p><p>14 void *ptr;</p><p>15</p><p>16 if (size > INT_MAX)</p><p>17 return NULL;</p><p>18 ptr = malloc(size);</p><p>19</p><p>20 return ptr;</p><p>21 }</p><p>22<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>内存动态重分配函数，做一下简单参数校验后调用系统函数</p><p>23 void *av_realloc(void *ptr, unsigned int size)</p><p>24 {</p><p>25 if (size > INT_MAX)</p><p>26 return NULL;</p><p>27</p><p>28 return realloc(ptr, size);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>29 }</p><p>30<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>内存动态释放函数，做一下简单参数校验后调用系统函数</p><p>31 void av_free(void *ptr)</p><p>32 {</p><p>33 if (ptr)</p><p>34 free(ptr);</p><p>35 }</p><p>36</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.049.png alt>内存动态分配函数，复用 av_malloc()函数，再把分配的内存清 0.</p><p>37 void *av_mallocz(unsigned int size)</p><p>38 {</p><p>39 void *ptr;</p><p>40</p><p>41 ptr = av_malloc(size);</p><p>42 if (!ptr)</p><p>43 return NULL;</p><p>44</p><p>45 memset(ptr, 0, size);</p><p>46 return ptr;</p><p>47 }</p><p>48<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>快速内存动态分配函数，预分配一些内存来避免多次调用系统函数达到快速的目的。</p><p>49 void *av_fast_realloc(void *ptr, unsigned int *size, unsigned int min_size)</p><p>50 {</p><p>51 if (min_size &lt; *size)</p><p>52 return ptr;</p><p>53</p><p>54 *size = FFMAX(17 *min_size / 16+32, min_size);</p><p>55</p><p>56 return av_realloc(ptr, *size);</p><p>57 }</p><p>58<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.050.png alt></p><p>动态内存释放函数，注意传入的变量的类型。</p><p>59 void av_freep(void *arg)</p><p>60 {</p><p>61 void **ptr = (void **)arg;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>62 av_free(*ptr);</p><p>63 *ptr = NULL;</p><p>64 }</p><p>65</p><p>66 AVCodec *first_avcodec = NULL;</p><p>67<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.050.png alt></p><p>把编解码器串联成一个链表，便于查找。</p><p>68 void register_avcodec(AVCodec *format)</p><p>69 {</p><p>70 AVCodec **p;</p><p>71 p = &first_avcodec;</p><p>72 while (*p != NULL)</p><p>73 p = &(*p)->next;</p><p>74 *p = format;</p><p>75 format->next = NULL;</p><p>76 }</p><p>77</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.051.png alt>编解码库内部使用的缓存区，因为视频图像有 RGB 或 YUV 分量格式，所以每个数组有四个分量。</p><p>78 typedef struct InternalBuffer</p><p>79 {</p><p>80 uint8_t *base[4];</p><p>81 uint8_t *data[4];</p><p>82 int linesize[4];</p><p>83 } InternalBuffer;</p><p>84</p><p>85 #define INTERNAL_BUFFER_SIZE 32</p><p>86</p><p>87 #define ALIGN(x, a) (((x)+(a)-1)&~((a)-1))</p><p>88<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>计算各种图像格式要求的图像长宽的字节对齐数，是 1 个还是 2 个，4 个，8 个，16 个字节对齐。</p><p>89 void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)</p><p>90 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>默认长宽是 1 个字节对齐。</p><p>91 int w_align = 1;</p><p>92 int h_align = 1;</p><p>93</p><p>94 switch (s->pix_fmt)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>95 {</p><p>96 case PIX_FMT_YUV420P:</p><p>97 case PIX_FMT_YUV422:</p><p>98 case PIX_FMT_UYVY422:</p><p>99 case PIX_FMT_YUV422P:</p><p>100 case PIX_FMT_YUV444P:</p><p>101 case PIX_FMT_GRAY8:</p><p>102 case PIX_FMT_YUVJ420P:</p><p>103 case PIX_FMT_YUVJ422P:</p><p>104 case PIX_FMT_YUVJ444P: //FIXME check for non mpeg style codecs and use less alignment</p><p>105 w_align = 16;</p><p>106 h_align = 16;</p><p>107 break;</p><p>108 case PIX_FMT_YUV411P:</p><p>109 case PIX_FMT_UYVY411:</p><p>110 w_align = 32;</p><p>111 h_align = 8;</p><p>112 break;</p><p>113 case PIX_FMT_YUV410P:</p><p>114 case PIX_FMT_RGB555:</p><p>115 case PIX_FMT_PAL8:</p><p>116 break;</p><p>117 case PIX_FMT_BGR24:</p><p>118 break;</p><p>119 default:</p><p>120 w_align = 1;</p><p>121 h_align = 1;</p><p>122 break;</p><p>123 }</p><p>124</p><p>125 *width = ALIGN(*width, w_align);</p><p>126 *height = ALIGN(*height, h_align);</p><p>127 }</p><p>128<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>校验视频图像的长宽是否合法。</p><p>129 int avcodec_check_dimensions(void *av_log_ctx, unsigned int w, unsigned int h)</p><p>130 {</p><p>131 if ((int)w > 0 && (int)h > 0 && (w + 128)*(uint64_t)(h + 128) &lt; INT_MAX / 4)</p><p>132 return 0;</p><p>133<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>134 return - 1;</p><p>135 }</p><p>136</p><p>每次取 internal_buffer_count 数据项，用 base[0]来判断是否已分配内存，用 data[0]来判断是否</p><p>已被占用。base[]和 data[]有多重意义。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.052.png alt>在 avcodec_alloc_context 中已把 internal_buffer 各项清 0，所以可以用 base[0]来判断。</p><p>137 int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic)</p><p>138 {</p><p>139 int i;</p><p>140 int w = s->width;</p><p>141 int h = s->height;</p><p>142 int align_off;</p><p>143 InternalBuffer *buf;</p><p>144</p><p>145 assert(pic->data[0] == NULL);</p><p>146 assert(INTERNAL_BUFFER_SIZE > s->internal_buffer_count);</p><p>147<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>校验视频图像的长宽是否合法。</p><p>148 if (avcodec_check_dimensions(s, w, h))</p><p>149 return - 1;</p><p>150<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>如果没有分配内存，就分配动态内存并清 0。</p><p>151 if (s->internal_buffer == NULL)</p><p>152 s->internal_buffer = av_mallocz(INTERNAL_BUFFER_SIZE *sizeof(InternalBuffer));</p><p>153<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.050.png alt></p><p>取缓存中的第一个没有占用内存。</p><p>154 buf = &((InternalBuffer*)s->internal_buffer)[s->internal_buffer_count];</p><p>155</p><p>156 if (buf->base[0])</p><p>157 { /* 如果内存已分配就跳过 */ }</p><p>158 else</p><p>159 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>如果没有分配内存就按照图像格式要求分配内存，并设置一些标记和计算一些参数值。</p><p>160 int h_chroma_shift, v_chroma_shift;</p><p>161 int pixel_size, size[3];</p><p>162<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>163 AVPicture picture;</p><p>164<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>计算 CbCr 色度分量长宽的与 Y 亮度分量长宽的比，最后用移位实现。</p><p>165 avcodec_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift, &v_chroma_shift);</p><p>166<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>规整长宽满足特定图像像素格式的要求。</p><p>167 avcodec_align_dimensions(s, &w, &h);</p><p>168</p><p>把长宽放大一些，比如在 mpeg4 视频中编码算法中的运动估计要把原始图像做扩展来满足不受限制运</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.053.png alt>动矢量的要求(运动矢量可以超出原始图像边界)。</p><p>169 w+= EDGE_WIDTH*2;</p><p>170 h+= EDGE_WIDTH*2;</p><p>171<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>计算特定格式的图像参数，包括各分量的大小，单行长度(linesi ze/stride) 等等。</p><p>172 avpicture_fill(&picture, NULL, s->pix_fmt, w, h);</p><p>173 pixel_size = picture.linesize[0] * 8 / w;</p><p>174 assert(pixel_size >= 1);</p><p>175</p><p>176 if (pixel_size == 3 *8)</p><p>177 w = ALIGN(w, STRIDE_ALIGN &lt;&lt; h_chroma_shift);</p><p>178 else</p><p>179 w = ALIGN(pixel_size *w, STRIDE_ALIGN &lt;&lt; (h_chroma_shift + 3)) / pixel_size;</p><p>180</p><p>181 size[1] = avpicture_fill(&picture, NULL, s->pix_fmt, w, h);</p><p>182 size[0] = picture.linesize[0] *h;</p><p>183 size[1] -= size[0];</p><p>184 if (picture.data[2])</p><p>185 size[1] = size[2] = size[1] / 2;</p><p>186 else</p><p>187 size[2] = 0;</p><p>188<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>注意 base[]和 data[]数组还有作为标记的用途，free()时的非 NULL 判断，这里要清 0。</p><p>189 memset(buf->base, 0, sizeof(buf->base));</p><p>190 memset(buf->data, 0, sizeof(buf->data));</p><p>191</p><p>192 for (i = 0; i &lt; 3 && size[i]; i++)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>193 {</p><p>194 const int h_shift = i == 0 ? 0 : h_chroma_shift;</p><p>195 const int v_shift = i == 0 ? 0 : v_chroma_shift;</p><p>196</p><p>197 buf->linesize[i] = picture.linesize[i];</p><p>198<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>实质性分配内存，并且在 202 行把内存清 0。</p><p>199 buf->base[i] = av_malloc(size[i] + 16); //FIXME 16</p><p>200 if (buf->base[i] == NULL)</p><p>201 return - 1;</p><p>202 memset(buf->base[i], 128, size[i]);</p><p>203<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>内存对齐计算。</p><p>204 align_off=ALIGN((buf->linesize[i]*EDGE_WIDTH>>v_shift)+(EDGE_WIDTH>>h_shift),STRIDE_ALIGN);</p><p>205</p><p>206 if ((s->pix_fmt == PIX_FMT_PAL8) || !size[2])</p><p>207 buf->data[i] = buf->base[i];</p><p>208 else</p><p>209 buf->data[i] = buf->base[i] + align_off;</p><p>210 }</p><p>211 }</p><p>212</p><p>213 for (i = 0; i &lt; 4; i++)</p><p>214 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.050.png alt></p><p>把分配的内存参数赋值到 pic 指向的结构中，传递出去。</p><table><thead><tr><th>215</th><th></th><th>pic->base[i] = buf->base[i];</th></tr></thead><tbody><tr><td>216</td><td></td><td>pic->data[i] = buf->data[i];</td></tr><tr><td>217</td><td></td><td>pic->linesize[i] = buf->linesize[i];</td></tr><tr><td>218</td><td>}</td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt>内存数组计数+1，注意释放时的操作，保证计数对应的内存数组是空闲的。</td><td></td><td></td></tr></tbody></table><p>219 s->internal_buffer_count++;</p><p>220</p><p>221 return 0;</p><p>222 }</p><p>223<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>释放占用的内存数组项。保证从 0 到 internal_buffer_count-1 数据项为有效数据，其他是空闲数据项<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>224 void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)</p><p>225 {</p><p>226 int i;</p><p>227 InternalBuffer *buf, *last, temp;</p><p>228<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>简单的参数校验，内存必须是已经分配过。</p><p>229 assert(s->internal_buffer_count);</p><p>230</p><p>231 buf = NULL;</p><p>232 for (i = 0; i &lt; s->internal_buffer_count; i++)</p><p>233 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>遍历内存数组，查找对应 pic 的内存数组项，以 data[0]内存地址为比较判别标记。</p><p>234 buf = &((InternalBuffer*)s->internal_buffer)[i]; //just 3-5 checks so is not worth to optimize</p><p>235 if (buf->data[0] == pic->data[0])</p><p>236 break;</p><p>237 }</p><p>238 assert(i &lt; s->internal_buffer_count);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.050.png alt></p><p>内存数组计数-1, 删除最后一项.</p><p>239 s->internal_buffer_count--;</p><p>240 last = &((InternalBuffer*)s->internal_buffer)[s->internal_buffer_count];</p><p>241</p><p>把将要空闲的数组项和数组最后一项交换，保证 internal_buffer_count 计算正确无误。注意这里并</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.047.png alt>没有内存释放的动作，便于下次复用已分配的内存。</p><p>242 temp = *buf;</p><p>243 *buf = *last;</p><p>244 *last = temp;</p><p>245</p><p>246 for (i = 0; i &lt; 3; i++)</p><p>247 {</p><p>把 data[i]置空，指示本块内存没有被占用，实际分配的首地址保持在 base[]中。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.054.png alt>整个程序最多分配 INTERNAL_ BUFFER_SIZE 次 avframe，其他次循环使用。</p><p>248 pic->data[i] = NULL;</p><p>249 }</p><p>250 }</p><p>251<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>重新获得缓存。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>252 int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)</p><p>253 {</p><p>254 if (pic->data[0] == NULL) // If no picture return a new buffer</p><p>255 {</p><p>256 return s->get_buffer(s, pic);</p><p>257 }</p><p>258</p><p>259 return 0;</p><p>260 }</p><p>261<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.041.png alt></p><p>释放内存数组项占用的内存。</p><p>262 void avcodec_default_free_buffers(AVCodecContext *s)</p><p>263 {</p><p>264 int i, j;</p><p>265</p><p>266 if (s->internal_buffer == NULL)</p><p>267 return ;</p><p>268</p><p>269 for (i = 0; i &lt; INTERNAL_BUFFER_SIZE; i++)</p><p>270 {</p><p>271 InternalBuffer *buf = &((InternalBuffer*)s->internal_buffer)[i];</p><p>272 for (j = 0; j &lt; 4; j++)</p><p>273 {</p><p>av_freep()函数调用的 av_free()函数做了非 NULL 判断，并且分配时已置 NULL，所以内循环可以到 4，</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.055.png alt>外循环可以到 INTERNAL_BUFFER_SIZE。</p><p>274 av_freep(&buf->base[j]);</p><p>275 buf->data[j] = NULL;</p><p>276 }</p><p>277 }</p><p>278 av_freep(&s->internal_buffer);</p><p>279</p><p>280 s->internal_buffer_count = 0;</p><p>281 }</p><p>282<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>分配编解码器上下文占用的内存，清 0 后部分参数赋初值。</p><p>283 AVCodecContext *avcodec_alloc_context(void)</p><p>284 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>285 AVCodecContext *s = av_malloc(sizeof(AVCodecContext));</p><p>286</p><p>287 if (s == NULL)</p><p>288 return NULL;</p><p>289<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>注意这里的清 0。</p><p>290 memset(s, 0, sizeof(AVCodecContext));</p><p>291</p><p>292 s->get_buffer = avcodec_default_get_buffer;</p><p>293 s->release_buffer = avcodec_default_release_buffer;</p><p>294</p><p>295 s->pix_fmt = PIX_FMT_NONE;</p><p>296</p><p>297 s->palctrl = NULL;</p><p>298 s->reget_buffer = avcodec_default_reget_buffer;</p><p>299</p><p>300 return s;</p><p>301 }</p><p>302<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>打开编解码器，分配具体编解码器使用的上下文，简单变量赋初值，调用初始化函数初始化编解码器</p><p>303 int avcodec_open(AVCodecContext *avctx, AVCodec *codec)</p><p>304 {</p><p>305 int ret = - 1;</p><p>306</p><p>307 if (avctx->codec)</p><p>308 goto end;</p><p>309</p><p>310 if (codec->priv_data_size > 0)</p><p>311 {</p><p>这里体现了 priv_data_size 参数的重大作用，如果没有这个参数，就要用 codec 结构的名字比较确</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.056.png alt>定具体编解码器使用的上下文结构大小，超级长的 if-else 语句。</p><p>312 avctx->priv_data = av_mallocz(codec->priv_data_size);</p><p>313 if (!avctx->priv_data)</p><p>314 goto end;</p><p>315 }</p><p>316 else</p><p>317 {</p><p>318 avctx->priv_data = NULL;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>319 }</p><p>320</p><p>321 avctx->codec = codec;</p><p>322 avctx->codec_id = codec->id;</p><p>323 avctx->frame_number = 0;</p><p>324 ret = avctx->codec->init(avctx);</p><p>325 if (ret &lt; 0)</p><p>326 {</p><p>327 av_freep(&avctx->priv_data);</p><p>328 avctx->codec = NULL;</p><p>329 goto end;</p><p>330 }</p><p>331 ret = 0;</p><p>332 end:</p><p>333 return ret;</p><p>334 }</p><p>335<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>视频解码，简单的跳转</p><p>336 int avcodec_decode_video(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr,</p><p>337 uint8_t *buf, int buf_size)</p><p>338 {</p><p>339 int ret;</p><p>340</p><p>341 *got_picture_ptr = 0;</p><p>342</p><p>343 if (buf_size)</p><p>344 {</p><p>345 ret = avctx->codec->decode(avctx, picture, got_picture_ptr, buf, buf_size);</p><p>346</p><p>347 if (*got_picture_ptr)</p><p>348 avctx->frame_number++;</p><p>349 }</p><p>350 else</p><p>351 ret = 0;</p><p>352</p><p>353 return ret;</p><p>354 }</p><p>355<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>音频解码，简单的跳转<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>356 int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr,</p><p>357 uint8_t *buf, int buf_size)</p><p>358 {</p><p>359 int ret;</p><p>360</p><p>361 *frame_size_ptr = 0;</p><p>362 if (buf_size)</p><p>363 {</p><p>364 ret = avctx->codec->decode(avctx, samples, frame_size_ptr, buf, buf_size);</p><p>365 avctx->frame_number++;</p><p>366 }</p><p>367 else</p><p>368 ret = 0;</p><p>369 return ret;</p><p>370 }</p><p>371<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.048.png alt></p><p>关闭解码器，释放动态分配的内存</p><p>372 int avcodec_close(AVCodecContext *avctx)</p><p>373 {</p><p>374 if (avctx->codec->close)</p><p>375 avctx->codec->close(avctx);</p><p>376 avcodec_default_free_buffers(avctx);</p><p>377 av_freep(&avctx->priv_data);</p><p>378 avctx->codec = NULL;</p><p>379 return 0;</p><p>380 }</p><p>381</p><p>查找编解码器，在本例中，读 avi 文件头得到 codec FOURCC ，再由 FOURCC 查找 codec_bmp_tags</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.057.png alt>或 codec_wav_tags 得到 CodecID 传给此函数。</p><p>382 AVCodec *avcodec_find_decoder(enum CodecID id)</p><p>383 {</p><p>384 AVCodec *p;</p><p>385 p = first_avcodec;</p><p>386 while (p)</p><p>387 {</p><p>388 if (p->decode != NULL && p->id == id)</p><p>389 return p;</p><p>390 p = p->next;</p><p>391 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>392 return NULL;</p><p>393 }</p><p>394<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>初始化编解码库，在本例中仅初始化限幅数组/查找表。</p><p>395 void avcodec_init(void)</p><p>396 {</p><p>397 static int inited = 0;</p><p>398</p><p>399 if (inited != 0)</p><p>400 return ;</p><p>401 inited = 1;</p><p>402</p><p>403 dsputil_static_init();</p><p>404 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=7-imgconvert_templateh-文件><strong>7 imgconvert_template.h 文件</strong></h3><p>7.1 功能描述</p><p>定义并实现图像颜色空间转换使用的函数和宏，此文件请各位自己仔细分析。</p><p>7.2 文件注释</p><p>1 #ifndef RGB_OUT</p><p>2 #define RGB_OUT(d, r, g, b) RGBA_OUT(d, r, g, b, 0xff)</p><p>3 #endif</p><p>4</p><p>5 #pragma warning (disable:4305 4244)</p><p>6<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>此文件请各位读者自行分析，都是些颜色空间转换函数。</p><p>7 static void glue(yuv420p_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>8 {</p><p>9 const uint8_t *y1_ptr, *y2_ptr, *cb_ptr, *cr_ptr;</p><p>10 uint8_t *d, *d1, *d2;</p><p>11 int w, y, cb, cr, r_add, g_add, b_add, width2;</p><p>12 uint8_t *cm = cropTbl + MAX_NEG_CROP;</p><p>13 unsigned int r, g, b;</p><p>14</p><p>15 d = dst->data[0];</p><p>16 y1_ptr = src->data[0];</p><p>17 cb_ptr = src->data[1];</p><p>18 cr_ptr = src->data[2];</p><p>19 width2 = (width + 1) >> 1;</p><p>20</p><p>21 for (; height >= 2; height -= 2)</p><p>22 {</p><p>23 d1 = d;</p><p>24 d2 = d + dst->linesize[0];</p><p>25 y2_ptr = y1_ptr + src->linesize[0];</p><p>26 for (w = width; w >= 2; w -= 2)</p><p>27 {</p><p>28 YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);</p><p>29</p><p>30 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]); /* output 4 pixels */</p><p>31 RGB_OUT(d1, r, g, b);</p><p>32</p><p>33 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[1]);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>34 RGB_OUT(d1 + BPP, r, g, b);</p><p>35</p><p>36 YUV_TO_RGB2_CCIR(r, g, b, y2_ptr[0]);</p><p>37 RGB_OUT(d2, r, g, b);</p><p>38</p><p>39 YUV_TO_RGB2_CCIR(r, g, b, y2_ptr[1]);</p><p>40 RGB_OUT(d2 + BPP, r, g, b);</p><p>41</p><p>42 d1 += 2 * BPP;</p><p>43 d2 += 2 * BPP;</p><p>44</p><p>45 y1_ptr += 2;</p><p>46 y2_ptr += 2;</p><p>47 cb_ptr++;</p><p>48 cr_ptr++;</p><p>49 }</p><p>50</p><p>51 if (w) /* handle odd width */</p><p>52 {</p><p>53 YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);</p><p>54 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]);</p><p>55 RGB_OUT(d1, r, g, b);</p><p>56</p><p>57 YUV_TO_RGB2_CCIR(r, g, b, y2_ptr[0]);</p><p>58 RGB_OUT(d2, r, g, b);</p><p>59 d1 += BPP;</p><p>60 d2 += BPP;</p><p>61 y1_ptr++;</p><p>62 y2_ptr++;</p><p>63 cb_ptr++;</p><p>64 cr_ptr++;</p><p>65 }</p><p>66 d += 2 * dst->linesize[0];</p><p>67 y1_ptr += 2 * src->linesize[0] - width;</p><p>68 cb_ptr += src->linesize[1] - width2;</p><p>69 cr_ptr += src->linesize[2] - width2;</p><p>70 }</p><p>71</p><p>72 if (height) /* handle odd height */</p><p>73 {</p><p>74 d1 = d;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>75 for (w = width; w >= 2; w -= 2)</p><p>76 {</p><p>77 YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);</p><p>78</p><p>79 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]); /* output 2 pixels */</p><p>80 RGB_OUT(d1, r, g, b);</p><p>81</p><p>82 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[1]);</p><p>83 RGB_OUT(d1 + BPP, r, g, b);</p><p>84</p><p>85 d1 += 2 * BPP;</p><p>86</p><p>87 y1_ptr += 2;</p><p>88 cb_ptr++;</p><p>89 cr_ptr++;</p><p>90 }</p><p>91</p><p>92 if (w) /* handle width */</p><p>93 {</p><p>94 YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);</p><p>95</p><p>96 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]); /* output 2 pixels */</p><p>97 RGB_OUT(d1, r, g, b);</p><p>98 d1 += BPP;</p><p>99</p><p>100 y1_ptr++;</p><p>101 cb_ptr++;</p><p>102 cr_ptr++;</p><p>103 }</p><p>104 }</p><p>105 }</p><p>106</p><p>107 static void glue(yuvj420p_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>108 {</p><p>109 const uint8_t *y1_ptr, *y2_ptr, *cb_ptr, *cr_ptr;</p><p>110 uint8_t *d, *d1, *d2;</p><p>111 int w, y, cb, cr, r_add, g_add, b_add, width2;</p><p>112 uint8_t *cm = cropTbl + MAX_NEG_CROP;</p><p>113 unsigned int r, g, b;</p><p>114</p><p>115 d = dst->data[0];<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>116 y1_ptr = src->data[0];</p><p>117 cb_ptr = src->data[1];</p><p>118 cr_ptr = src->data[2];</p><p>119 width2 = (width + 1) >> 1;</p><p>120</p><p>121 for (; height >= 2; height -= 2)</p><p>122 {</p><p>123 d1 = d;</p><p>124 d2 = d + dst->linesize[0];</p><p>125 y2_ptr = y1_ptr + src->linesize[0];</p><p>126 for (w = width; w >= 2; w -= 2)</p><p>127 {</p><p>128 YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);</p><p>129</p><p>130 YUV_TO_RGB2(r, g, b, y1_ptr[0]); /* output 4 pixels */</p><p>131 RGB_OUT(d1, r, g, b);</p><p>132</p><p>133 YUV_TO_RGB2(r, g, b, y1_ptr[1]);</p><p>134 RGB_OUT(d1 + BPP, r, g, b);</p><p>135</p><p>136 YUV_TO_RGB2(r, g, b, y2_ptr[0]);</p><p>137 RGB_OUT(d2, r, g, b);</p><p>138</p><p>139 YUV_TO_RGB2(r, g, b, y2_ptr[1]);</p><p>140 RGB_OUT(d2 + BPP, r, g, b);</p><p>141</p><p>142 d1 += 2 * BPP;</p><p>143 d2 += 2 * BPP;</p><p>144</p><p>145 y1_ptr += 2;</p><p>146 y2_ptr += 2;</p><p>147 cb_ptr++;</p><p>148 cr_ptr++;</p><p>149 }</p><p>150</p><p>151 if (w) /* handle odd width */</p><p>152 {</p><p>153 YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);</p><p>154 YUV_TO_RGB2(r, g, b, y1_ptr[0]);</p><p>155 RGB_OUT(d1, r, g, b);</p><p>156<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>157 YUV_TO_RGB2(r, g, b, y2_ptr[0]);</p><p>158 RGB_OUT(d2, r, g, b);</p><p>159 d1 += BPP;</p><p>160 d2 += BPP;</p><p>161 y1_ptr++;</p><p>162 y2_ptr++;</p><p>163 cb_ptr++;</p><p>164 cr_ptr++;</p><p>165 }</p><p>166 d += 2 * dst->linesize[0];</p><p>167 y1_ptr += 2 * src->linesize[0] - width;</p><p>168 cb_ptr += src->linesize[1] - width2;</p><p>169 cr_ptr += src->linesize[2] - width2;</p><p>170 }</p><p>171</p><p>172 if (height) /* handle odd height */</p><p>173 {</p><p>174 d1 = d;</p><p>175 for (w = width; w >= 2; w -= 2)</p><p>176 {</p><p>177 YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);</p><p>178</p><p>179 YUV_TO_RGB2(r, g, b, y1_ptr[0]); /* output 2 pixels */</p><p>180 RGB_OUT(d1, r, g, b);</p><p>181</p><p>182 YUV_TO_RGB2(r, g, b, y1_ptr[1]);</p><p>183 RGB_OUT(d1 + BPP, r, g, b);</p><p>184</p><p>185 d1 += 2 * BPP;</p><p>186</p><p>187 y1_ptr += 2;</p><p>188 cb_ptr++;</p><p>189 cr_ptr++;</p><p>190 }</p><p>191</p><p>192 if (w) /* handle width */</p><p>193 {</p><p>194 YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);</p><p>195</p><p>196 YUV_TO_RGB2(r, g, b, y1_ptr[0]); /* output 2 pixels */</p><p>197 RGB_OUT(d1, r, g, b);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>198 d1 += BPP;</p><p>199</p><p>200 y1_ptr++;</p><p>201 cb_ptr++;</p><p>202 cr_ptr++;</p><p>203 }</p><p>204 }</p><p>205 }</p><p>206</p><p>207 static void glue(RGB_NAME, _to_yuv420p)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>208 {</p><p>209 int wrap, wrap3, width2;</p><p>210 int r, g, b, r1, g1, b1, w;</p><p>211 uint8_t *lum, *cb, *cr;</p><p>212 const uint8_t *p;</p><p>213</p><p>214 lum = dst->data[0];</p><p>215 cb = dst->data[1];</p><p>216 cr = dst->data[2];</p><p>217</p><p>218 width2 = (width + 1) >> 1;</p><p>219 wrap = dst->linesize[0];</p><p>220 wrap3 = src->linesize[0];</p><p>221 p = src->data[0];</p><p>222 for (; height >= 2; height -= 2)</p><p>223 {</p><p>224 for (w = width; w >= 2; w -= 2)</p><p>225 {</p><p>226 RGB_IN(r, g, b, p);</p><p>227 r1 = r;</p><p>228 g1 = g;</p><p>229 b1 = b;</p><p>230 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>231</p><p>232 RGB_IN(r, g, b, p + BPP);</p><p>233 r1 += r;</p><p>234 g1 += g;</p><p>235 b1 += b;</p><p>236 lum[1] = RGB_TO_Y_CCIR(r, g, b);</p><p>237 p += wrap3;</p><p>238 lum += wrap;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>239</p><p>240 RGB_IN(r, g, b, p);</p><p>241 r1 += r;</p><p>242 g1 += g;</p><p>243 b1 += b;</p><p>244 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>245</p><p>246 RGB_IN(r, g, b, p + BPP);</p><p>247 r1 += r;</p><p>248 g1 += g;</p><p>249 b1 += b;</p><p>250 lum[1] = RGB_TO_Y_CCIR(r, g, b);</p><p>251</p><p>252 cb[0] = RGB_TO_U_CCIR(r1, g1, b1, 2);</p><p>253 cr[0] = RGB_TO_V_CCIR(r1, g1, b1, 2);</p><p>254</p><p>255 cb++;</p><p>256 cr++;</p><p>257 p += - wrap3 + 2 * BPP;</p><p>258 lum += - wrap + 2;</p><p>259 }</p><p>260 if (w)</p><p>261 {</p><p>262 RGB_IN(r, g, b, p);</p><p>263 r1 = r;</p><p>264 g1 = g;</p><p>265 b1 = b;</p><p>266 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>267 p += wrap3;</p><p>268 lum += wrap;</p><p>269 RGB_IN(r, g, b, p);</p><p>270 r1 += r;</p><p>271 g1 += g;</p><p>272 b1 += b;</p><p>273 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>274 cb[0] = RGB_TO_U_CCIR(r1, g1, b1, 1);</p><p>275 cr[0] = RGB_TO_V_CCIR(r1, g1, b1, 1);</p><p>276 cb++;</p><p>277 cr++;</p><p>278 p += - wrap3 + BPP;</p><p>279 lum += - wrap + 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>280 }</p><p>281 p += wrap3 + (wrap3 - width * BPP);</p><p>282 lum += wrap + (wrap - width);</p><p>283 cb += dst->linesize[1] - width2;</p><p>284 cr += dst->linesize[2] - width2;</p><p>285 }</p><p>286</p><p>287 if (height) /* handle odd height */</p><p>288 {</p><p>289 for (w = width; w >= 2; w -= 2)</p><p>290 {</p><p>291 RGB_IN(r, g, b, p);</p><p>292 r1 = r;</p><p>293 g1 = g;</p><p>294 b1 = b;</p><p>295 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>296</p><p>297 RGB_IN(r, g, b, p + BPP);</p><p>298 r1 += r;</p><p>299 g1 += g;</p><p>300 b1 += b;</p><p>301 lum[1] = RGB_TO_Y_CCIR(r, g, b);</p><p>302 cb[0] = RGB_TO_U_CCIR(r1, g1, b1, 1);</p><p>303 cr[0] = RGB_TO_V_CCIR(r1, g1, b1, 1);</p><p>304 cb++;</p><p>305 cr++;</p><p>306 p += 2 * BPP;</p><p>307 lum += 2;</p><p>308 }</p><p>309 if (w)</p><p>310 {</p><p>311 RGB_IN(r, g, b, p);</p><p>312 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>313 cb[0] = RGB_TO_U_CCIR(r, g, b, 0);</p><p>314 cr[0] = RGB_TO_V_CCIR(r, g, b, 0);</p><p>315 }</p><p>316 }</p><p>317 }</p><p>318</p><p>319 static void glue(RGB_NAME, _to_gray)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>320 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>321 const unsigned char *p;</p><p>322 unsigned char *q;</p><p>323 int r, g, b, dst_wrap, src_wrap;</p><p>324 int x, y;</p><p>325</p><p>326 p = src->data[0];</p><p>327 src_wrap = src->linesize[0] - BPP * width;</p><p>328</p><p>329 q = dst->data[0];</p><p>330 dst_wrap = dst->linesize[0] - width;</p><p>331</p><p>332 for (y = 0; y &lt; height; y++)</p><p>333 {</p><p>334 for (x = 0; x &lt; width; x++)</p><p>335 {</p><p>336 RGB_IN(r, g, b, p);</p><p>337 q[0] = RGB_TO_Y(r, g, b);</p><p>338 q++;</p><p>339 p += BPP;</p><p>340 }</p><p>341 p += src_wrap;</p><p>342 q += dst_wrap;</p><p>343 }</p><p>344 }</p><p>345</p><p>346 static void glue(gray_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>347 {</p><p>348 const unsigned char *p;</p><p>349 unsigned char *q;</p><p>350 int r, dst_wrap, src_wrap;</p><p>351 int x, y;</p><p>352</p><p>353 p = src->data[0];</p><p>354 src_wrap = src->linesize[0] - width;</p><p>355</p><p>356 q = dst->data[0];</p><p>357 dst_wrap = dst->linesize[0] - BPP * width;</p><p>358</p><p>359 for (y = 0; y &lt; height; y++)</p><p>360 {</p><p>361 for (x = 0; x &lt; width; x++)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>362 {</p><p>363 r = p[0];</p><p>364 RGB_OUT(q, r, r, r);</p><p>365 q += BPP;</p><p>366 p++;</p><p>367 }</p><p>368 p += src_wrap;</p><p>369 q += dst_wrap;</p><p>370 }</p><p>371 }</p><p>372</p><p>373 static void glue(pal8_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>374 {</p><p>375 const unsigned char *p;</p><p>376 unsigned char *q;</p><p>377 int r, g, b, dst_wrap, src_wrap;</p><p>378 int x, y;</p><p>379 uint32_t v;</p><p>380 const uint32_t *palette;</p><p>381</p><p>382 p = src->data[0];</p><p>383 src_wrap = src->linesize[0] - width;</p><p>384 palette = (uint32_t*)src->data[1];</p><p>385</p><p>386 q = dst->data[0];</p><p>387 dst_wrap = dst->linesize[0] - BPP * width;</p><p>388</p><p>389 for (y = 0; y &lt; height; y++)</p><p>390 {</p><p>391 for (x = 0; x &lt; width; x++)</p><p>392 {</p><p>393 v = palette[p[0]];</p><p>394 r = (v >> 16) &amp;0xff;</p><p>395 g = (v >> 8) &amp;0xff;</p><p>396 b = (v) &amp;0xff;</p><p>397 #ifdef RGBA_OUT</p><p>398 {</p><p>399 int a;</p><p>400 a = (v >> 24) &amp;0xff;</p><p>401 RGBA_OUT(q, r, g, b, a);</p><p>402 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>403 #else</p><p>404 RGB_OUT(q, r, g, b);</p><p>405 #endif</p><p>406 q += BPP;</p><p>407 p++;</p><p>408 }</p><p>409 p += src_wrap;</p><p>410 q += dst_wrap;</p><p>411 }</p><p>412 }</p><p>413</p><p>414 #if !defined(FMT_RGBA32) && defined(RGBA_OUT)</p><p>415 /* alpha support */</p><p>416</p><p>417 static void glue(rgba32_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>418 {</p><p>419 const uint8_t *s;</p><p>420 uint8_t *d;</p><p>421 int src_wrap, dst_wrap, j, y;</p><p>422 unsigned int v, r, g, b, a;</p><p>423</p><p>424 s = src->data[0];</p><p>425 src_wrap = src->linesize[0] - width * 4;</p><p>426</p><p>427 d = dst->data[0];</p><p>428 dst_wrap = dst->linesize[0] - width * BPP;</p><p>429</p><p>430 for (y = 0; y &lt; height; y++)</p><p>431 {</p><p>432 for (j = 0; j &lt; width; j++)</p><p>433 {</p><p>434 v = ((const uint32_t*)(s))[0];</p><p>435 a = (v >> 24) &amp;0xff;</p><p>436 r = (v >> 16) &amp;0xff;</p><p>437 g = (v >> 8) &amp;0xff;</p><p>438 b = v &amp;0xff;</p><p>439 RGBA_OUT(d, r, g, b, a);</p><p>440 s += 4;</p><p>441 d += BPP;</p><p>442 }</p><p>443 s += src_wrap;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>444 d += dst_wrap;</p><p>445 }</p><p>446 }</p><p>447</p><p>448 static void glue(RGB_NAME, _to_rgba32)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>449 {</p><p>450 const uint8_t *s;</p><p>451 uint8_t *d;</p><p>452 int src_wrap, dst_wrap, j, y;</p><p>453 unsigned int r, g, b, a;</p><p>454</p><p>455 s = src->data[0];</p><p>456 src_wrap = src->linesize[0] - width * BPP;</p><p>457</p><p>458 d = dst->data[0];</p><p>459 dst_wrap = dst->linesize[0] - width * 4;</p><p>460</p><p>461 for (y = 0; y &lt; height; y++)</p><p>462 {</p><p>463 for (j = 0; j &lt; width; j++)</p><p>464 {</p><p>465 RGBA_IN(r, g, b, a, s);</p><p>466 ((uint32_t*)(d))[0] = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;</p><p>467 d += 4;</p><p>468 s += BPP;</p><p>469 }</p><p>470 s += src_wrap;</p><p>471 d += dst_wrap;</p><p>472 }</p><p>473 }</p><p>474</p><p>475 #endif /* !defined(FMT_RGBA32) && defined(RGBA_IN) */</p><p>476</p><p>477 #ifndef FMT_RGB24</p><p>478</p><p>479 static void glue(rgb24_to_, RGB_NAME)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>480 {</p><p>481 const uint8_t *s;</p><p>482 uint8_t *d;</p><p>483 int src_wrap, dst_wrap, j, y;</p><p>484 unsigned int r, g, b;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>485</p><p>486 s = src->data[0];</p><p>487 src_wrap = src->linesize[0] - width * 3;</p><p>488</p><p>489 d = dst->data[0];</p><p>490 dst_wrap = dst->linesize[0] - width * BPP;</p><p>491</p><p>492 for (y = 0; y &lt; height; y++)</p><p>493 {</p><p>494 for (j = 0; j &lt; width; j++)</p><p>495 {</p><p>496 r = s[0];</p><p>497 g = s[1];</p><p>498 b = s[2];</p><p>499 RGB_OUT(d, r, g, b);</p><p>500 s += 3;</p><p>501 d += BPP;</p><p>502 }</p><p>503 s += src_wrap;</p><p>504 d += dst_wrap;</p><p>505 }</p><p>506 }</p><p>507</p><p>508 static void glue(RGB_NAME, _to_rgb24)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>509 {</p><p>510 const uint8_t *s;</p><p>511 uint8_t *d;</p><p>512 int src_wrap, dst_wrap, j, y;</p><p>513 unsigned int r, g, b;</p><p>514</p><p>515 s = src->data[0];</p><p>516 src_wrap = src->linesize[0] - width * BPP;</p><p>517</p><p>518 d = dst->data[0];</p><p>519 dst_wrap = dst->linesize[0] - width * 3;</p><p>520</p><p>521 for (y = 0; y &lt; height; y++)</p><p>522 {</p><p>523 for (j = 0; j &lt; width; j++)</p><p>524 {</p><p>525 RGB_IN(r, g, b, s)d[0] = r;</p><table><thead><tr><th>526</th><th></th><th>d[1]</th><th>= g;</th></tr></thead><tbody><tr><td>527</td><td></td><td>d[2]</td><td>= b;</td></tr><tr><td>528</td><td></td><td>d +=</td><td>3;</td></tr><tr><td>529</td><td></td><td>s +=</td><td>BPP;</td></tr><tr><td>530</td><td>}</td><td></td><td></td></tr><tr><td>531 s += src_wrap;</td><td></td><td></td><td></td></tr></tbody></table><p>532 d += dst_wrap;</p><p>533 }</p><p>534 }</p><p>535</p><p>536 #endif /* !FMT_RGB24 */</p><p>537</p><p>538 #ifdef FMT_RGB24</p><p>539</p><p>540 static void yuv444p_to_rgb24(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>541 {</p><p>542 const uint8_t *y1_ptr, *cb_ptr, *cr_ptr;</p><p>543 uint8_t *d, *d1;</p><p>544 int w, y, cb, cr, r_add, g_add, b_add;</p><p>545 uint8_t *cm = cropTbl + MAX_NEG_CROP;</p><p>546 unsigned int r, g, b;</p><p>547</p><p>548 d = dst->data[0];</p><p>549 y1_ptr = src->data[0];</p><p>550 cb_ptr = src->data[1];</p><p>551 cr_ptr = src->data[2];</p><p>552 for (; height > 0; height--)</p><p>553 {</p><p>554 d1 = d;</p><p>555 for (w = width; w > 0; w--)</p><p>556 {</p><p>557 YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);</p><p>558</p><p>559 YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]);</p><p>560 RGB_OUT(d1, r, g, b);</p><p>561 d1 += BPP;</p><p>562</p><p>563 y1_ptr++;</p><p>564 cb_ptr++;</p><p>565 cr_ptr++;</p><p>566 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>567 d += dst->linesize[0];</p><p>568 y1_ptr += src->linesize[0] - width;</p><p>569 cb_ptr += src->linesize[1] - width;</p><p>570 cr_ptr += src->linesize[2] - width;</p><p>571 }</p><p>572 }</p><p>573</p><p>574 static void yuvj444p_to_rgb24(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>575 {</p><p>576 const uint8_t *y1_ptr, *cb_ptr, *cr_ptr;</p><p>577 uint8_t *d, *d1;</p><p>578 int w, y, cb, cr, r_add, g_add, b_add;</p><p>579 uint8_t *cm = cropTbl + MAX_NEG_CROP;</p><p>580 unsigned int r, g, b;</p><p>581</p><p>582 d = dst->data[0];</p><p>583 y1_ptr = src->data[0];</p><p>584 cb_ptr = src->data[1];</p><p>585 cr_ptr = src->data[2];</p><p>586 for (; height > 0; height--)</p><p>587 {</p><p>588 d1 = d;</p><p>589 for (w = width; w > 0; w--)</p><p>590 {</p><p>591 YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);</p><p>592</p><p>593 YUV_TO_RGB2(r, g, b, y1_ptr[0]);</p><p>594 RGB_OUT(d1, r, g, b);</p><p>595 d1 += BPP;</p><p>596</p><p>597 y1_ptr++;</p><p>598 cb_ptr++;</p><p>599 cr_ptr++;</p><p>600 }</p><p>601 d += dst->linesize[0];</p><p>602 y1_ptr += src->linesize[0] - width;</p><p>603 cb_ptr += src->linesize[1] - width;</p><p>604 cr_ptr += src->linesize[2] - width;</p><p>605 }</p><p>606 }</p><p>607<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>608 static void rgb24_to_yuv444p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>609 {</p><p>610 int src_wrap, x, y;</p><p>611 int r, g, b;</p><p>612 uint8_t *lum, *cb, *cr;</p><p>613 const uint8_t *p;</p><p>614</p><p>615 lum = dst->data[0];</p><p>616 cb = dst->data[1];</p><p>617 cr = dst->data[2];</p><p>618</p><p>619 src_wrap = src->linesize[0] - width * BPP;</p><p>620 p = src->data[0];</p><p>621</p><p>622 for (y = 0; y &lt; height; y++)</p><p>623 {</p><p>624 for (x = 0; x &lt; width; x++)</p><p>625 {</p><p>626 RGB_IN(r, g, b, p);</p><p>627 lum[0] = RGB_TO_Y_CCIR(r, g, b);</p><p>628 cb[0] = RGB_TO_U_CCIR(r, g, b, 0);</p><p>629 cr[0] = RGB_TO_V_CCIR(r, g, b, 0);</p><p>630 p += BPP;</p><p>631 cb++;</p><p>632 cr++;</p><p>633 lum++;</p><p>634 }</p><p>635 p += src_wrap;</p><p>636 lum += dst->linesize[0] - width;</p><p>637 cb += dst->linesize[1] - width;</p><p>638 cr += dst->linesize[2] - width;</p><p>639 }</p><p>640 }</p><p>641</p><p>642 static void rgb24_to_yuvj420p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>643 {</p><p>644 int wrap, wrap3, width2;</p><p>645 int r, g, b, r1, g1, b1, w;</p><p>646 uint8_t *lum, *cb, *cr;</p><p>647 const uint8_t *p;</p><p>648<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>649 lum = dst->data[0];</p><p>650 cb = dst->data[1];</p><p>651 cr = dst->data[2];</p><p>652</p><p>653 width2 = (width + 1) >> 1;</p><p>654 wrap = dst->linesize[0];</p><p>655 wrap3 = src->linesize[0];</p><p>656 p = src->data[0];</p><p>657 for (; height >= 2; height -= 2)</p><p>658 {</p><p>659 for (w = width; w >= 2; w -= 2)</p><p>660 {</p><p>661 RGB_IN(r, g, b, p);</p><p>662 r1 = r;</p><p>663 g1 = g;</p><p>664 b1 = b;</p><p>665 lum[0] = RGB_TO_Y(r, g, b);</p><p>666</p><p>667 RGB_IN(r, g, b, p + BPP);</p><p>668 r1 += r;</p><p>669 g1 += g;</p><p>670 b1 += b;</p><p>671 lum[1] = RGB_TO_Y(r, g, b);</p><p>672 p += wrap3;</p><p>673 lum += wrap;</p><p>674</p><p>675 RGB_IN(r, g, b, p);</p><p>676 r1 += r;</p><p>677 g1 += g;</p><p>678 b1 += b;</p><p>679 lum[0] = RGB_TO_Y(r, g, b);</p><p>680</p><p>681 RGB_IN(r, g, b, p + BPP);</p><p>682 r1 += r;</p><p>683 g1 += g;</p><p>684 b1 += b;</p><p>685 lum[1] = RGB_TO_Y(r, g, b);</p><p>686</p><p>687 cb[0] = RGB_TO_U(r1, g1, b1, 2);</p><p>688 cr[0] = RGB_TO_V(r1, g1, b1, 2);</p><p>689</p><table><thead><tr><th>690</th><th></th><th>cb++;</th></tr></thead><tbody><tr><td>691</td><td></td><td>cr++;</td></tr><tr><td>692</td><td></td><td>p += - wrap3 + 2 * BPP;</td></tr><tr><td>693</td><td></td><td>lum += - wrap + 2;</td></tr><tr><td>694</td><td>}</td><td></td></tr><tr><td>695 if (w)</td><td></td><td></td></tr></tbody></table><p>696 {</p><p>697 RGB_IN(r, g, b, p);</p><p>698 r1 = r;</p><p>699 g1 = g;</p><p>700 b1 = b;</p><p>701 lum[0] = RGB_TO_Y(r, g, b);</p><p>702 p += wrap3;</p><p>703 lum += wrap;</p><p>704 RGB_IN(r, g, b, p);</p><p>705 r1 += r;</p><p>706 g1 += g;</p><p>707 b1 += b;</p><p>708 lum[0] = RGB_TO_Y(r, g, b);</p><p>709 cb[0] = RGB_TO_U(r1, g1, b1, 1);</p><p>710 cr[0] = RGB_TO_V(r1, g1, b1, 1);</p><p>711 cb++;</p><p>712 cr++;</p><p>713 p += - wrap3 + BPP;</p><p>714 lum += - wrap + 1;</p><p>715 }</p><p>716 p += wrap3 + (wrap3 - width * BPP);</p><p>717 lum += wrap + (wrap - width);</p><p>718 cb += dst->linesize[1] - width2;</p><p>719 cr += dst->linesize[2] - width2;</p><p>720 }</p><p>721</p><p>722 if (height) /* handle odd height */</p><p>723 {</p><p>724 for (w = width; w >= 2; w -= 2)</p><p>725 {</p><p>726 RGB_IN(r, g, b, p);</p><p>727 r1 = r;</p><p>728 g1 = g;</p><p>729 b1 = b;</p><p>730 lum[0] = RGB_TO_Y(r, g, b);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>731</p><p>732 RGB_IN(r, g, b, p + BPP);</p><p>733 r1 += r;</p><p>734 g1 += g;</p><p>735 b1 += b;</p><p>736 lum[1] = RGB_TO_Y(r, g, b);</p><p>737 cb[0] = RGB_TO_U(r1, g1, b1, 1);</p><p>738 cr[0] = RGB_TO_V(r1, g1, b1, 1);</p><p>739 cb++;</p><p>740 cr++;</p><p>741 p += 2 * BPP;</p><p>742 lum += 2;</p><p>743 }</p><p>744 if (w)</p><p>745 {</p><p>746 RGB_IN(r, g, b, p);</p><p>747 lum[0] = RGB_TO_Y(r, g, b);</p><p>748 cb[0] = RGB_TO_U(r, g, b, 0);</p><p>749 cr[0] = RGB_TO_V(r, g, b, 0);</p><p>750 }</p><p>751 }</p><p>752 }</p><p>753</p><p>754 static void rgb24_to_yuvj444p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>755 {</p><p>756 int src_wrap, x, y;</p><p>757 int r, g, b;</p><p>758 uint8_t *lum, *cb, *cr;</p><p>759 const uint8_t *p;</p><p>760</p><p>761 lum = dst->data[0];</p><p>762 cb = dst->data[1];</p><p>763 cr = dst->data[2];</p><p>764</p><p>765 src_wrap = src->linesize[0] - width * BPP;</p><p>766 p = src->data[0];</p><p>767 for (y = 0; y &lt; height; y++)</p><p>768 {</p><p>769 for (x = 0; x &lt; width; x++)</p><p>770 {</p><p>771 RGB_IN(r, g, b, p);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>772 lum[0] = RGB_TO_Y(r, g, b);</p><p>773 cb[0] = RGB_TO_U(r, g, b, 0);</p><p>774 cr[0] = RGB_TO_V(r, g, b, 0);</p><p>775 p += BPP;</p><p>776 cb++;</p><p>777 cr++;</p><p>778 lum++;</p><p>779 }</p><p>780 p += src_wrap;</p><p>781 lum += dst->linesize[0] - width;</p><p>782 cb += dst->linesize[1] - width;</p><p>783 cr += dst->linesize[2] - width;</p><p>784 }</p><p>785 }</p><p>786</p><p>787 #endif /* FMT_RGB24 */</p><p>788</p><p>789 #if defined(FMT_RGB24) || defined(FMT_RGBA32)</p><p>790</p><p>791 static void glue(RGB_NAME, _to_pal8)(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>792 {</p><p>793 const unsigned char *p;</p><p>794 unsigned char *q;</p><p>795 int dst_wrap, src_wrap;</p><p>796 int x, y, has_alpha;</p><p>797 unsigned int r, g, b;</p><p>798</p><p>799 p = src->data[0];</p><p>800 src_wrap = src->linesize[0] - BPP * width;</p><p>801</p><p>802 q = dst->data[0];</p><p>803 dst_wrap = dst->linesize[0] - width;</p><p>804 has_alpha = 0;</p><p>805</p><p>806 for (y = 0; y &lt; height; y++)</p><p>807 {</p><p>808 for (x = 0; x &lt; width; x++)</p><p>809 {</p><p>810 #ifdef RGBA_IN</p><p>811 {</p><p>812 unsigned int a;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>813 RGBA_IN(r, g, b, a, p);</p><p>814</p><p>815 if (a &lt; 0x80) /* crude approximation for alpha ! */</p><p>816 {</p><p>817 has_alpha = 1;</p><p>818 q[0] = TRANSP_INDEX;</p><p>819 }</p><p>820 else</p><p>821 {</p><p>822 q[0] = gif_clut_index(r, g, b);</p><p>823 }</p><p>824 }</p><p>825 #else</p><p>826 RGB_IN(r, g, b, p);</p><p>827 q[0] = gif_clut_index(r, g, b);</p><p>828 #endif</p><p>829 q++;</p><p>830 p += BPP;</p><p>831 }</p><p>832 p += src_wrap;</p><p>833 q += dst_wrap;</p><p>834 }</p><p>835</p><p>836 build_rgb_palette(dst->data[1], has_alpha);</p><p>837 }</p><p>838</p><p>839 #endif /* defined(FMT_RGB24) || defined(FMT_RGBA32) */</p><p>840</p><p>841 #ifdef RGBA_IN</p><p>842</p><p>843 #define FF_ALPHA_TRANSP 0x0001 /* image has some totally transparent pixels */</p><p>844 #define FF_ALPHA_SEMI_TRANSP 0x0002 /* image has some transparent pixels */</p><p>845</p><p>846 static int glue(get_alpha_info_, RGB_NAME)(const AVPicture *src, int width, int height)</p><p>847 {</p><p>848 const unsigned char *p;</p><p>849 int src_wrap, ret, x, y;</p><p>850 unsigned int r, g, b, a;</p><p>851</p><p>852 p = src->data[0];</p><p>853 src_wrap = src->linesize[0] - BPP * width;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>854 ret = 0;</p><p>855 for (y = 0; y &lt; height; y++)</p><p>856 {</p><p>857 for (x = 0; x &lt; width; x++)</p><p>858 {</p><p>859 RGBA_IN(r, g, b, a, p);</p><p>860 if (a == 0x00)</p><p>861 {</p><p>862 ret |= FF_ALPHA_TRANSP;</p><p>863 }</p><p>864 else if (a != 0xff)</p><p>865 {</p><p>866 ret |= FF_ALPHA_SEMI_TRANSP;</p><p>867 }</p><p>868 p += BPP;</p><p>869 }</p><p>870 p += src_wrap;</p><p>871 }</p><p>872 return ret;</p><p>873 }</p><p>874</p><p>875 #endif /* RGBA_IN */</p><p>876</p><p>877 #undef RGB_IN</p><p>878 #undef RGBA_IN</p><p>879 #undef RGB_OUT</p><p>880 #undef RGBA_OUT</p><p>881 #undef BPP</p><p>882 #undef RGB_NAME</p><p>883 #undef FMT_RGB24</p><p>884 #undef FMT_RGBA32<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=8-imgconvertc-文件><strong>8 imgconvert.c 文件</strong></h3><p>8.1 功能描述</p><p>定义并实现图像颜色空间转换使用的函数和宏，此文件大部分请各位自己仔细分析。</p><p>8.2 文件注释</p><p>1 #include "avcodec.h"</p><p>2 #include "dsputil.h"</p><p>3</p><p>4 #define xglue(x, y) x ## y</p><p>5 #define glue(x, y) xglue(x, y)</p><p>6</p><p>7 #define FF_COLOR_RGB 0 // RGB color space</p><p>8 #define FF_COLOR_GRAY 1 // gray color space</p><p>9 #define FF_COLOR_YUV 2 // YUV color space. 16 &lt;= Y &lt;= 235, 16 &lt;= U, V &lt;= 240</p><p>10 #define FF_COLOR_YUV_JPEG 3 // YUV color space. 0 &lt;= Y &lt;= 255, 0 &lt;= U, V &lt;= 255</p><p>11</p><p>12 #define FF_PIXEL_PLANAR 0 // each channel has one component in AVPicture</p><p>13 #define FF_PIXEL_PACKED 1 // only one components containing all the channels</p><p>14 #define FF_PIXEL_PALETTE 2 // one components containing indexes for a palette</p><p>15<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.059.png alt></p><p>定义视频图像格式信息类型。</p><p>16 typedef struct PixFmtInfo</p><p>17 {</p><p>18 const char *name;</p><p>19 uint8_t nb_channels; // number of channels (including alpha)</p><p>20 uint8_t color_type; // color type (see FF_COLOR_xxx constants)</p><p>21 uint8_t pixel_type; // pixel storage type (see FF_PIXEL_xxx constants)</p><p>22 uint8_t is_alpha; // true if alpha can be specified</p><p>23 uint8_t x_chroma_shift; // X chroma subsampling factor is 2 ^ shift</p><p>24 uint8_t y_chroma_shift; // Y chroma subsampling factor is 2 ^ shift</p><p>25 uint8_t depth; // bit depth of the color components</p><p>26 } PixFmtInfo;</p><p>27<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.059.png alt></p><p>定义支持的视频图像格式信息。</p><p>28 // this table gives more information about formats</p><p>29 static PixFmtInfo pix_fmt_info[PIX_FMT_NB] =</p><p>30 {</p><p>31 { "yuv420p", 3, FF_COLOR_YUV, FF_PIXEL_PLANAR, 0, 1, 1, 8},<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>32 { "yuv422", 1, FF_COLOR_YUV,</p><p>33 { "rgb24", 3, FF_COLOR_RGB,</p><p>34 { "bgr24", 3, FF_COLOR_RGB,</p><p>35 { "yuv422p", 3, FF_COLOR_YUV,</p><p>36 { "yuv444p", 3, FF_COLOR_YUV,</p><p>37 { "rgba32", 4, FF_COLOR_RGB,</p><p>38 { "yuv410p", 3, FF_COLOR_YUV,</p><p>39 { "yuv411p", 3, FF_COLOR_YUV,</p><p>40 { "rgb565", 3, FF_COLOR_RGB,</p><p>41 { "rgb555", 4, FF_COLOR_RGB,</p><p>FF_PIXEL_PACKED, 0, 1, 0, 8}, FF_PIXEL_PACKED, 0, 0, 0, 8}, FF_PIXEL_PACKED, 0, 0, 0, 8}, FF_PIXEL_PLANAR, 0, 1, 0, 8}, FF_PIXEL_PLANAR, 0, 0, 0, 8}, FF_PIXEL_PACKED, 1, 0, 0, 8}, FF_PIXEL_PLANAR, 0, 2, 2, 8}, FF_PIXEL_PLANAR, 0, 2, 0, 8}, FF_PIXEL_PACKED, 0, 0, 0, 5}, FF_PIXEL_PACKED, 1, 0, 0, 5},</p><p>568
<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.060.png alt></p><p>42 { "gray", 1, FF_COLOR_GRAY, FF_PIXEL_PLANAR, 0, 0, 0, 8},</p><p>43 { "monow", 1, FF_COLOR_GRAY, FF_PIXEL_PLANAR, 0, 0, 0, 1},</p><p>44 { "monob", 1, FF_COLOR_GRAY, FF_PIXEL_PLANAR, 0, 0, 0, 1},</p><p>45 { "pal8", 4, FF_COLOR_RGB, FF_PIXEL_PALETTE, 1, 0, 0, 8},</p><p>46 { "yuvj420p", 3, FF_COLOR_YUV_JPEG, FF_PIXEL_PLANAR, 0, 1, 1, 8},</p><p>47 { "yuvj422p", 3, FF_COLOR_YUV_JPEG, FF_PIXEL_PLANAR, 0, 1, 0, 8},</p><p>48 { "yuvj444p", 3, FF_COLOR_YUV_JPEG, FF_PIXEL_PLANAR, 0, 0, 0, 8},</p><p>49 { "xvmcmc", },</p><p>50 { "xvmcidct",},</p><p>51 { "uyvy422", 1, FF_COLOR_YUV, FF_PIXEL_PACKED, 0, 1, 0, 8},</p><p>52 { "uyvy411", 1, FF_COLOR_YUV, FF_PIXEL_PACKED, 0, 2, 0, 8},</p><p>53 };</p><p>54<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>读取视频图像格式信息中色度相对亮度采样比例(用移位的位数表示)。</p><p>55 void avcodec_get_chroma_sub_sample(int pix_fmt, int *h_shift, int *v_shift)</p><p>56 {</p><p>57 *h_shift = pix_fmt_info[pix_fmt].x_chroma_shift;</p><p>58 *v_shift = pix_fmt_info[pix_fmt].y_chroma_shift;</p><p>59 }</p><p>60<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>填充各种视频图像格式对应的 AVPicture 结构字段，返回图像大小。</p><p>61 // Picture field are filled with 'ptr' addresses. Also return size</p><p>62 int avpicture_fill(AVPicture *picture, uint8_t *ptr, int pix_fmt, int width, int height)</p><p>63 {</p><p>64 int size, w2, h2, size2;</p><p>65 PixFmtInfo *pinfo;</p><p>66<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>图像像素大小规整，比如 YUV420P 宽度和高度必须是 2 的整数倍，如果不符合，程序自动填充补足。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>67 if (avcodec_check_dimensions(NULL, width, height))</p><p>68 goto fail;</p><p>69</p><p>70 pinfo = &pix_fmt_info[pix_fmt];</p><p>71 size = width * height;</p><p>72 switch (pix_fmt)</p><p>73 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>按照图像格式，分别计算 AVPicture 结构字段的值。</p><p>74 case PIX_FMT_YUV420P:</p><p>75 case PIX_FMT_YUV422P:</p><p>76 case PIX_FMT_YUV444P:</p><p>77 case PIX_FMT_YUV410P:</p><p>78 case PIX_FMT_YUV411P:</p><p>79 case PIX_FMT_YUVJ420P:</p><p>80 case PIX_FMT_YUVJ422P:</p><p>81 case PIX_FMT_YUVJ444P:</p><p>82 w2 = (width + (1 &lt;&lt; pinfo->x_chroma_shift) - 1) >> pinfo->x_chroma_shift;</p><p>83 h2 = (height + (1 &lt;&lt; pinfo->y_chroma_shift) - 1) >> pinfo->y_chroma_shift;</p><p>84 size2 = w2 * h2;</p><p>85 picture->data[0] = ptr;</p><p>86 picture->data[1] = picture->data[0] + size;</p><p>87 picture->data[2] = picture->data[1] + size2;</p><p>88 picture->linesize[0] = width;</p><p>89 picture->linesize[1] = w2;</p><p>90 picture->linesize[2] = w2;</p><p>91 return size + 2 * size2;</p><p>92 case PIX_FMT_RGB24:</p><p>93 case PIX_FMT_BGR24:</p><p>94 picture->data[0] = ptr;</p><p>95 picture->data[1] = NULL;</p><p>96 picture->data[2] = NULL;</p><p>97 picture->linesize[0] = width * 3;</p><p>98 return size *3;</p><p>99 case PIX_FMT_RGBA32:</p><p>100 picture->data[0] = ptr;</p><p>101 picture->data[1] = NULL;</p><p>102 picture->data[2] = NULL;</p><p>103 picture->linesize[0] = width * 4;</p><p>104 return size *4;</p><p>105 case PIX_FMT_RGB555:</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>106 case PIX_FMT_RGB565:</p><p>107 case PIX_FMT_YUV422:</p><p>108 picture->data[0] = ptr;</p><p>109 picture->data[1] = NULL;</p><p>110 picture->data[2] = NULL;</p><p>111 picture->linesize[0] = width * 2;</p><p>112 return size *2;</p><p>113 case PIX_FMT_UYVY422:</p><p>114 picture->data[0] = ptr;</p><p>115 picture->data[1] = NULL;</p><p>116 picture->data[2] = NULL;</p><p>117 picture->linesize[0] = width * 2;</p><p>118 return size *2;</p><p>119 case PIX_FMT_UYVY411:</p><p>120 picture->data[0] = ptr;</p><p>121 picture->data[1] = NULL;</p><p>122 picture->data[2] = NULL;</p><p>123 picture->linesize[0] = width + width / 2;</p><p>124 return size + size / 2;</p><p>125 case PIX_FMT_GRAY8:</p><p>126 picture->data[0] = ptr;</p><p>127 picture->data[1] = NULL;</p><p>128 picture->data[2] = NULL;</p><p>129 picture->linesize[0] = width;</p><p>130 return size;</p><p>131 case PIX_FMT_MONOWHITE:</p><p>132 case PIX_FMT_MONOBLACK:</p><p>133 picture->data[0] = ptr;</p><p>134 picture->data[1] = NULL;</p><p>135 picture->data[2] = NULL;</p><p>136 picture->linesize[0] = (width + 7) >> 3;</p><p>137 return picture->linesize[0] *height;</p><p>138 case PIX_FMT_PAL8:</p><p>139 size2 = (size + 3) &~3;</p><p>140 picture->data[0] = ptr;</p><p>141 picture->data[1] = ptr + size2; // palette is stored here as 256 32 bit words</p><p>142 picture->data[2] = NULL;</p><p>143 picture->linesize[0] = width;</p><p>144 picture->linesize[1] = 4;</p><p>145 return size2 + 256 * 4;</p><p>146 default:</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>147 fail:</p><p>148 picture->data[0] = NULL;</p><p>149 picture->data[1] = NULL;</p><p>150 picture->data[2] = NULL;</p><p>151 picture->data[3] = NULL;</p><p>152 return - 1;</p><p>153 }</p><p>154 }</p><p>155<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>传入像素格式，图像长宽，计算图像大小。程序简单的复用 avpicture_fill()函数的返回值。</p><p>156 int avpicture_get_size(int pix_fmt, int width, int height)</p><p>157 {</p><p>158 AVPicture dummy_pict;</p><p>159 return avpicture_fill(&dummy_pict, NULL, pix_fmt, width, height);</p><p>160 }</p><p>161<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>初始化 AVPicture 结构。输入像素格式和长宽，计算图像大小，分配图像缓存，填充 AVPicture 结构 。</p><p>162 int avpicture_alloc(AVPicture *picture, int pix_fmt, int width, int height)</p><p>163 {</p><p>164 unsigned int size;</p><p>165 void *ptr;</p><p>166<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>调用函数计算图像大小。</p><p>167 size = avpicture_get_size(pix_fmt, width, height);</p><p>168 if (size &lt; 0)</p><p>169 goto fail;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>调用函数分配图像缓存。</p><p>170 ptr = av_malloc(size);</p><p>171 if (!ptr)</p><p>172 goto fail;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>填充 AVPicture 结构。</p><p>173 avpicture_fill(picture, ptr, pix_fmt, width, height);</p><p>174 return 0;</p><p>175 fail:</p><p>176 memset(picture, 0, sizeof(AVPicture));</p><p>177 return - 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>178 }</p><p>179<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>释放 AVPicture 分配的内存，因为内存首地址在 picture->data[0]中，所以可以简单的释放。</p><p>180 void avpicture_free(AVPicture *picture)</p><p>181 {</p><p>182 av_free(picture->data[0]);</p><p>183 }</p><p>184<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>计算各种图像格式平均每个像素占用的 bit 位数。</p><p>185 static int avg_bits_per_pixel(int pix_fmt)</p><p>186 {</p><p>187 int bits;</p><p>188 const PixFmtInfo *pf;</p><p>189</p><p>190 pf = &pix_fmt_info[pix_fmt];</p><p>191 switch (pf->pixel_type)</p><p>192 {</p><p>193 case FF_PIXEL_PACKED:</p><p>194 switch (pix_fmt)</p><p>195 {</p><p>196 case PIX_FMT_YUV422:</p><p>197 case PIX_FMT_UYVY422:</p><p>198 case PIX_FMT_RGB565:</p><p>199 case PIX_FMT_RGB555:</p><p>200 bits = 16;</p><p>201 break;</p><p>202 case PIX_FMT_UYVY411:</p><p>203 bits = 12;</p><p>204 break;</p><p>205 default:</p><p>206 bits = pf->depth *pf->nb_channels;</p><p>207 break;</p><p>208 }</p><p>209 break;</p><p>210 case FF_PIXEL_PLANAR:</p><p>211 if (pf->x_chroma_shift == 0 && pf->y_chroma_shift == 0)</p><p>212 {</p><p>213 bits = pf->depth *pf->nb_channels;</p><p>214 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>215 else</p><p>216 {</p><p>217 bits = pf->depth + ((2 *pf->depth) >> (pf->x_chroma_shift + pf->y_chroma_shift));</p><p>218 }</p><p>219 break;</p><p>220 case FF_PIXEL_PALETTE:</p><p>221 bits = 8;</p><p>222 break;</p><p>223 default:</p><p>224 bits = - 1;</p><p>225 break;</p><p>226 }</p><p>227 return bits;</p><p>228 }</p><p>229</p><p>230 ////////////////////////////</p><p>231<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>图像数据平面拷贝，由于宽度可能有差别，只能一行一行的拷贝。</p><p>232 void ff_img_copy_plane(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>233 {</p><p>234 if ((!dst) || (!src))</p><p>235 return ;</p><p>236 for (; height > 0; height--)</p><p>237 {</p><p>238 memcpy(dst, src, width);</p><p>239 dst += dst_wrap;</p><p>240 src += src_wrap;</p><p>241 }</p><p>242 }</p><p>243<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>各种图像格式的图像数据拷贝。</p><p>244 void img_copy(AVPicture *dst, const AVPicture *src, int pix_fmt, int width, int height)</p><p>245 {</p><p>246 int bwidth, bits, i;</p><p>247 PixFmtInfo *pf = &pix_fmt_info[pix_fmt];</p><p>248</p><p>249 pf = &pix_fmt_info[pix_fmt];</p><p>250 switch (pf->pixel_type)</p><p>251 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>252 case FF_PIXEL_PACKED:</p><p>253 switch (pix_fmt)</p><p>254 {</p><p>255 case PIX_FMT_YUV422:</p><p>256 case PIX_FMT_UYVY422:</p><p>257 case PIX_FMT_RGB565:</p><p>258 case PIX_FMT_RGB555:</p><p>259 bits = 16;</p><p>260 break;</p><p>261 case PIX_FMT_UYVY411:</p><p>262 bits = 12;</p><p>263 break;</p><p>264 default:</p><p>265 bits = pf->depth *pf->nb_channels;</p><p>266 break;</p><p>267 }</p><p>268 bwidth = (width *bits + 7) >> 3;</p><p>269 ff_img_copy_plane(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0], bwidth, height);</p><p>270 break;</p><p>271 case FF_PIXEL_PLANAR:</p><p>272 for (i = 0; i &lt; pf->nb_channels; i++)</p><p>273 {</p><p>274 int w, h;</p><p>275 w = width;</p><p>276 h = height;</p><p>277 if (i == 1 || i == 2)</p><p>278 {</p><p>279 w >>= pf->x_chroma_shift;</p><p>280 h >>= pf->y_chroma_shift;</p><p>281 }</p><p>282 bwidth = (w *pf->depth + 7) >> 3;</p><p>283 ff_img_copy_plane(dst->data[i], dst->linesize[i], src->data[i], src->linesize[i], bwidth, h);</p><p>284 }</p><p>285 break;</p><p>286 case FF_PIXEL_PALETTE:</p><p>287 ff_img_copy_plane(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0], width, height);</p><p>288 // copy the palette</p><p>289 ff_img_copy_plane(dst->data[1], dst->linesize[1], src->data[1], src->linesize[1], 4,</p><p>256);</p><p>290 break;</p><p>291 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>292 }</p><p>293</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt>本文件的后面部分请各位自行仔细分析。</p><p>294 static void yuv422_to_yuv420p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>295 {</p><p>296 const uint8_t *p, *p1;</p><p>297 uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>298 int w;</p><p>299</p><p>300 p1 = src->data[0];</p><p>301 lum1 = dst->data[0];</p><p>302 cb1 = dst->data[1];</p><p>303 cr1 = dst->data[2];</p><p>304</p><p>305 for (; height >= 1; height -= 2)</p><p>306 {</p><p>307 p = p1;</p><p>308 lum = lum1;</p><p>309 cb = cb1;</p><p>310 cr = cr1;</p><p>311 for (w = width; w >= 2; w -= 2)</p><p>312 {</p><p>313 lum[0] = p[0];</p><p>314 cb[0] = p[1];</p><p>315 lum[1] = p[2];</p><p>316 cr[0] = p[3];</p><p>317 p += 4;</p><p>318 lum += 2;</p><p>319 cb++;</p><p>320 cr++;</p><p>321 }</p><p>322 if (w)</p><p>323 {</p><p>324 lum[0] = p[0];</p><p>325 cb[0] = p[1];</p><p>326 cr[0] = p[3];</p><p>327 cb++;</p><p>328 cr++;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>329 }</p><p>330 p1 += src->linesize[0];</p><p>331 lum1 += dst->linesize[0];</p><p>332 if (height > 1)</p><p>333 {</p><p>334 p = p1;</p><p>335 lum = lum1;</p><p>336 for (w = width; w >= 2; w -= 2)</p><p>337 {</p><p>338 lum[0] = p[0];</p><p>339 lum[1] = p[2];</p><p>340 p += 4;</p><p>341 lum += 2;</p><p>342 }</p><p>343 if (w)</p><p>344 {</p><p>345 lum[0] = p[0];</p><p>346 }</p><p>347 p1 += src->linesize[0];</p><p>348 lum1 += dst->linesize[0];</p><p>349 }</p><p>350 cb1 += dst->linesize[1];</p><p>351 cr1 += dst->linesize[2];</p><p>352 }</p><p>353 }</p><p>354</p><p>355 static void uyvy422_to_yuv420p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>356 {</p><p>357 const uint8_t *p, *p1;</p><p>358 uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>359 int w;</p><p>360</p><p>361 p1 = src->data[0];</p><p>362</p><p>363 lum1 = dst->data[0];</p><p>364 cb1 = dst->data[1];</p><p>365 cr1 = dst->data[2];</p><p>366</p><p>367 for (; height >= 1; height -= 2)</p><p>368 {</p><p>369 p = p1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>370 lum = lum1;</p><p>371 cb = cb1;</p><p>372 cr = cr1;</p><p>373 for (w = width; w >= 2; w -= 2)</p><p>374 {</p><p>375 lum[0] = p[1];</p><p>376 cb[0] = p[0];</p><p>377 lum[1] = p[3];</p><p>378 cr[0] = p[2];</p><p>379 p += 4;</p><p>380 lum += 2;</p><p>381 cb++;</p><p>382 cr++;</p><p>383 }</p><p>384 if (w)</p><p>385 {</p><p>386 lum[0] = p[1];</p><p>387 cb[0] = p[0];</p><p>388 cr[0] = p[2];</p><p>389 cb++;</p><p>390 cr++;</p><p>391 }</p><p>392 p1 += src->linesize[0];</p><p>393 lum1 += dst->linesize[0];</p><p>394 if (height > 1)</p><p>395 {</p><p>396 p = p1;</p><p>397 lum = lum1;</p><p>398 for (w = width; w >= 2; w -= 2)</p><p>399 {</p><p>400 lum[0] = p[1];</p><p>401 lum[1] = p[3];</p><p>402 p += 4;</p><p>403 lum += 2;</p><p>404 }</p><p>405 if (w)</p><p>406 {</p><p>407 lum[0] = p[1];</p><p>408 }</p><p>409 p1 += src->linesize[0];</p><p>410 lum1 += dst->linesize[0];<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>411 }</p><p>412 cb1 += dst->linesize[1];</p><p>413 cr1 += dst->linesize[2];</p><p>414 }</p><p>415 }</p><p>416</p><p>417 static void uyvy422_to_yuv422p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>418 {</p><p>419 const uint8_t *p, *p1;</p><p>420 uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>421 int w;</p><p>422</p><p>423 p1 = src->data[0];</p><p>424 lum1 = dst->data[0];</p><p>425 cb1 = dst->data[1];</p><p>426 cr1 = dst->data[2];</p><p>427 for (; height > 0; height--)</p><p>428 {</p><p>429 p = p1;</p><p>430 lum = lum1;</p><p>431 cb = cb1;</p><p>432 cr = cr1;</p><p>433 for (w = width; w >= 2; w -= 2)</p><p>434 {</p><p>435 lum[0] = p[1];</p><p>436 cb[0] = p[0];</p><p>437 lum[1] = p[3];</p><p>438 cr[0] = p[2];</p><p>439 p += 4;</p><p>440 lum += 2;</p><p>441 cb++;</p><p>442 cr++;</p><p>443 }</p><p>444 p1 += src->linesize[0];</p><p>445 lum1 += dst->linesize[0];</p><p>446 cb1 += dst->linesize[1];</p><p>447 cr1 += dst->linesize[2];</p><p>448 }</p><p>449 }</p><p>450</p><p>451 static void yuv422_to_yuv422p(AVPicture *dst, const AVPicture *src, int width, int height)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>452 {</p><p>453 const uint8_t *p, *p1;</p><p>454 uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>455 int w;</p><p>456</p><p>457 p1 = src->data[0];</p><p>458 lum1 = dst->data[0];</p><p>459 cb1 = dst->data[1];</p><p>460 cr1 = dst->data[2];</p><p>461 for (; height > 0; height--)</p><p>462 {</p><p>463 p = p1;</p><p>464 lum = lum1;</p><p>465 cb = cb1;</p><p>466 cr = cr1;</p><p>467 for (w = width; w >= 2; w -= 2)</p><p>468 {</p><p>469 lum[0] = p[0];</p><p>470 cb[0] = p[1];</p><p>471 lum[1] = p[2];</p><p>472 cr[0] = p[3];</p><p>473 p += 4;</p><p>474 lum += 2;</p><p>475 cb++;</p><p>476 cr++;</p><p>477 }</p><p>478 p1 += src->linesize[0];</p><p>479 lum1 += dst->linesize[0];</p><p>480 cb1 += dst->linesize[1];</p><p>481 cr1 += dst->linesize[2];</p><p>482 }</p><p>483 }</p><p>484</p><p>485 static void yuv422p_to_yuv422(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>486 {</p><table><thead><tr><th>487</th><th>uint8_t *p, *p1;</th><th></th></tr></thead><tbody><tr><td>488</td><td>const uint8_t *lum, *cr, *cb, *lum1, *cr1,</td><td>*cb1;</td></tr><tr><td>489</td><td>int w;</td><td></td></tr><tr><td>490</td><td></td><td></td></tr><tr><td>491</td><td>p1 = dst->data[0];</td><td></td></tr><tr><td>492</td><td>lum1 = src->data[0];</td><td></td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>493 cb1 = src->data[1];</p><p>494 cr1 = src->data[2];</p><p>495 for (; height > 0; height--)</p><p>496 {</p><p>497 p = p1;</p><p>498 lum = lum1;</p><p>499 cb = cb1;</p><p>500 cr = cr1;</p><p>501 for (w = width; w >= 2; w -= 2)</p><p>502 {</p><p>503 p[0] = lum[0];</p><p>504 p[1] = cb[0];</p><p>505 p[2] = lum[1];</p><p>506 p[3] = cr[0];</p><p>507 p += 4;</p><p>508 lum += 2;</p><p>509 cb++;</p><p>510 cr++;</p><p>511 }</p><p>512 p1 += dst->linesize[0];</p><p>513 lum1 += src->linesize[0];</p><p>514 cb1 += src->linesize[1];</p><p>515 cr1 += src->linesize[2];</p><p>516 }</p><p>517 }</p><p>518</p><p>519 static void yuv422p_to_uyvy422(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>520 {</p><p>521 uint8_t *p, *p1;</p><p>522 const uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>523 int w;</p><p>524</p><p>525 p1 = dst->data[0];</p><p>526 lum1 = src->data[0];</p><p>527 cb1 = src->data[1];</p><p>528 cr1 = src->data[2];</p><p>529 for (; height > 0; height--)</p><p>530 {</p><p>531 p = p1;</p><p>532 lum = lum1;</p><p>533 cb = cb1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>534 cr = cr1;</p><p>535 for (w = width; w >= 2; w -= 2)</p><p>536 {</p><p>537 p[1] = lum[0];</p><p>538 p[0] = cb[0];</p><p>539 p[3] = lum[1];</p><p>540 p[2] = cr[0];</p><p>541 p += 4;</p><p>542 lum += 2;</p><p>543 cb++;</p><p>544 cr++;</p><p>545 }</p><p>546 p1 += dst->linesize[0];</p><p>547 lum1 += src->linesize[0];</p><p>548 cb1 += src->linesize[1];</p><p>549 cr1 += src->linesize[2];</p><p>550 }</p><p>551 }</p><p>552</p><p>553 static void uyvy411_to_yuv411p(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>554 {</p><p>555 const uint8_t *p, *p1;</p><p>556 uint8_t *lum, *cr, *cb, *lum1, *cr1, *cb1;</p><p>557 int w;</p><p>558</p><p>559 p1 = src->data[0];</p><p>560 lum1 = dst->data[0];</p><p>561 cb1 = dst->data[1];</p><p>562 cr1 = dst->data[2];</p><p>563 for (; height > 0; height--)</p><p>564 {</p><p>565 p = p1;</p><p>566 lum = lum1;</p><p>567 cb = cb1;</p><p>568 cr = cr1;</p><p>569 for (w = width; w >= 4; w -= 4)</p><p>570 {</p><p>571 cb[0] = p[0];</p><p>572 lum[0] = p[1];</p><p>573 lum[1] = p[2];</p><p>574 cr[0] = p[3];<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>575 lum[2] = p[4];</p><p>576 lum[3] = p[5];</p><p>577 p += 6;</p><p>578 lum += 4;</p><p>579 cb++;</p><p>580 cr++;</p><p>581 }</p><p>582 p1 += src->linesize[0];</p><p>583 lum1 += dst->linesize[0];</p><p>584 cb1 += dst->linesize[1];</p><p>585 cr1 += dst->linesize[2];</p><p>586 }</p><p>587 }</p><p>588</p><p>589 static void yuv420p_to_yuv422(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>590 {</p><p>591 int w, h;</p><p>592 uint8_t *line1, *line2, *linesrc = dst->data[0];</p><p>593 uint8_t *lum1, *lum2, *lumsrc = src->data[0];</p><p>594 uint8_t *cb1, *cb2 = src->data[1];</p><p>595 uint8_t *cr1, *cr2 = src->data[2];</p><p>596</p><p>597 for (h = height / 2; h--;)</p><p>598 {</p><p>599 line1 = linesrc;</p><p>600 line2 = linesrc + dst->linesize[0];</p><p>601</p><p>602 lum1 = lumsrc;</p><p>603 lum2 = lumsrc + src->linesize[0];</p><p>604</p><p>605 cb1 = cb2;</p><p>606 cr1 = cr2;</p><p>607</p><p>608 for (w = width / 2; w--;)</p><p>609 {</p><p>610 *line1++ = *lum1++;</p><p>611 *line2++ = *lum2++;</p><p>612 *line1++ = *line2++ = *cb1++;</p><p>613 *line1++ = *lum1++;</p><p>614 *line2++ = *lum2++;</p><p>615 *line1++ = *line2++ = *cr1++;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>616 }</p><p>617</p><p>618 linesrc += dst->linesize[0] *2;</p><p>619 lumsrc += src->linesize[0] *2;</p><p>620 cb2 += src->linesize[1];</p><p>621 cr2 += src->linesize[2];</p><p>622 }</p><p>623 }</p><p>624</p><p>625 static void yuv420p_to_uyvy422(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>626 {</p><p>627 int w, h;</p><p>628 uint8_t *line1, *line2, *linesrc = dst->data[0];</p><p>629 uint8_t *lum1, *lum2, *lumsrc = src->data[0];</p><p>630 uint8_t *cb1, *cb2 = src->data[1];</p><p>631 uint8_t *cr1, *cr2 = src->data[2];</p><p>632</p><p>633 for (h = height / 2; h--;)</p><p>634 {</p><p>635 line1 = linesrc;</p><p>636 line2 = linesrc + dst->linesize[0];</p><p>637</p><p>638 lum1 = lumsrc;</p><p>639 lum2 = lumsrc + src->linesize[0];</p><p>640</p><p>641 cb1 = cb2;</p><p>642 cr1 = cr2;</p><p>643</p><p>644 for (w = width / 2; w--;)</p><p>645 {</p><p>646 *line1++ = *line2++ = *cb1++;</p><p>647 *line1++ = *lum1++;</p><p>648 *line2++ = *lum2++;</p><p>649 *line1++ = *line2++ = *cr1++;</p><p>650 *line1++ = *lum1++;</p><p>651 *line2++ = *lum2++;</p><p>652 }</p><p>653</p><p>654 linesrc += dst->linesize[0] *2;</p><p>655 lumsrc += src->linesize[0] *2;</p><p>656 cb2 += src->linesize[1];<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>657 cr2 += src->linesize[2];</p><p>658 }</p><p>659 }</p><p>660</p><p>661 #define SCALEBITS 10</p><p>662 #define ONE_HALF (1 &lt;&lt; (SCALEBITS - 1))</p><p>663 #define FIX(x) ((int) ((x) * (1&lt;&lt;SCALEBITS) + 0.5))</p><p>664</p><p>665 #define YUV_TO_RGB1_CCIR(cb1, cr1)\</p><p>666 {\</p><p>667 cb = (cb1) - 128;\</p><p>668 cr = (cr1) - 128;\</p><p>669 r_add = FIX(1.40200*255.0/224.0) * cr + ONE_HALF;\</p><p>670 g_add = - FIX(0.34414*255.0/224.0) * cb - FIX(0.71414*255.0/224.0) * cr + \</p><p>671 ONE_HALF;\</p><p>672 b_add = FIX(1.77200*255.0/224.0) * cb + ONE_HALF;\</p><p>673 }</p><p>674</p><p>675 #define YUV_TO_RGB2_CCIR(r, g, b, y1)\</p><p>676 {\</p><p>677 y = ((y1) - 16) * FIX(255.0/219.0);\</p><p>678 r = cm[(y + r_add) >> SCALEBITS];\</p><p>679 g = cm[(y + g_add) >> SCALEBITS];\</p><p>680 b = cm[(y + b_add) >> SCALEBITS];\</p><p>681 }</p><p>682</p><p>683 #define YUV_TO_RGB1(cb1, cr1)\</p><p>684 {\</p><p>685 cb = (cb1) - 128;\</p><p>686 cr = (cr1) - 128;\</p><p>687 r_add = FIX(1.40200) * cr + ONE_HALF;\</p><p>688 g_add = - FIX(0.34414) * cb - FIX(0.71414) * cr + ONE_HALF;\</p><p>689 b_add = FIX(1.77200) * cb + ONE_HALF;\</p><p>690 }</p><p>691</p><p>692 #define YUV_TO_RGB2(r, g, b, y1)\</p><p>693 {\</p><p>694 y = (y1) &lt;&lt; SCALEBITS;\</p><p>695 r = cm[(y + r_add) >> SCALEBITS];\</p><p>696 g = cm[(y + g_add) >> SCALEBITS];\</p><p>697 b = cm[(y + b_add) >> SCALEBITS];!<a href=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png></a></p><p>698 }</p><p>699</p><p>700 #define Y_CCIR_TO_JPEG(y)\</p><p>701 cm[((y) * FIX(255.0/219.0) + (ONE_HALF - 16 * FIX(255.0/219.0))) >> SCALEBITS]</p><p>702</p><p>703 #define Y_JPEG_TO_CCIR(y)\</p><p>704 (((y) * FIX(219.0/255.0) + (ONE_HALF + (16 &lt;&lt; SCALEBITS))) >> SCALEBITS)</p><p>705</p><p>706 #define C_CCIR_TO_JPEG(y)\</p><p>707 cm[(((y) - 128) * FIX(127.0/112.0) + (ONE_HALF + (128 &lt;&lt; SCALEBITS))) >> SCALEBITS]</p><p>708</p><p>709 /* NOTE: the clamp is really necessary! */</p><p>710 static inline int C_JPEG_TO_CCIR(int y)</p><p>711 {</p><p>712 y = (((y - 128) *FIX(112.0 / 127.0) + (ONE_HALF + (128 &lt;&lt; SCALEBITS))) >> SCALEBITS);</p><p>713 if (y &lt; 16)</p><p>714 y = 16;</p><p>715 return y;</p><p>716 }</p><p>717</p><p>718 #define RGB_TO_Y(r, g, b) \</p><p>719 ((FIX(0.29900) * (r) + FIX(0.58700) * (g) + \</p><p>720 FIX(0.11400) * (b) + ONE_HALF) >> SCALEBITS)</p><p>721</p><p>722 #define RGB_TO_U(r1, g1, b1, shift)\</p><p>723 (((- FIX(0.16874) * r1 - FIX(0.33126) * g1 + \</p><p>724 FIX(0.50000) * b1 + (ONE_HALF &lt;&lt; shift) - 1) >> (SCALEBITS + shift)) + 128)</p><p>725</p><p>726 #define RGB_TO_V(r1, g1, b1, shift)\</p><p>727 (((FIX(0.50000) * r1 - FIX(0.41869) * g1 - \</p><p>728 FIX(0.08131) * b1 + (ONE_HALF &lt;&lt; shift) - 1) >> (SCALEBITS + shift)) + 128)</p><p>729</p><p>730 #define RGB_TO_Y_CCIR(r, g, b) \</p><p>731 ((FIX(0.29900*219.0/255.0) * (r) + FIX(0.58700*219.0/255.0) * (g) + \</p><p>732 FIX(0.11400*219.0/255.0) * (b) + (ONE_HALF + (16 &lt;&lt; SCALEBITS))) >> SCALEBITS)</p><p>733</p><p>734 #define RGB_TO_U_CCIR(r1, g1, b1, shift)\</p><p>735 (((- FIX(0.16874*224.0/255.0) * r1 - FIX(0.33126*224.0/255.0) * g1 + \</p><p>736 FIX(0.50000*224.0/255.0) * b1 + (ONE_HALF &lt;&lt; shift) - 1) >> (SCALEBITS + shift)) + 128)</p><p>737</p><p>738 #define RGB_TO_V_CCIR(r1, g1, b1, shift)!<a href=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png></a></p><p>739 (((FIX(0.50000*224.0/255.0) * r1 - FIX(0.41869*224.0/255.0) * g1 - \</p><p>740 FIX(0.08131*224.0/255.0) * b1 + (ONE_HALF &lt;&lt; shift) - 1) >> (SCALEBITS + shift)) + 128)</p><p>741</p><p>742 static uint8_t y_ccir_to_jpeg[256];</p><p>743 static uint8_t y_jpeg_to_ccir[256];</p><p>744 static uint8_t c_ccir_to_jpeg[256];</p><p>745 static uint8_t c_jpeg_to_ccir[256];</p><p>746</p><p>747 /* apply to each pixel the given table */</p><p>748 static void img_apply_table(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap,</p><p>749 int width, int height, const uint8_t *table1)</p><p>750 {</p><p>751 int n;</p><p>752 const uint8_t *s;</p><p>753 uint8_t *d;</p><p>754 const uint8_t *table;</p><p>755</p><p>756 table = table1;</p><p>757 for (; height > 0; height--)</p><p>758 {</p><p>759 s = src;</p><p>760 d = dst;</p><p>761 n = width;</p><p>762 while (n >= 4)</p><p>763 {</p><p>764 d[0] = table[s[0]];</p><p>765 d[1] = table[s[1]];</p><p>766 d[2] = table[s[2]];</p><p>767 d[3] = table[s[3]];</p><p>768 d += 4;</p><p>769 s += 4;</p><p>770 n -= 4;</p><p>771 }</p><p>772 while (n > 0)</p><p>773 {</p><p>774 d[0] = table[s[0]];</p><p>775 d++;</p><p>776 s++;</p><p>777 n--;</p><p>778 }</p><p>779 dst += dst_wrap;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>780 src += src_wrap;</p><p>781 }</p><p>782 }</p><p>783</p><p>784 /* XXX: use generic filter ? */</p><p>785 /* XXX: in most cases, the sampling position is incorrect */</p><p>786</p><p>787 /* 4x1 -> 1x1 */</p><p>788 static void shrink41(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>789 {</p><p>790 int w;</p><p>791 const uint8_t *s;</p><p>792 uint8_t *d;</p><p>793</p><p>794 for (; height > 0; height--)</p><p>795 {</p><p>796 s = src;</p><p>797 d = dst;</p><p>798 for (w = width; w > 0; w--)</p><p>799 {</p><p>800 d[0] = (s[0] + s[1] + s[2] + s[3] + 2) >> 2;</p><p>801 s += 4;</p><p>802 d++;</p><p>803 }</p><p>804 src += src_wrap;</p><p>805 dst += dst_wrap;</p><p>806 }</p><p>807 }</p><p>808</p><p>809 /* 2x1 -> 1x1 */</p><p>810 static void shrink21(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>811 {</p><p>812 int w;</p><p>813 const uint8_t *s;</p><p>814 uint8_t *d;</p><p>815</p><p>816 for (; height > 0; height--)</p><p>817 {</p><p>818 s = src;</p><p>819 d = dst;</p><p>820 for (w = width; w > 0; w--)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>821 {</p><p>822 d[0] = (s[0] + s[1]) >> 1;</p><p>823 s += 2;</p><p>824 d++;</p><p>825 }</p><p>826 src += src_wrap;</p><p>827 dst += dst_wrap;</p><p>828 }</p><p>829 }</p><p>830</p><p>831 /* 1x2 -> 1x1 */</p><p>832 static void shrink12(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>833 {</p><p>834 int w;</p><p>835 uint8_t *d;</p><p>836 const uint8_t *s1, *s2;</p><p>837</p><p>838 for (; height > 0; height--)</p><p>839 {</p><p>840 s1 = src;</p><p>841 s2 = s1 + src_wrap;</p><p>842 d = dst;</p><p>843 for (w = width; w >= 4; w -= 4)</p><p>844 {</p><p>845 d[0] = (s1[0] + s2[0]) >> 1;</p><p>846 d[1] = (s1[1] + s2[1]) >> 1;</p><p>847 d[2] = (s1[2] + s2[2]) >> 1;</p><p>848 d[3] = (s1[3] + s2[3]) >> 1;</p><p>849 s1 += 4;</p><p>850 s2 += 4;</p><p>851 d += 4;</p><p>852 }</p><p>853 for (; w > 0; w--)</p><p>854 {</p><p>855 d[0] = (s1[0] + s2[0]) >> 1;</p><p>856 s1++;</p><p>857 s2++;</p><p>858 d++;</p><p>859 }</p><p>860 src += 2 * src_wrap;</p><p>861 dst += dst_wrap;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>862 }</p><p>863 }</p><p>864</p><p>865 /* 2x2 -> 1x1 */</p><p>866 void ff_shrink22(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>867 {</p><p>868 int w;</p><p>869 const uint8_t *s1, *s2;</p><p>870 uint8_t *d;</p><p>871</p><p>872 for (; height > 0; height--)</p><p>873 {</p><p>874 s1 = src;</p><p>875 s2 = s1 + src_wrap;</p><p>876 d = dst;</p><p>877 for (w = width; w >= 4; w -= 4)</p><p>878 {</p><p>879 d[0] = (s1[0] + s1[1] + s2[0] + s2[1] + 2) >> 2;</p><p>880 d[1] = (s1[2] + s1[3] + s2[2] + s2[3] + 2) >> 2;</p><p>881 d[2] = (s1[4] + s1[5] + s2[4] + s2[5] + 2) >> 2;</p><p>882 d[3] = (s1[6] + s1[7] + s2[6] + s2[7] + 2) >> 2;</p><p>883 s1 += 8;</p><p>884 s2 += 8;</p><p>885 d += 4;</p><p>886 }</p><p>887 for (; w > 0; w--)</p><p>888 {</p><p>889 d[0] = (s1[0] + s1[1] + s2[0] + s2[1] + 2) >> 2;</p><p>890 s1 += 2;</p><p>891 s2 += 2;</p><p>892 d++;</p><p>893 }</p><p>894 src += 2 * src_wrap;</p><p>895 dst += dst_wrap;</p><p>896 }</p><p>897 }</p><p>898</p><p>899 /* 4x4 -> 1x1 */</p><p>900 void ff_shrink44(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>901 {</p><p>902 int w;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>903 const uint8_t *s1, *s2, *s3, *s4;</p><p>904 uint8_t *d;</p><p>905</p><p>906 for (; height > 0; height--)</p><p>907 {</p><p>908 s1 = src;</p><p>909 s2 = s1 + src_wrap;</p><p>910 s3 = s2 + src_wrap;</p><p>911 s4 = s3 + src_wrap;</p><p>912 d = dst;</p><p>913 for (w = width; w > 0; w--)</p><p>914 {</p><p>915 d[0] = (s1[0] + s1[1] + s1[2] + s1[3] + s2[0] + s2[1] + s2[2] + s2[3] +</p><p>916 s3[0] + s3[1] + s3[2] + s3[3] + s4[0] + s4[1] + s4[2] + s4[3] + 8) >> 4;</p><p>917 s1 += 4;</p><p>918 s2 += 4;</p><p>919 s3 += 4;</p><p>920 s4 += 4;</p><p>921 d++;</p><p>922 }</p><p>923 src += 4 * src_wrap;</p><p>924 dst += dst_wrap;</p><p>925 }</p><p>926 }</p><p>927</p><p>928 static void grow21_line(uint8_t *dst, const uint8_t *src, int width)</p><p>929 {</p><p>930 int w;</p><p>931 const uint8_t *s1;</p><p>932 uint8_t *d;</p><p>933</p><p>934 s1 = src;</p><p>935 d = dst;</p><p>936 for (w = width; w >= 4; w -= 4)</p><p>937 {</p><p>938 d[1] = d[0] = s1[0];</p><p>939 d[3] = d[2] = s1[1];</p><p>940 s1 += 2;</p><p>941 d += 4;</p><p>942 }</p><p>943 for (; w >= 2; w -= 2)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>944 {</p><p>945 d[1] = d[0] = s1[0];</p><p>946 s1++;</p><p>947 d += 2;</p><p>948 }</p><p>949 /* only needed if width is not a multiple of two */</p><p>950 /* XXX: veryfy that */</p><p>951 if (w)</p><p>952 {</p><p>953 d[0] = s1[0];</p><p>954 }</p><p>955 }</p><p>956</p><p>957 static void grow41_line(uint8_t *dst, const uint8_t *src, int width)</p><p>958 {</p><p>959 int w, v;</p><p>960 const uint8_t *s1;</p><p>961 uint8_t *d;</p><p>962</p><p>963 s1 = src;</p><p>964 d = dst;</p><p>965 for (w = width; w >= 4; w -= 4)</p><p>966 {</p><p>967 v = s1[0];</p><p>968 d[0] = v;</p><p>969 d[1] = v;</p><p>970 d[2] = v;</p><p>971 d[3] = v;</p><p>972 s1++;</p><p>973 d += 4;</p><p>974 }</p><p>975 }</p><p>976</p><p>977 /* 1x1 -> 2x1 */</p><p>978 static void grow21(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>979 {</p><p>980 for (; height > 0; height--)</p><p>981 {</p><p>982 grow21_line(dst, src, width);</p><p>983 src += src_wrap;</p><p>984 dst += dst_wrap;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>985 }</p><p>986 }</p><p>987</p><p>988 /* 1x1 -> 2x2 */</p><p>989 static void grow22(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>990 {</p><p>991 for (; height > 0; height--)</p><p>992 {</p><p>993 grow21_line(dst, src, width);</p><p>994 if (height % 2)</p><p>995 src += src_wrap;</p><p>996 dst += dst_wrap;</p><p>997 }</p><p>998 }</p><p>999</p><p>1000 /* 1x1 -> 4x1 */</p><p>1001 static void grow41(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>1002 {</p><p>1003 for (; height > 0; height--)</p><p>1004 {</p><p>1005 grow41_line(dst, src, width);</p><p>1006 src += src_wrap;</p><p>1007 dst += dst_wrap;</p><p>1008 }</p><p>1009 }</p><p>1010</p><p>1011 /* 1x1 -> 4x4 */</p><p>1012 static void grow44(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>1013 {</p><p>1014 for (; height > 0; height--)</p><p>1015 {</p><p>1016 grow41_line(dst, src, width);</p><p>1017 if ((height &3) == 1)</p><p>1018 src += src_wrap;</p><p>1019 dst += dst_wrap;</p><p>1020 }</p><p>1021 }</p><p>1022</p><p>1023 /* 1x2 -> 2x1 */</p><p>1024 static void conv411(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap, int width, int height)</p><p>1025 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1026 int w, c;</p><p>1027 const uint8_t *s1, *s2;</p><p>1028 uint8_t *d;</p><p>1029</p><p>1030 width >>= 1;</p><p>1031</p><p>1032 for (; height > 0; height--)</p><p>1033 {</p><p>1034 s1 = src;</p><p>1035 s2 = src + src_wrap;</p><p>1036 d = dst;</p><p>1037 for (w = width; w > 0; w--)</p><p>1038 {</p><p>1039 c = (s1[0] + s2[0]) >> 1;</p><p>1040 d[0] = c;</p><p>1041 d[1] = c;</p><p>1042 s1++;</p><p>1043 s2++;</p><p>1044 d += 2;</p><p>1045 }</p><p>1046 src += src_wrap * 2;</p><p>1047 dst += dst_wrap;</p><p>1048 }</p><p>1049 }</p><p>1050</p><p>1051 /* XXX: add jpeg quantize code */</p><p>1052</p><p>1053 #define TRANSP_INDEX (6*6*6)</p><p>1054</p><p>1055 /* this is maybe slow, but allows for extensions */</p><p>1056 static inline unsigned char gif_clut_index(uint8_t r, uint8_t g, uint8_t b)</p><p>1057 {</p><p>1058 return ((((r) / 47) % 6) *6 * 6+(((g) / 47) % 6) *6+(((b) / 47) % 6));</p><p>1059 }</p><p>1060</p><p>1061 static void build_rgb_palette(uint8_t *palette, int has_alpha)</p><p>1062 {</p><p>1063 uint32_t *pal;</p><p>1064 static const uint8_t pal_value[6] = {0x00, 0x33, 0x66, 0x99, 0xcc, 0xff };</p><p>1065 int i, r, g, b;</p><p>1066<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1067 pal = (uint32_t*)palette;</p><p>1068 i = 0;</p><p>1069 for (r = 0; r &lt; 6; r++)</p><p>1070 {</p><p>1071 for (g = 0; g &lt; 6; g++)</p><p>1072 {</p><p>1073 for (b = 0; b &lt; 6; b++)</p><p>1074 {</p><p>1075 pal[i++] = (0xff &lt;&lt; 24) | (pal_value[r] &lt;&lt; 16) | (pal_value[g] &lt;&lt; 8) | pal_value[b];</p><p>1076 }</p><p>1077 }</p><p>1078 }</p><p>1079 if (has_alpha)</p><p>1080 pal[i++] = 0;</p><p>1081 while (i &lt; 256)</p><p>1082 pal[i++] = 0xff000000;</p><p>1083 }</p><p>1084</p><p>1085 /* copy bit n to bits 0 ... n - 1 */</p><p>1086 static inline unsigned int bitcopy_n(unsigned int a, int n)</p><p>1087 {</p><p>1088 int mask;</p><p>1089 mask = (1 &lt;&lt; n) - 1;</p><p>1090 return (a &(0xff &~mask)) | (( - ((a >> n) &1)) &mask);</p><p>1091 }</p><p>1092</p><p>1093 /* rgb555 handling */</p><p>1094</p><p>1095 #define RGB_NAME rgb555</p><p>1096</p><p>1097 #define RGB_IN(r, g, b, s)\</p><p>1098 {\</p><p>1099 unsigned int v = ((const uint16_t *)(s))[0];\</p><p>1100 r = bitcopy_n(v >> (10 - 3), 3);\</p><p>1101 g = bitcopy_n(v >> (5 - 3), 3);\</p><p>1102 b = bitcopy_n(v &lt;&lt; 3, 3);\</p><p>1103 }</p><p>1104</p><p>1105 #define RGBA_IN(r, g, b, a, s)\</p><p>1106 {\</p><p>1107 unsigned int v = ((const uint16_t *)(s))[0];!<a href=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png></a></p><p>1108 r = bitcopy_n(v >> (10 - 3), 3);\</p><p>1109 g = bitcopy_n(v >> (5 - 3), 3);\</p><p>1110 b = bitcopy_n(v &lt;&lt; 3, 3);\</p><p>1111 a = (-(v >> 15)) & 0xff;\</p><p>1112 }</p><p>1113</p><p>1114 #define RGBA_OUT(d, r, g, b, a)\</p><p>1115 {\</p><p>1116 ((uint16_t *)(d))[0] = ((r >> 3) &lt;&lt; 10) | ((g >> 3) &lt;&lt; 5) | (b >> 3) | \</p><p>1117 ((a &lt;&lt; 8) & 0x8000);\</p><p>1118 }</p><p>1119</p><p>1120 #define BPP 2</p><p>1121</p><p>1122 #include "imgconvert_template.h"</p><p>1123</p><p>1124 /* rgb565 handling */</p><p>1125</p><p>1126 #define RGB_NAME rgb565</p><p>1127</p><p>1128 #define RGB_IN(r, g, b, s)\</p><p>1129 {\</p><p>1130 unsigned int v = ((const uint16_t *)(s))[0];\</p><p>1131 r = bitcopy_n(v >> (11 - 3), 3);\</p><p>1132 g = bitcopy_n(v >> (5 - 2), 2);\</p><p>1133 b = bitcopy_n(v &lt;&lt; 3, 3);\</p><p>1134 }</p><p>1135</p><p>1136 #define RGB_OUT(d, r, g, b)\</p><p>1137 {\</p><p>1138 ((uint16_t *)(d))[0] = ((r >> 3) &lt;&lt; 11) | ((g >> 2) &lt;&lt; 5) | (b >> 3);\</p><p>1139 }</p><p>1140</p><p>1141 #define BPP 2</p><p>1142</p><p>1143 #include "imgconvert_template.h"</p><p>1144</p><p>1145 /* bgr24 handling */</p><p>1146</p><p>1147 #define RGB_NAME bgr24</p><p>1148<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1149 #define RGB_IN(r, g, b, s)\</p><p>1150 {\</p><p>1151 b = (s)[0];\</p><p>1152 g = (s)[1];\</p><p>1153 r = (s)[2];\</p><p>1154 }</p><p>1155</p><p>1156 #define RGB_OUT(d, r, g, b)\</p><p>1157 {\</p><p>1158 (d)[0] = b;\</p><p>1159 (d)[1] = g;\</p><p>1160 (d)[2] = r;\</p><p>1161 }</p><p>1162</p><p>1163 #define BPP 3</p><p>1164</p><p>1165 #include "imgconvert_template.h"</p><p>1166</p><p>1167 #undef RGB_IN</p><p>1168 #undef RGB_OUT</p><p>1169 #undef BPP</p><p>1170</p><p>1171 /* rgb24 handling */</p><p>1172</p><p>1173 #define RGB_NAME rgb24</p><p>1174 #define FMT_RGB24</p><p>1175</p><p>1176 #define RGB_IN(r, g, b, s)\</p><p>1177 {\</p><p>1178 r = (s)[0];\</p><p>1179 g = (s)[1];\</p><p>1180 b = (s)[2];\</p><p>1181 }</p><p>1182</p><p>1183 #define RGB_OUT(d, r, g, b)\</p><p>1184 {\</p><p>1185 (d)[0] = r;\</p><p>1186 (d)[1] = g;\</p><p>1187 (d)[2] = b;\</p><p>1188 }</p><p>1189<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1190 #define BPP 3</p><p>1191</p><p>1192 #include "imgconvert_template.h"</p><p>1193</p><p>1194 /* rgba32 handling */</p><p>1195</p><p>1196 #define RGB_NAME rgba32</p><p>1197 #define FMT_RGBA32</p><p>1198</p><p>1199 #define RGB_IN(r, g, b, s)\</p><p>1200 {\</p><p>1201 unsigned int v = ((const uint32_t *)(s))[0];\</p><p>1202 r = (v >> 16) & 0xff;\</p><p>1203 g = (v >> 8) & 0xff;\</p><p>1204 b = v & 0xff;\</p><p>1205 }</p><p>1206</p><p>1207 #define RGBA_IN(r, g, b, a, s)\</p><p>1208 {\</p><p>1209 unsigned int v = ((const uint32_t *)(s))[0];\</p><p>1210 a = (v >> 24) & 0xff;\</p><p>1211 r = (v >> 16) & 0xff;\</p><p>1212 g = (v >> 8) & 0xff;\</p><p>1213 b = v & 0xff;\</p><p>1214 }</p><p>1215</p><p>1216 #define RGBA_OUT(d, r, g, b, a)\</p><p>1217 {\</p><p>1218 ((uint32_t *)(d))[0] = (a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;\</p><p>1219 }</p><p>1220</p><p>1221 #define BPP 4</p><p>1222</p><p>1223 #include "imgconvert_template.h"</p><p>1224</p><p>1225 static void mono_to_gray(AVPicture *dst, const AVPicture *src, int width, int height, int xor_mask)</p><p>1226 {</p><p>1227 const unsigned char *p;</p><p>1228 unsigned char *q;</p><p>1229 int v, dst_wrap, src_wrap;</p><p>1230 int y, w;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1231</p><p>1232 p = src->data[0];</p><p>1233 src_wrap = src->linesize[0] - ((width + 7) >> 3);</p><p>1234</p><p>1235 q = dst->data[0];</p><p>1236 dst_wrap = dst->linesize[0] - width;</p><p>1237 for (y = 0; y &lt; height; y++)</p><p>1238 {</p><p>1239 w = width;</p><p>1240 while (w >= 8)</p><p>1241 {</p><p>1242 v = *p++ ^ xor_mask;</p><p>1243 q[0] = - (v >> 7);</p><p>1244 q[1] = - ((v >> 6) &1);</p><p>1245 q[2] = - ((v >> 5) &1);</p><p>1246 q[3] = - ((v >> 4) &1);</p><p>1247 q[4] = - ((v >> 3) &1);</p><p>1248 q[5] = - ((v >> 2) &1);</p><p>1249 q[6] = - ((v >> 1) &1);</p><p>1250 q[7] = - ((v >> 0) &1);</p><p>1251 w -= 8;</p><p>1252 q += 8;</p><p>1253 }</p><p>1254 if (w > 0)</p><p>1255 {</p><p>1256 v = *p++ ^ xor_mask;</p><p>1257 do</p><p>1258 {</p><p>1259 q[0] = - ((v >> 7) &1);</p><p>1260 q++;</p><p>1261 v &lt;&lt;= 1;</p><p>1262 }</p><p>1263 while (--w);</p><p>1264 }</p><p>1265 p += src_wrap;</p><p>1266 q += dst_wrap;</p><p>1267 }</p><p>1268 }</p><p>1269</p><p>1270 static void monowhite_to_gray(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>1271 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1272 mono_to_gray(dst, src, width, height, 0xff);</p><p>1273 }</p><p>1274</p><p>1275 static void monoblack_to_gray(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>1276 {</p><p>1277 mono_to_gray(dst, src, width, height, 0x00);</p><p>1278 }</p><p>1279</p><p>1280 static void gray_to_mono(AVPicture *dst, const AVPicture *src, int width, int height, int xor_mask)</p><p>1281 {</p><p>1282 int n;</p><p>1283 const uint8_t *s;</p><p>1284 uint8_t *d;</p><p>1285 int j, b, v, n1, src_wrap, dst_wrap, y;</p><p>1286</p><p>1287 s = src->data[0];</p><p>1288 src_wrap = src->linesize[0] - width;</p><p>1289</p><p>1290 d = dst->data[0];</p><p>1291 dst_wrap = dst->linesize[0] - ((width + 7) >> 3);</p><p>1292</p><p>1293 for (y = 0; y &lt; height; y++)</p><p>1294 {</p><p>1295 n = width;</p><p>1296 while (n >= 8)</p><p>1297 {</p><p>1298 v = 0;</p><p>1299 for (j = 0; j &lt; 8; j++)</p><p>1300 {</p><p>1301 b = s[0];</p><p>1302 s++;</p><p>1303 v = (v &lt;&lt; 1) | (b >> 7);</p><table><thead><tr><th>1304</th><th></th><th>}</th></tr></thead><tbody><tr><td>1305</td><td></td><td>d[0] = v ^ xor_mask;</td></tr><tr><td>1306</td><td></td><td>d++;</td></tr><tr><td>1307</td><td></td><td>n -= 8;</td></tr><tr><td>1308</td><td>}</td><td></td></tr><tr><td>1309 if (n > 0)</td><td></td><td></td></tr><tr><td>1310</td><td>{</td><td></td></tr><tr><td>1311</td><td></td><td>n1 = n;</td></tr><tr><td>1312</td><td></td><td>v = 0;</td></tr></tbody></table><table><thead><tr><th>1313</th><th></th><th></th><th>while (n > 0)</th></tr></thead><tbody><tr><td>1314</td><td></td><td></td><td>{</td></tr><tr><td>1315</td><td></td><td></td><td>b = s[0];</td></tr><tr><td>1316</td><td></td><td></td><td>s++;</td></tr><tr><td>1317</td><td></td><td></td><td>v = (v &lt;&lt; 1)</td></tr><tr><td>1318</td><td></td><td></td><td>n--;</td></tr><tr><td>1319</td><td></td><td></td><td>}</td></tr><tr><td>1320</td><td></td><td></td><td>d[0] = (v &lt;&lt; (8-(n1 &7))) ^ xor_mask;</td></tr><tr><td>1321</td><td></td><td></td><td>d++;</td></tr><tr><td>1322</td><td></td><td></td><td>}</td></tr><tr><td>1323</td><td></td><td></td><td>s += src_wrap;</td></tr><tr><td>1324</td><td></td><td></td><td>d += dst_wrap;</td></tr><tr><td>1325</td><td></td><td>}</td><td></td></tr><tr><td>1326</td><td>}</td><td></td><td></td></tr><tr><td>1327</td><td></td><td></td><td></td></tr><tr><td>1328 static void gray_to_monowhite(AVPicture *dst, const AVPicture *src, int width, int height)</td><td></td><td></td><td></td></tr></tbody></table><p>1329 {</p><p>1330 gray_to_mono(dst, src, width, height, 0xff);</p><p>1331 }</p><p>1332</p><p>1333 static void gray_to_monoblack(AVPicture *dst, const AVPicture *src, int width, int height)</p><p>1334 {</p><p>1335 gray_to_mono(dst, src, width, height, 0x00);</p><p>1336 }</p><p>1337</p><p>1338 typedef struct ConvertEntry</p><p>1339 {</p><p>1340 void(*convert)(AVPicture *dst, const AVPicture *src, int width, int height);</p><p>1341 } ConvertEntry;</p><p>1342</p><p>1343 /* Add each new convertion function in this table. In order to be able</p><p>1344 to convert from any format to any format, the following constraints must be satisfied:</p><p>1345</p><p>1346 - all FF_COLOR_RGB formats must convert to and from PIX_FMT_RGB24</p><p>1347</p><p>1348 - all FF_COLOR_GRAY formats must convert to and from PIX_FMT_GRAY8</p><p>1349</p><p>1350 - all FF_COLOR_RGB formats with alpha must convert to and from PIX_FMT_RGBA32</p><p>1351</p><p>1352 - PIX_FMT_YUV444P and PIX_FMT_YUVJ444P must convert to and from PIX_FMT_RGB24.</p><p>1353<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1354 - PIX_FMT_422 must convert to and from PIX_FMT_422P.</p><p>1355</p><p>1356 The other conversion functions are just optimisations for common cases.</p><p>1357 */</p><p>1358</p><p>1359 static ConvertEntry convert_table[PIX_FMT_NB][PIX_FMT_NB];</p><p>1360</p><p>1361 static void img_convert_init(void)</p><p>1362 {</p><p>1363 int i;</p><p>1364 uint8_t *cm = cropTbl + MAX_NEG_CROP;</p><p>1365</p><p>1366 for (i = 0; i &lt; 256; i++)</p><p>1367 {</p><p>1368 y_ccir_to_jpeg[i] = Y_CCIR_TO_JPEG(i);</p><p>1369 y_jpeg_to_ccir[i] = Y_JPEG_TO_CCIR(i);</p><p>1370 c_ccir_to_jpeg[i] = C_CCIR_TO_JPEG(i);</p><p>1371 c_jpeg_to_ccir[i] = C_JPEG_TO_CCIR(i);</p><p>1372 }</p><p>1373</p><p>1374 convert_table[PIX_FMT_YUV420P][PIX_FMT_YUV422].convert = yuv420p_to_yuv422;</p><p>1375 convert_table[PIX_FMT_YUV420P][PIX_FMT_YUV422].convert = yuv420p_to_yuv422;</p><p>1376 convert_table[PIX_FMT_YUV420P][PIX_FMT_RGB555].convert = yuv420p_to_rgb555;</p><p>1377 convert_table[PIX_FMT_YUV420P][PIX_FMT_RGB565].convert = yuv420p_to_rgb565;</p><p>1378 convert_table[PIX_FMT_YUV420P][PIX_FMT_BGR24].convert = yuv420p_to_bgr24;</p><p>1379 convert_table[PIX_FMT_YUV420P][PIX_FMT_RGB24].convert = yuv420p_to_rgb24;</p><p>1380 convert_table[PIX_FMT_YUV420P][PIX_FMT_RGBA32].convert = yuv420p_to_rgba32;</p><p>1381 convert_table[PIX_FMT_YUV420P][PIX_FMT_UYVY422].convert = yuv420p_to_uyvy422;</p><p>1382</p><p>1383 convert_table[PIX_FMT_YUV422P][PIX_FMT_YUV422].convert = yuv422p_to_yuv422;</p><p>1384 convert_table[PIX_FMT_YUV422P][PIX_FMT_UYVY422].convert = yuv422p_to_uyvy422;</p><p>1385</p><p>1386 convert_table[PIX_FMT_YUV444P][PIX_FMT_RGB24].convert = yuv444p_to_rgb24;</p><p>1387</p><p>1388 convert_table[PIX_FMT_YUVJ420P][PIX_FMT_RGB555].convert = yuvj420p_to_rgb555;</p><p>1389 convert_table[PIX_FMT_YUVJ420P][PIX_FMT_RGB565].convert = yuvj420p_to_rgb565;</p><p>1390 convert_table[PIX_FMT_YUVJ420P][PIX_FMT_BGR24].convert = yuvj420p_to_bgr24;</p><p>1391 convert_table[PIX_FMT_YUVJ420P][PIX_FMT_RGB24].convert = yuvj420p_to_rgb24;</p><p>1392 convert_table[PIX_FMT_YUVJ420P][PIX_FMT_RGBA32].convert = yuvj420p_to_rgba32;</p><p>1393</p><p>1394 convert_table[PIX_FMT_YUVJ444P][PIX_FMT_RGB24].convert = yuvj444p_to_rgb24;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1395</p><p>1396 convert_table[PIX_FMT_YUV422][PIX_FMT_YUV420P].convert = yuv422_to_yuv420p;</p><p>1397 convert_table[PIX_FMT_YUV422][PIX_FMT_YUV422P].convert = yuv422_to_yuv422p;</p><p>1398</p><p>1399 convert_table[PIX_FMT_UYVY422][PIX_FMT_YUV420P].convert = uyvy422_to_yuv420p;</p><p>1400 convert_table[PIX_FMT_UYVY422][PIX_FMT_YUV422P].convert = uyvy422_to_yuv422p;</p><p>1401</p><p>1402 convert_table[PIX_FMT_RGB24][PIX_FMT_YUV420P].convert = rgb24_to_yuv420p;</p><p>1403 convert_table[PIX_FMT_RGB24][PIX_FMT_RGB565].convert = rgb24_to_rgb565;</p><p>1404 convert_table[PIX_FMT_RGB24][PIX_FMT_RGB555].convert = rgb24_to_rgb555;</p><p>1405 convert_table[PIX_FMT_RGB24][PIX_FMT_RGBA32].convert = rgb24_to_rgba32;</p><p>1406 convert_table[PIX_FMT_RGB24][PIX_FMT_BGR24].convert = rgb24_to_bgr24;</p><p>1407 convert_table[PIX_FMT_RGB24][PIX_FMT_GRAY8].convert = rgb24_to_gray;</p><p>1408 convert_table[PIX_FMT_RGB24][PIX_FMT_PAL8].convert = rgb24_to_pal8;</p><p>1409 convert_table[PIX_FMT_RGB24][PIX_FMT_YUV444P].convert = rgb24_to_yuv444p;</p><p>1410 convert_table[PIX_FMT_RGB24][PIX_FMT_YUVJ420P].convert = rgb24_to_yuvj420p;</p><p>1411 convert_table[PIX_FMT_RGB24][PIX_FMT_YUVJ444P].convert = rgb24_to_yuvj444p;</p><p>1412</p><p>1413 convert_table[PIX_FMT_RGBA32][PIX_FMT_RGB24].convert = rgba32_to_rgb24;</p><p>1414 convert_table[PIX_FMT_RGBA32][PIX_FMT_RGB555].convert = rgba32_to_rgb555;</p><p>1415 convert_table[PIX_FMT_RGBA32][PIX_FMT_PAL8].convert = rgba32_to_pal8;</p><p>1416 convert_table[PIX_FMT_RGBA32][PIX_FMT_YUV420P].convert = rgba32_to_yuv420p;</p><p>1417 convert_table[PIX_FMT_RGBA32][PIX_FMT_GRAY8].convert = rgba32_to_gray;</p><p>1418</p><p>1419 convert_table[PIX_FMT_BGR24][PIX_FMT_RGB24].convert = bgr24_to_rgb24;</p><p>1420 convert_table[PIX_FMT_BGR24][PIX_FMT_YUV420P].convert = bgr24_to_yuv420p;</p><p>1421 convert_table[PIX_FMT_BGR24][PIX_FMT_GRAY8].convert = bgr24_to_gray;</p><p>1422</p><p>1423 convert_table[PIX_FMT_RGB555][PIX_FMT_RGB24].convert = rgb555_to_rgb24;</p><p>1424 convert_table[PIX_FMT_RGB555][PIX_FMT_RGBA32].convert = rgb555_to_rgba32;</p><p>1425 convert_table[PIX_FMT_RGB555][PIX_FMT_YUV420P].convert = rgb555_to_yuv420p;</p><p>1426 convert_table[PIX_FMT_RGB555][PIX_FMT_GRAY8].convert = rgb555_to_gray;</p><p>1427</p><p>1428 convert_table[PIX_FMT_RGB565][PIX_FMT_RGB24].convert = rgb565_to_rgb24;</p><p>1429 convert_table[PIX_FMT_RGB565][PIX_FMT_YUV420P].convert = rgb565_to_yuv420p;</p><p>1430 convert_table[PIX_FMT_RGB565][PIX_FMT_GRAY8].convert = rgb565_to_gray;</p><p>1431</p><p>1432 convert_table[PIX_FMT_GRAY8][PIX_FMT_RGB555].convert = gray_to_rgb555;</p><p>1433 convert_table[PIX_FMT_GRAY8][PIX_FMT_RGB565].convert = gray_to_rgb565;</p><p>1434 convert_table[PIX_FMT_GRAY8][PIX_FMT_RGB24].convert = gray_to_rgb24;</p><p>1435 convert_table[PIX_FMT_GRAY8][PIX_FMT_BGR24].convert = gray_to_bgr24;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1436 convert_table[PIX_FMT_GRAY8][PIX_FMT_RGBA32].convert = gray_to_rgba32;</p><p>1437 convert_table[PIX_FMT_GRAY8][PIX_FMT_MONOWHITE].convert = gray_to_monowhite;</p><p>1438 convert_table[PIX_FMT_GRAY8][PIX_FMT_MONOBLACK].convert = gray_to_monoblack;</p><p>1439</p><p>1440 convert_table[PIX_FMT_MONOWHITE][PIX_FMT_GRAY8].convert = monowhite_to_gray;</p><p>1441</p><p>1442 convert_table[PIX_FMT_MONOBLACK][PIX_FMT_GRAY8].convert = monoblack_to_gray;</p><p>1443</p><p>1444 convert_table[PIX_FMT_PAL8][PIX_FMT_RGB555].convert = pal8_to_rgb555;</p><p>1445 convert_table[PIX_FMT_PAL8][PIX_FMT_RGB565].convert = pal8_to_rgb565;</p><p>1446 convert_table[PIX_FMT_PAL8][PIX_FMT_BGR24].convert = pal8_to_bgr24;</p><p>1447 convert_table[PIX_FMT_PAL8][PIX_FMT_RGB24].convert = pal8_to_rgb24;</p><p>1448 convert_table[PIX_FMT_PAL8][PIX_FMT_RGBA32].convert = pal8_to_rgba32;</p><p>1449</p><p>1450 convert_table[PIX_FMT_UYVY411][PIX_FMT_YUV411P].convert = uyvy411_to_yuv411p;</p><p>1451 }</p><p>1452</p><p>1453 static inline int is_yuv_planar(PixFmtInfo *ps)</p><p>1454 {</p><p>1455 return (ps->color_type == FF_COLOR_YUV || ps->color_type == FF_COLOR_YUV_JPEG)</p><p>1456 && ps->pixel_type == FF_PIXEL_PLANAR;</p><p>1457 }</p><p>1458</p><p>1459 int img_convert(AVPicture *dst, int dst_pix_fmt, const AVPicture *src, int src_pix_fmt,</p><p>1460 int src_width, int src_height)</p><p>1461 {</p><p>1462 static int inited;</p><p>1463 int i, ret, dst_width, dst_height, int_pix_fmt;</p><p>1464 PixFmtInfo *src_pix, *dst_pix;</p><p>1465 ConvertEntry *ce;</p><p>1466 AVPicture tmp1, *tmp = &amp;tmp1;</p><p>1467</p><p>1468 if (src_pix_fmt &lt; 0 || src_pix_fmt >= PIX_FMT_NB || dst_pix_fmt &lt; 0 || dst_pix_fmt >= PIX_FMT_NB)</p><p>1469 return - 1;</p><p>1470</p><p>1471 if (src_width &lt;= 0 || src_height &lt;= 0)</p><p>1472 return 0;</p><p>1473</p><p>1474 if (!inited)</p><p>1475 {</p><p>1476 inited = 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1477 img_convert_init();</p><p>1478 }</p><p>1479</p><p>1480 dst_width = src_width;</p><p>1481 dst_height = src_height;</p><p>1482</p><p>1483 dst_pix = &pix_fmt_info[dst_pix_fmt];</p><p>1484 src_pix = &pix_fmt_info[src_pix_fmt];</p><p>1485</p><p>1486 if (src_pix_fmt == dst_pix_fmt) // no conversion needed: just copy</p><p>1487 {</p><p>1488 img_copy(dst, src, dst_pix_fmt, dst_width, dst_height);</p><p>1489 return 0;</p><p>1490 }</p><p>1491</p><p>1492 ce = &convert_table[src_pix_fmt][dst_pix_fmt];</p><p>1493 if (ce->convert)</p><p>1494 {</p><p>1495 ce->convert(dst, src, dst_width, dst_height); // specific conversion routine</p><p>1496 return 0;</p><p>1497 }</p><p>1498</p><p>1499 if (is_yuv_planar(dst_pix) && src_pix_fmt == PIX_FMT_GRAY8) // gray to YUV</p><p>1500 {</p><p>1501 int w, h, y;</p><p>1502 uint8_t *d;</p><p>1503</p><p>1504 if (dst_pix->color_type == FF_COLOR_YUV_JPEG)</p><p>1505 {</p><p>1506 ff_img_copy_plane(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0] ,</p><p>1507 dst_width, dst_height);</p><p>1508 }</p><p>1509 else</p><p>1510 {</p><p>1511 img_apply_table(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0],</p><p>1512 dst_width, dst_height, y_jpeg_to_ccir);</p><p>1513 }</p><p>1514</p><p>1515 w = dst_width; // fill U and V with 128</p><p>1516 h = dst_height;</p><p>1517 w >>= dst_pix->x_chroma_shift;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1518 h >>= dst_pix->y_chroma_shift;</p><p>1519 for (i = 1; i &lt;= 2; i++)</p><p>1520 {</p><p>1521 d = dst->data[i];</p><p>1522 for (y = 0; y &lt; h; y++)</p><p>1523 {</p><p>1524 memset(d, 128, w);</p><p>1525 d += dst->linesize[i];</p><p>1526 }</p><p>1527 }</p><p>1528 return 0;</p><p>1529 }</p><p>1530</p><p>1531 if (is_yuv_planar(src_pix) && dst_pix_fmt == PIX_FMT_GRAY8) // YUV to gray</p><p>1532 {</p><p>1533 if (src_pix->color_type == FF_COLOR_YUV_JPEG)</p><p>1534 {</p><p>1535 ff_img_copy_plane(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0] ,</p><p>1536 dst_width, dst_height);</p><p>1537 }</p><p>1538 else</p><p>1539 {</p><p>1540 img_apply_table(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0],</p><p>1541 dst_width, dst_height, y_ccir_to_jpeg);</p><p>1542 }</p><p>1543 return 0;</p><p>1544 }</p><p>1545</p><p>1546 if (is_yuv_planar(dst_pix) && is_yuv_planar(src_pix)) // YUV to YUV planar</p><p>1547 {</p><p>1548 int x_shift, y_shift, w, h, xy_shift;</p><p>1549 void(*resize_func)(uint8_t *dst, int dst_wrap, const uint8_t *src, int src_wrap,</p><p>1550 int width, int height);</p><p>1551</p><p>1552 // compute chroma size of the smallest dimensions</p><p>1553 w = dst_width;</p><p>1554 h = dst_height;</p><p>1555 if (dst_pix->x_chroma_shift >= src_pix->x_chroma_shift)</p><p>1556 w >>= dst_pix->x_chroma_shift;</p><p>1557 else</p><p>1558 w >>= src_pix->x_chroma_shift;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1559 if (dst_pix->y_chroma_shift >= src_pix->y_chroma_shift)</p><p>1560 h >>= dst_pix->y_chroma_shift;</p><p>1561 else</p><p>1562 h >>= src_pix->y_chroma_shift;</p><p>1563</p><p>1564 x_shift = (dst_pix->x_chroma_shift - src_pix->x_chroma_shift);</p><p>1565 y_shift = (dst_pix->y_chroma_shift - src_pix->y_chroma_shift);</p><p>1566 xy_shift = ((x_shift &0xf) &lt;&lt; 4) | (y_shift &0xf);</p><p>1567</p><p>1568 // there must be filters for conversion at least from and to YUV444 format</p><p>1569 switch (xy_shift)</p><p>1570 {</p><p>1571 case 0x00:</p><p>1572 resize_func = ff_img_copy_plane;</p><p>1573 break;</p><p>1574 case 0x10:</p><p>1575 resize_func = shrink21;</p><p>1576 break;</p><p>1577 case 0x20:</p><p>1578 resize_func = shrink41;</p><p>1579 break;</p><p>1580 case 0x01:</p><p>1581 resize_func = shrink12;</p><p>1582 break;</p><p>1583 case 0x11:</p><p>1584 resize_func = ff_shrink22;</p><p>1585 break;</p><p>1586 case 0x22:</p><p>1587 resize_func = ff_shrink44;</p><p>1588 break;</p><p>1589 case 0xf0:</p><p>1590 resize_func = grow21;</p><p>1591 break;</p><p>1592 case 0xe0:</p><p>1593 resize_func = grow41;</p><p>1594 break;</p><p>1595 case 0xff:</p><p>1596 resize_func = grow22;</p><p>1597 break;</p><p>1598 case 0xee:</p><p>1599 resize_func = grow44;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1600 break;</p><p>1601 case 0xf1:</p><p>1602 resize_func = conv411;</p><p>1603 break;</p><p>1604 default:</p><p>1605 goto no_chroma_filter; // currently not handled</p><p>1606 }</p><p>1607</p><p>1608 ff_img_copy_plane(dst->data[0], dst->linesize[0], src->data[0], src->linesize[0],</p><p>1609 dst_width, dst_height);</p><p>1610</p><p>1611 for (i = 1; i &lt;= 2; i++)</p><p>1612 resize_func(dst->data[i], dst->linesize[i], src->data[i], src->linesize[i],</p><p>1613 dst_width >> dst_pix->x_chroma_shift, dst_height >> dst_pix->y_chroma_shift);</p><p>1614</p><p>1615 // if yuv color space conversion is needed, we do it here on the destination image</p><p>1616 if (dst_pix->color_type != src_pix->color_type)</p><p>1617 {</p><p>1618 const uint8_t *y_table, *c_table;</p><p>1619 if (dst_pix->color_type == FF_COLOR_YUV)</p><p>1620 {</p><p>1621 y_table = y_jpeg_to_ccir;</p><p>1622 c_table = c_jpeg_to_ccir;</p><p>1623 }</p><p>1624 else</p><p>1625 {</p><p>1626 y_table = y_ccir_to_jpeg;</p><p>1627 c_table = c_ccir_to_jpeg;</p><p>1628 }</p><p>1629</p><p>1630 img_apply_table(dst->data[0], dst->linesize[0], dst->data[0], dst->linesize[0],</p><p>1631 dst_width, dst_height, y_table);</p><p>1632</p><p>1633 for (i = 1; i &lt;= 2; i++)</p><p>1634 img_apply_table(dst->data[i], dst->linesize[i], dst->data[i], dst->linesize[i],</p><p>1635 dst_width >> dst_pix->x_chroma_shift, dst_height >> dst_pix->y_chroma_shift, c_table);</p><p>1636 }</p><p>1637 return 0;</p><p>1638 }</p><p>1639</p><p>1640 no_chroma_filter: // try to use an intermediate format<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1641</p><p>1642 if (src_pix_fmt == PIX_FMT_YUV422 || dst_pix_fmt == PIX_FMT_YUV422)</p><p>1643 {</p><p>1644 int_pix_fmt = PIX_FMT_YUV422P; // specific case: convert to YUV422P first</p><p>1645 }</p><p>1646 else if (src_pix_fmt == PIX_FMT_UYVY422 || dst_pix_fmt == PIX_FMT_UYVY422)</p><p>1647 {</p><p>1648</p><p>1649 int_pix_fmt = PIX_FMT_YUV422P; // specific case: convert to YUV422P first</p><p>1650 }</p><p>1651 else if (src_pix_fmt == PIX_FMT_UYVY411 || dst_pix_fmt == PIX_FMT_UYVY411)</p><p>1652 {</p><p>1653</p><p>1654 int_pix_fmt = PIX_FMT_YUV411P; // specific case: convert to YUV411P first</p><p>1655 }</p><p>1656 else if ((src_pix->color_type == FF_COLOR_GRAY && src_pix_fmt != PIX_FMT_GRAY8)</p><p>1657 || (dst_pix->color_type == FF_COLOR_GRAY && dst_pix_fmt != PIX_FMT_GRAY8))</p><p>1658 {</p><p>1659</p><p>1660 int_pix_fmt = PIX_FMT_GRAY8; // gray8 is the normalized format</p><p>1661 }</p><p>1662 else if ((is_yuv_planar(src_pix) && src_pix_fmt != PIX_FMT_YUV444P</p><p>1663 && src_pix_fmt != PIX_FMT_YUVJ444P))</p><p>1664 {</p><p>1665 if (src_pix->color_type == FF_COLOR_YUV_JPEG) // yuv444 is the normalized format</p><p>1666 int_pix_fmt = PIX_FMT_YUVJ444P;</p><p>1667 else</p><p>1668 int_pix_fmt = PIX_FMT_YUV444P;</p><p>1669 }</p><p>1670 else if ((is_yuv_planar(dst_pix) && dst_pix_fmt != PIX_FMT_YUV444P</p><p>1671 && dst_pix_fmt != PIX_FMT_YUVJ444P))</p><p>1672 {</p><p>1673 if (dst_pix->color_type == FF_COLOR_YUV_JPEG) // yuv444 is the normalized format</p><p>1674 int_pix_fmt = PIX_FMT_YUVJ444P;</p><p>1675 else</p><p>1676 int_pix_fmt = PIX_FMT_YUV444P;</p><p>1677 }</p><p>1678 else // the two formats are rgb or gray8 or yuv[j]444p</p><p>1679 {</p><p>1680 if (src_pix->is_alpha && dst_pix->is_alpha)</p><p>1681 int_pix_fmt = PIX_FMT_RGBA32;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>1682 else</p><p>1683 int_pix_fmt = PIX_FMT_RGB24;</p><p>1684 }</p><p>1685</p><p>1686 if (avpicture_alloc(tmp, int_pix_fmt, dst_width, dst_height) &lt; 0)</p><p>1687 return - 1;</p><p>1688</p><p>1689 ret = - 1;</p><p>1690</p><p>1691 if (img_convert(tmp, int_pix_fmt, src, src_pix_fmt, src_width, src_height) &lt; 0)</p><p>1692 goto fail1;</p><p>1693</p><p>1694 if (img_convert(dst, dst_pix_fmt, tmp, int_pix_fmt, dst_width, dst_height) &lt; 0)</p><p>1695 goto fail1;</p><p>1696 ret = 0;</p><p>1697</p><p>1698 fail1:</p><p>1699 avpicture_free(tmp);</p><p>1700 return ret;</p><p>1701 }</p><p>1702</p><p>1703 #undef FIX</p><h3 id=images2020ffmpegasposewordsa0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4020png9-msrlec-文件><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><strong>9 msrle.c 文件</strong></h3><p>9.1 功能描述</p><p>此文件实现微软行程长度压缩算法解码器，此文件请各位参考压缩算法自己仔细分析。</p><p>9.2 文件注释</p><p>1 #include &lt;stdio.h></p><p>2 #include &lt;stdlib.h></p><p>3 #include &lt;string.h></p><p>4</p><p>5 #include "../libavutil/common.h"</p><p>6 #include "avcodec.h"</p><p>7 #include "dsputil.h"</p><p>8</p><p>9 #define FF_BUFFER_HINTS_VALID 0x01 // Buffer hints value is meaningful (if 0 ignore)</p><p>10 #define FF_BUFFER_HINTS_READABLE 0x02 // Codec will read from buffer</p><p>11 #define FF_BUFFER_HINTS_PRESERVE 0x04 // User must not alter buffer content</p><p>12 #define FF_BUFFER_HINTS_REUSABLE 0x08 // Codec will reuse the buffer (update)</p><p>13<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>此文件请各位参考压缩算法自己仔细分析。</p><p>14 typedef struct MsrleContext</p><p>15 {</p><p>16 AVCodecContext *avctx;</p><p>17 AVFrame frame;</p><p>18</p><p>19 unsigned char *buf;</p><p>20 int size;</p><p>21</p><p>22 } MsrleContext;</p><p>23</p><p>24 #define FETCH_NEXT_STREAM_BYTE() \</p><p>25 if (stream_ptr >= s->size) \</p><p>26 { \</p><p>27 return; \</p><p>28 } \</p><p>29 stream_byte = s->buf[stream_ptr++];</p><p>30</p><p>31 static void msrle_decode_pal4(MsrleContext *s)</p><p>32 {</p><p>33 int stream_ptr = 0;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>34 unsigned char rle_code;</p><p>35 unsigned char extra_byte, odd_pixel;</p><p>36 unsigned char stream_byte;</p><p>37 int pixel_ptr = 0;</p><p>38 int row_dec = s->frame.linesize[0];</p><p>39 int row_ptr = (s->avctx->height - 1) *row_dec;</p><p>40 int frame_size = row_dec * s->avctx->height;</p><p>41 int i;</p><p>42</p><p>43 // make the palette available</p><p>44 memcpy(s->frame.data[1], s->avctx->palctrl->palette, AVPALETTE_SIZE);</p><p>45 if (s->avctx->palctrl->palette_changed)</p><p>46 {</p><p>47 // s->frame.palette_has_changed = 1;</p><p>48 s->avctx->palctrl->palette_changed = 0;</p><p>49 }</p><p>50</p><p>51 while (row_ptr >= 0)</p><p>52 {</p><p>53 FETCH_NEXT_STREAM_BYTE();</p><p>54 rle_code = stream_byte;</p><p>55 if (rle_code == 0)</p><p>56 {</p><p>57 // fetch the next byte to see how to handle escape code</p><p>58 FETCH_NEXT_STREAM_BYTE();</p><p>59 if (stream_byte == 0)</p><p>60 {</p><p>61 // line is done, goto the next one</p><p>62 row_ptr -= row_dec;</p><p>63 pixel_ptr = 0;</p><p>64 }</p><p>65 else if (stream_byte == 1)</p><p>66 {</p><p>67 // decode is done</p><p>68 return ;</p><p>69 }</p><p>70 else if (stream_byte == 2)</p><p>71 {</p><p>72 // reposition frame decode coordinates</p><p>73 FETCH_NEXT_STREAM_BYTE();</p><p>74 pixel_ptr += stream_byte;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>75 FETCH_NEXT_STREAM_BYTE();</p><p>76 row_ptr -= stream_byte * row_dec;</p><p>77 }</p><p>78 else</p><p>79 {</p><p>80 // copy pixels from encoded stream</p><p>81 odd_pixel = stream_byte &amp;1;</p><p>82 rle_code = (stream_byte + 1) / 2;</p><p>83 extra_byte = rle_code &amp;0x01;</p><p>84 if ((row_ptr + pixel_ptr + stream_byte > frame_size) || (row_ptr &lt; 0))</p><p>85 {</p><p>86 return ;</p><p>87 }</p><p>88</p><p>89 for (i = 0; i &lt; rle_code; i++)</p><p>90 {</p><p>91 if (pixel_ptr >= s->avctx->width)</p><p>92 break;</p><p>93 FETCH_NEXT_STREAM_BYTE();</p><p>94 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte >> 4;</p><p>95 pixel_ptr++;</p><p>96 if (i + 1 == rle_code && odd_pixel)</p><p>97 break;</p><p>98 if (pixel_ptr >= s->avctx->width)</p><p>99 break;</p><p>100 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte &amp;0x0F;</p><p>101 pixel_ptr++;</p><p>102 }</p><p>103</p><p>104 // if the RLE code is odd, skip a byte in the stream</p><p>105 if (extra_byte)</p><p>106 stream_ptr++;</p><p>107 }</p><p>108 }</p><p>109 else</p><p>110 {</p><p>111 // decode a run of data</p><p>112 if ((row_ptr + pixel_ptr + stream_byte > frame_size) || (row_ptr &lt; 0))</p><p>113 {</p><p>114 return ;</p><p>115 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>116 FETCH_NEXT_STREAM_BYTE();</p><p>117 for (i = 0; i &lt; rle_code; i++)</p><p>118 {</p><p>119 if (pixel_ptr >= s->avctx->width)</p><p>120 break;</p><p>121 if ((i &1) == 0)</p><p>122 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte >> 4;</p><p>123 else</p><p>124 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte &amp;0x0F;</p><p>125 pixel_ptr++;</p><p>126 }</p><p>127 }</p><p>128 }</p><p>129</p><p>130 // one last sanity check on the way out</p><p>131 if (stream_ptr &lt; s->size)</p><p>132 {</p><p>133 // error</p><p>134 }</p><p>135 }</p><p>136</p><p>137 static void msrle_decode_pal8(MsrleContext *s)</p><p>138 {</p><p>139 int stream_ptr = 0;</p><p>140 unsigned char rle_code;</p><p>141 unsigned char extra_byte;</p><p>142 unsigned char stream_byte;</p><p>143 int pixel_ptr = 0;</p><p>144 int row_dec = s->frame.linesize[0];</p><p>145 int row_ptr = (s->avctx->height - 1) *row_dec;</p><p>146 int frame_size = row_dec * s->avctx->height;</p><p>147</p><p>148 // make the palette available</p><p>149 memcpy(s->frame.data[1], s->avctx->palctrl->palette, AVPALETTE_SIZE);</p><p>150 if (s->avctx->palctrl->palette_changed)</p><p>151 {</p><p>152 // s->frame.palette_has_changed = 1;</p><p>153 s->avctx->palctrl->palette_changed = 0;</p><p>154 }</p><p>155</p><p>156 while (row_ptr >= 0)</p><table><thead><tr><th>157</th><th>{</th><th></th></tr></thead><tbody><tr><td>158</td><td></td><td>FETCH_NEXT_STREAM_BYTE();</td></tr><tr><td>159</td><td></td><td>rle_code = stream_byte;</td></tr><tr><td>160 if (rle_code == 0)</td><td></td><td></td></tr></tbody></table><p>161 {</p><p>162 // fetch the next byte to see how to handle escape code</p><p>163 FETCH_NEXT_STREAM_BYTE();</p><p>164 if (stream_byte == 0)</p><p>165 {</p><p>166 // line is done, goto the next one</p><p>167 row_ptr -= row_dec;</p><p>168 pixel_ptr = 0;</p><p>169 }</p><p>170 else if (stream_byte == 1)</p><p>171 {</p><p>172 // decode is done</p><p>173 return ;</p><p>174 }</p><p>175 else if (stream_byte == 2)</p><p>176 {</p><p>177 // reposition frame decode coordinates</p><p>178 FETCH_NEXT_STREAM_BYTE();</p><p>179 pixel_ptr += stream_byte;</p><p>180 FETCH_NEXT_STREAM_BYTE();</p><p>181 row_ptr -= stream_byte * row_dec;</p><p>182 }</p><p>183 else</p><p>184 {</p><p>185 // copy pixels from encoded stream</p><p>186 if ((row_ptr + pixel_ptr + stream_byte > frame_size) || (row_ptr &lt; 0))</p><p>187 {</p><p>188 return ;</p><p>189 }</p><p>190</p><p>191 rle_code = stream_byte;</p><p>192 extra_byte = stream_byte &amp;0x01;</p><p>193 if (stream_ptr + rle_code + extra_byte > s->size)</p><p>194 {</p><p>195 return ;</p><p>196 }</p><p>197<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>198 while (rle_code--)</p><p>199 {</p><p>200 FETCH_NEXT_STREAM_BYTE();</p><p>201 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte;</p><p>202 pixel_ptr++;</p><p>203 }</p><p>204</p><p>205 // if the RLE code is odd, skip a byte in the stream</p><p>206 if (extra_byte)</p><p>207 stream_ptr++;</p><p>208 }</p><p>209 }</p><p>210 else</p><p>211 {</p><p>212 // decode a run of data</p><p>213 if ((row_ptr + pixel_ptr + stream_byte > frame_size) || (row_ptr &lt; 0))</p><p>214 {</p><p>215 return ;</p><p>216 }</p><p>217</p><p>218 FETCH_NEXT_STREAM_BYTE();</p><p>219</p><p>220 while (rle_code--)</p><p>221 {</p><p>222 s->frame.data[0][row_ptr + pixel_ptr] = stream_byte;</p><p>223 pixel_ptr++;</p><p>224 }</p><p>225 }</p><p>226 }</p><p>227</p><p>228 // one last sanity check on the way out</p><p>229 if (stream_ptr &lt; s->size)</p><p>230 {</p><p>231 // error</p><p>232 }</p><p>233 }</p><p>234</p><p>235 static int msrle_decode_init(AVCodecContext *avctx)</p><p>236 {</p><p>237 MsrleContext *s = (MsrleContext*)avctx->priv_data;</p><p>238<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>239 s->avctx = avctx;</p><p>240</p><p>241 avctx->pix_fmt = PIX_FMT_PAL8;</p><p>242</p><p>243 s->frame.data[0] = NULL;</p><p>244</p><p>245 return 0;</p><p>246 }</p><p>247</p><p>248 static int msrle_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)</p><p>249 {</p><p>250 MsrleContext *s = (MsrleContext*)avctx->priv_data;</p><p>251</p><p>252 s->buf = buf;</p><p>253 s->size = buf_size;</p><p>254</p><p>255 if (avctx->reget_buffer(avctx, &s->frame))</p><p>256 return - 1;</p><p>257</p><p>258 switch (avctx->bits_per_sample)</p><p>259 {</p><p>260 case 8:</p><p>261 msrle_decode_pal8(s);</p><p>262 break;</p><p>263 case 4:</p><p>264 msrle_decode_pal4(s);</p><p>265 break;</p><p>266 default:</p><p>267 break;</p><p>268 }</p><p>269</p><p>270 *data_size = sizeof(AVFrame);</p><p>271 *(AVFrame*)data = s->frame;</p><p>272</p><p>273 // report that the buffer was completely consumed</p><p>274 return buf_size;</p><p>275 }</p><p>276</p><p>277 static int msrle_decode_end(AVCodecContext *avctx)</p><p>278 {</p><p>279 MsrleContext *s = (MsrleContext*)avctx->priv_data;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>280</p><p>281 // release the last frame</p><p>282 if (s->frame.data[0])</p><p>283 avctx->release_buffer(avctx, &s->frame);</p><p>284</p><p>285 return 0;</p><p>286 }</p><p>287</p><p>288 AVCodec msrle_decoder =</p><p>289 {</p><p>290 "msrle",</p><p>291 CODEC_TYPE_VIDEO,</p><p>292 CODEC_ID_MSRLE,</p><p>293 sizeof(MsrleContext),</p><p>294 msrle_decode_init,</p><p>295 NULL,</p><p>296 msrle_decode_end,</p><p>297 msrle_decode_frame</p><p>298 };<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=10-turespeech_datah-文件><strong>10 turespeech_data.h 文件</strong></h3><p>10.1 功能描述</p><p>此文件定义 true speed 音频解码器使用的常数，此文件请各位参考 TrueSpeed 压缩算法自己仔细分析。</p><p>10.2 文件注释</p><p>1 #ifndef TRUESPEECH_DATA</p><p>2 #define TRUESPEECH_DATA</p><p>3</p><p>4 #pragma warning(disable:4305 )</p><p>5<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>此文件请各位参考 TrueSpeed 压缩算法自己仔细分析。</p><p>6 /* codebooks fo expanding input filter */</p><p>7 static const int16_t ts_cb_0[32] =</p><p>8 {</p><p>9 0x8240, 0x8364, 0x84CE, 0x865D, 0x8805, 0x89DE, 0x8BD7, 0x8DF4,</p><p>10 0x9051, 0x92E2, 0x95DE, 0x990F, 0x9C81, 0xA079, 0xA54C, 0xAAD2,</p><p>11 0xB18A, 0xB90A, 0xC124, 0xC9CC, 0xD339, 0xDDD3, 0xE9D6, 0xF893,</p><p>12 0x096F, 0x1ACA, 0x29EC, 0x381F, 0x45F9, 0x546A, 0x63C3, 0x73B5,</p><p>13 };</p><p>14</p><p>15 static const int16_t ts_cb_1[32] =</p><p>16 {</p><p>17 0x9F65, 0xB56B, 0xC583, 0xD371, 0xE018, 0xEBB4, 0xF61C, 0xFF59,</p><p>18 0x085B, 0x1106, 0x1952, 0x214A, 0x28C9, 0x2FF8, 0x36E6, 0x3D92,</p><p>19 0x43DF, 0x49BB, 0x4F46, 0x5467, 0x5930, 0x5DA3, 0x61EC, 0x65F9,</p><p>20 0x69D4, 0x6D5A, 0x709E, 0x73AD, 0x766B, 0x78F0, 0x7B5A, 0x7DA5,</p><p>21 };</p><p>22</p><p>23 static const int16_t ts_cb_2[16] =</p><p>24 {</p><p>25 0x96F8, 0xA3B4, 0xAF45, 0xBA53, 0xC4B1, 0xCECC, 0xD86F, 0xE21E,</p><p>26 0xEBF3, 0xF640, 0x00F7, 0x0C20, 0x1881, 0x269A, 0x376B, 0x4D60,</p><p>27 };</p><p>28</p><p>29 static const int16_t ts_cb_3[16] =</p><p>30 {</p><p>31 0xC654, 0xDEF2, 0xEFAA, 0xFD94, 0x096A, 0x143F, 0x1E7B, 0x282C,</p><p>32 0x3176, 0x3A89, 0x439F, 0x4CA2, 0x557F, 0x5E50, 0x6718, 0x6F8D,</p><p>33 };<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>34</p><p>35 static const int16_t ts_cb_4[16] =</p><p>36 {</p><p>37 0xABE7, 0xBBA8, 0xC81C, 0xD326, 0xDD0E, 0xE5D4, 0xEE22, 0xF618,</p><p>38 0xFE28, 0x064F, 0x0EB7, 0x17B8, 0x21AA, 0x2D8B, 0x3BA2, 0x4DF9,</p><p>39 };</p><p>40</p><p>41 static const int16_t ts_cb_5[8] = { 0xD51B, 0xF12E, 0x042E, 0x13C7, 0x2260, 0x311B, 0x40DE, 0x5385,};</p><p>42</p><p>43 static const int16_t ts_cb_6[8] = { 0xB550, 0xC825, 0xD980, 0xE997, 0xF883, 0x0752, 0x1811, 0x2E18,};</p><p>44</p><p>45 static const int16_t ts_cb_7[8] = { 0xCEF0, 0xE4F9, 0xF6BB, 0x0646, 0x14F5, 0x23FF, 0x356F, 0x4A8D,};</p><p>46</p><p>47 static const int16_t *ts_codebook[8] = {ts_cb_0, ts_cb_1, ts_cb_2, ts_cb_3,</p><p>48 ts_cb_4, ts_cb_5, ts_cb_6, ts_cb_7};</p><p>49 /* table used for decoding pulse positions */</p><p>50 static const int16_t ts_140[120] =</p><p>51 {</p><p>52 0x0E46, 0x0CCC, 0x0B6D, 0x0A28, 0x08FC, 0x07E8, 0x06EB, 0x0604,</p><p>53 0x0532, 0x0474, 0x03C9, 0x0330, 0x02A8, 0x0230, 0x01C7, 0x016C,</p><p>54 0x011E, 0x00DC, 0x00A5, 0x0078, 0x0054, 0x0038, 0x0023, 0x0014,</p><p>55 0x000A, 0x0004, 0x0001, 0x0000, 0x0000, 0x0000,</p><p>56</p><p>57 0x0196, 0x017A, 0x015F, 0x0145, 0x012C, 0x0114, 0x00FD, 0x00E7,</p><p>58 0x00D2, 0x00BE, 0x00AB, 0x0099, 0x0088, 0x0078, 0x0069, 0x005B,</p><p>59 0x004E, 0x0042, 0x0037, 0x002D, 0x0024, 0x001C, 0x0015, 0x000F,</p><p>60 0x000A, 0x0006, 0x0003, 0x0001, 0x0000, 0x0000,</p><p>61</p><p>62 0x001D, 0x001C, 0x001B, 0x001A, 0x0019, 0x0018, 0x0017, 0x0016,</p><p>63 0x0015, 0x0014, 0x0013, 0x0012, 0x0011, 0x0010, 0x000F, 0x000E,</p><p>64 0x000D, 0x000C, 0x000B, 0x000A, 0x0009, 0x0008, 0x0007, 0x0006,</p><p>65 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0000,</p><p>66</p><p>67 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001,</p><p>68 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001,</p><p>69 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001,</p><p>70 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001</p><p>71 };</p><p>72</p><p>73 /* filter for correlated input filter */</p><p>74 static const int16_t ts_230[8] = { 0x7F3B, 0x7E78, 0x7DB6, 0x7CF5, 0x7C35, 0x7B76, 0x7AB8, 0x79FC };<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>75</p><p>76 /* two-point filters table */</p><p>77 static const int16_t ts_240[25 * 2] =</p><p>78 {</p><p>79 0xED2F, 0x5239,</p><p>80 0x54F1, 0xE4A9,</p><p>81 0x2620, 0xEE3E,</p><p>82 0x09D6, 0x2C40,</p><p>83 0xEFB5, 0x2BE0,</p><p>84</p><p>85 0x3FE1, 0x3339,</p><p>86 0x442F, 0xE6FE,</p><p>87 0x4458, 0xF9DF,</p><p>88 0xF231, 0x43DB,</p><p>89 0x3DB0, 0xF705,</p><p>90</p><p>91 0x4F7B, 0xFEFB,</p><p>92 0x26AD, 0x0CDC,</p><p>93 0x33C2, 0x0739,</p><p>94 0x12BE, 0x43A2,</p><p>95 0x1BDF, 0x1F3E,</p><p>96</p><p>97 0x0211, 0x0796,</p><p>98 0x2AEB, 0x163F,</p><p>99 0x050D, 0x3A38,</p><p>100 0x0D1E, 0x0D78,</p><p>101 0x150F, 0x3346,</p><p>102</p><p>103 0x38A4, 0x0B7D,</p><p>104 0x2D5D, 0x1FDF,</p><p>105 0x19B7, 0x2822,</p><p>106 0x0D99, 0x1F12,</p><p>107 0x194C, 0x0CE6</p><p>108 };</p><p>109</p><p>110 /* possible pulse values */</p><p>111 static const int16_t ts_562[64] =</p><p>112 {</p><p>113 0x0002, 0x0006, 0xFFFE, 0xFFFA,</p><p>114 0x0004, 0x000C, 0xFFFC, 0xFFF4,</p><p>115 0x0006, 0x0012, 0xFFFA, 0xFFEE,<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>116 0x000A, 0x001E, 0xFFF6, 0xFFE2,</p><p>117 0x0010, 0x0030, 0xFFF0, 0xFFD0,</p><p>118 0x0019, 0x004B, 0xFFE7, 0xFFB5,</p><p>119 0x0028, 0x0078, 0xFFD8, 0xFF88,</p><p>120 0x0040, 0x00C0, 0xFFC0, 0xFF40,</p><p>121 0x0065, 0x012F, 0xFF9B, 0xFED1,</p><p>122 0x00A1, 0x01E3, 0xFF5F, 0xFE1D,</p><p>123 0x0100, 0x0300, 0xFF00, 0xFD00,</p><p>124 0x0196, 0x04C2, 0xFE6A, 0xFB3E,</p><p>125 0x0285, 0x078F, 0xFD7B, 0xF871,</p><p>126 0x0400, 0x0C00, 0xFC00, 0xF400,</p><p>127 0x0659, 0x130B, 0xF9A7, 0xECF5,</p><p>128 0x0A14, 0x1E3C, 0xF5EC, 0xE1C4</p><p>129 };</p><p>130</p><p>131 /* filters used in final output calculations */</p><p>132 static const int16_t ts_5E2[8] = { 0x4666, 0x26B8, 0x154C, 0x0BB6, 0x0671, 0x038B, 0x01F3, 0x0112 };</p><p>133</p><p>134 static const int16_t ts_5F2[8] = { 0x6000, 0x4800, 0x3600, 0x2880, 0x1E60, 0x16C8, 0x1116, 0x0CD1 };</p><p>135</p><p>136 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=11-turespeechc-文件><strong>11 turespeech.c 文件</strong></h3><p>11.1 功能描述</p><p>此文件实现 true speed 音频解码器，此文件请各位参考压缩算法自己仔细分析。</p><p>11.2 文件注释</p><p>1 #include "avcodec.h"</p><p>2</p><p>3 #include "truespeech_data.h"</p><p>4</p><p>5 // TrueSpeech decoder context</p><p>6<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.058.png alt></p><p>此文件请各位参考 TrueSpeed 压缩算法自己仔细分析。</p><p>7 typedef struct TSContext</p><p>8 {</p><p>9 // input data</p><p>10 int16_t vector[8]; // input vector: 5/5/4/4/4/3/3/3</p><p>11 int offset1[2]; // 8-bit value, used in one copying offset</p><p>12 int offset2[4]; // 7-bit value, encodes offsets for copying and for two-point filter</p><p>13 int pulseoff[4]; // 4-bit offset of pulse values block</p><p>14 int pulsepos[4]; // 27-bit variable, encodes 7 pulse positions</p><p>15 int pulseval[4]; // 7x2-bit pulse values</p><p>16 int flag; // 1-bit flag, shows how to choose filters</p><p>17 // temporary data</p><p>18 int filtbuf[146]; // some big vector used for storing filters</p><p>19 int prevfilt[8]; // filter from previous frame</p><p>20 int16_t tmp1[8]; // coefficients for adding to out</p><p>21 int16_t tmp2[8]; // coefficients for adding to out</p><p>22 int16_t tmp3[8]; // coefficients for adding to out</p><p>23 int16_t cvector[8]; // correlated input vector</p><p>24 int filtval; // gain value for one function</p><p>25 int16_t newvec[60]; // tmp vector</p><p>26 int16_t filters[32]; // filters for every subframe</p><p>27 } TSContext;</p><p>28</p><p>29 #if !defined(LE_32)</p><p>30 #define LE_32(x) ((((uint8_t*)(x))[3] &lt;&lt; 24)| (((uint8_t*)(x))[2] &lt;&lt; 16) | \</p><p>31 (((uint8_t*)(x))[1] &lt;&lt; 8) | ((uint8_t*)(x))[0])</p><p>32 #endif</p><p>33<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>34 static int truespeech_decode_init(AVCodecContext *avctx)</p><p>35 {</p><p>36 return 0;</p><p>37 }</p><p>38</p><p>39 static void truespeech_read_frame(TSContext *dec, uint8_t *input)</p><p>40 {</p><p>41 uint32_t t;</p><p>42</p><p>43 t = LE_32(input); // first dword</p><p>44 input += 4;</p><p>45</p><p>46 dec->flag = t &amp;1;</p><p>47</p><p>48 dec->vector[0] = ts_codebook[0][(t >> 1) &0x1F];</p><p>49 dec->vector[1] = ts_codebook[1][(t >> 6) &0x1F];</p><p>50 dec->vector[2] = ts_codebook[2][(t >> 11) &0xF];</p><p>51 dec->vector[3] = ts_codebook[3][(t >> 15) &0xF];</p><p>52 dec->vector[4] = ts_codebook[4][(t >> 19) &0xF];</p><p>53 dec->vector[5] = ts_codebook[5][(t >> 23) &0x7];</p><p>54 dec->vector[6] = ts_codebook[6][(t >> 26) &0x7];</p><p>55 dec->vector[7] = ts_codebook[7][(t >> 29) &0x7];</p><p>56</p><p>57</p><p>58 t = LE_32(input); // second dword</p><p>59 input += 4;</p><p>60</p><p>61 dec->offset2[0] = (t >> 0) &amp;0x7F;</p><p>62 dec->offset2[1] = (t >> 7) &amp;0x7F;</p><p>63 dec->offset2[2] = (t >> 14) &amp;0x7F;</p><p>64 dec->offset2[3] = (t >> 21) &amp;0x7F;</p><p>65</p><p>66 dec->offset1[0] = ((t >> 28) &0xF) &lt;&lt; 4;</p><p>67</p><p>68</p><p>69 t = LE_32(input); // third dword</p><p>70 input += 4;</p><p>71</p><p>72 dec->pulseval[0] = (t >> 0) &amp;0x3FFF;</p><p>73 dec->pulseval[1] = (t >> 14) &amp;0x3FFF;</p><p>74<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>75 dec->offset1[1] = (t >> 28) &amp;0x0F;</p><p>76</p><p>77</p><p>78 t = LE_32(input); // fourth dword</p><p>79 input += 4;</p><p>80</p><p>81 dec->pulseval[2] = (t >> 0) &amp;0x3FFF;</p><p>82 dec->pulseval[3] = (t >> 14) &amp;0x3FFF;</p><p>83</p><p>84 dec->offset1[1] |= ((t >> 28) &0x0F) &lt;&lt; 4;</p><p>85</p><p>86</p><p>87 t = LE_32(input); // fifth dword</p><p>88 input += 4;</p><p>89</p><p>90 dec->pulsepos[0] = (t >> 4) &amp;0x7FFFFFF;</p><p>91</p><p>92 dec->pulseoff[0] = (t >> 0) &amp;0xF;</p><p>93</p><p>94 dec->offset1[0] |= (t >> 31) &amp;1;</p><p>95</p><p>96</p><p>97 t = LE_32(input); // sixth dword</p><p>98 input += 4;</p><p>99</p><p>100 dec->pulsepos[1] = (t >> 4) &amp;0x7FFFFFF;</p><p>101</p><p>102 dec->pulseoff[1] = (t >> 0) &amp;0xF;</p><p>103</p><p>104 dec->offset1[0] |= ((t >> 31) &1) &lt;&lt; 1;</p><p>105</p><p>106</p><p>107 t = LE_32(input); // seventh dword</p><p>108 input += 4;</p><p>109</p><p>110 dec->pulsepos[2] = (t >> 4) &amp;0x7FFFFFF;</p><p>111</p><p>112 dec->pulseoff[2] = (t >> 0) &amp;0xF;</p><p>113</p><p>114 dec->offset1[0] |= ((t >> 31) &1) &lt;&lt; 2;</p><p>115<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>116</p><p>117 t = LE_32(input); // eighth dword</p><p>118 input += 4;</p><p>119</p><p>120 dec->pulsepos[3] = (t >> 4) &amp;0x7FFFFFF;</p><p>121</p><p>122 dec->pulseoff[3] = (t >> 0) &amp;0xF;</p><p>123</p><p>124 dec->offset1[0] |= ((t >> 31) &1) &lt;&lt; 3;</p><p>125 }</p><p>126</p><p>127 static void truespeech_correlate_filter(TSContext *dec)</p><p>128 {</p><p>129 int16_t tmp[8];</p><p>130 int i, j;</p><p>131</p><p>132 for (i = 0; i &lt; 8; i++)</p><p>133 {</p><p>134 if (i > 0)</p><p>135 {</p><p>136 memcpy(tmp, dec->cvector, i *2);</p><p>137 for (j = 0; j &lt; i; j++)</p><p>138 dec->cvector[j] =((tmp[i-j-1]*dec->vector[i])+(dec->cvector[j]&lt;&lt; 15)+0x4000)>>15;</p><p>139 }</p><p>140 dec->cvector[i] = (8-dec->vector[i]) >> 3;</p><p>141 }</p><p>142</p><p>143 for (i = 0; i &lt; 8; i++)</p><p>144 dec->cvector[i] = (dec->cvector[i] *ts_230[i]) >> 15;</p><p>145</p><p>146 dec->filtval = dec->vector[0];</p><p>147 }</p><p>148</p><p>149 static void truespeech_filters_merge(TSContext *dec)</p><p>150 {</p><p>151 int i;</p><p>152</p><p>153 if (!dec->flag)</p><table><thead><tr><th>154</th><th>{</th><th></th></tr></thead><tbody><tr><td>155</td><td></td><td>for (i = 0; i &lt; 8; i++)</td></tr><tr><td>156</td><td></td><td>{</td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>157 dec->filters[i + 0] = dec->prevfilt[i];</p><p>158 dec->filters[i + 8] = dec->prevfilt[i];</p><p>159 }</p><p>160 }</p><p>161 else</p><p>162 {</p><p>163 for (i = 0; i &lt; 8; i++)</p><p>164 {</p><p>165 dec->filters[i + 0] = (dec->cvector[i] *21846+dec->prevfilt[i] *10923+16384) >></p><p>15;</p><p>166 dec->filters[i + 8] = (dec->cvector[i] *10923+dec->prevfilt[i] *21846+16384) >></p><p>15;</p><p>167 }</p><p>168 }</p><p>169 for (i = 0; i &lt; 8; i++)</p><p>170 {</p><p>171 dec->filters[i + 16] = dec->cvector[i];</p><p>172 dec->filters[i + 24] = dec->cvector[i];</p><p>173 }</p><p>174 }</p><p>175</p><p>176 static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)</p><p>177 {</p><p>178 int16_t tmp[146+60], *ptr0, *ptr1, *filter;</p><p>179 int i, t, off;</p><p>180</p><p>181 t = dec->offset2[quart];</p><p>182 if (t == 127)</p><p>183 {</p><p>184 memset(dec->newvec, 0, 60 *2);</p><p>185 return ;</p><p>186 }</p><p>187</p><p>188 for (i = 0; i &lt; 146; i++)</p><p>189 tmp[i] = dec->filtbuf[i];</p><p>190</p><p>191 off = (t / 25) + dec->offset1[quart >> 1] + 18;</p><p>192 ptr0 = tmp + 145-off;</p><p>193 ptr1 = tmp + 146;</p><p>194 filter = (int16_t*)ts_240 + (t % 25) *2;</p><p>195 for (i = 0; i &lt; 60; i++)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>196 {</p><p>197 t = (ptr0[0] *filter[0] + ptr0[1] *filter[1] + 0x2000) >> 14;</p><p>198 ptr0++;</p><p>199 dec->newvec[i] = t;</p><p>200 ptr1[i] = t;</p><p>201 }</p><p>202 }</p><p>203</p><p>204 static void truespeech_place_pulses(TSContext *dec, int16_t *out, int quart)</p><p>205 {</p><p>206 int16_t tmp[7];</p><p>207 int i, j, t;</p><p>208 int16_t *ptr1, *ptr2;</p><p>209 int coef;</p><p>210</p><p>211 memset(out, 0, 60 *2);</p><p>212 for (i = 0; i &lt; 7; i++)</p><p>213 {</p><p>214 t = dec->pulseval[quart] &amp;3;</p><p>215 dec->pulseval[quart] >>= 2;</p><p>216 tmp[6-i] = ts_562[dec->pulseoff[quart] *4+t];</p><p>217 }</p><p>218</p><p>219 coef = dec->pulsepos[quart] >> 15;</p><p>220 ptr1 = (int16_t*)ts_140 + 30;</p><p>221 ptr2 = tmp;</p><p>222 for (i = 0, j = 3; (i &lt; 30) && (j > 0); i++)</p><p>223 {</p><p>224 t = *ptr1++;</p><p>225 if (coef >= t)</p><p>226 coef -= t;</p><p>227 else</p><p>228 {</p><p>229 out[i] = *ptr2++;</p><p>230 ptr1 += 30;</p><p>231 j--;</p><p>232 }</p><p>233 }</p><p>234 coef = dec->pulsepos[quart] &amp;0x7FFF;</p><p>235 ptr1 = (int16_t*)ts_140;</p><p>236 for (i = 30, j = 4; (i &lt; 60) && (j > 0); i++)</p><table><thead><tr><th>237</th><th>{</th><th></th></tr></thead><tbody><tr><td>238</td><td></td><td>t = *ptr1++;</td></tr><tr><td>239</td><td></td><td>if (coef >= t)</td></tr><tr><td>240 coef -= t;</td><td></td><td></td></tr></tbody></table><p>241 else</p><p>242 {</p><p>243 out[i] = *ptr2++;</p><p>244 ptr1 += 30;</p><p>245 j--;</p><p>246 }</p><p>247 }</p><p>248 }</p><p>249</p><p>250 static void truespeech_update_filters(TSContext *dec, int16_t *out, int quart)</p><p>251 {</p><p>252 int i;</p><p>253</p><p>254 for (i = 0; i &lt; 86; i++)</p><p>255 dec->filtbuf[i] = dec->filtbuf[i + 60];</p><p>256</p><p>257 for (i = 0; i &lt; 60; i++)</p><p>258 {</p><p>259 dec->filtbuf[i + 86] = out[i] + dec->newvec[i] - (dec->newvec[i] >> 3);</p><p>260 out[i] += dec->newvec[i];</p><p>261 }</p><p>262 }</p><p>263</p><p>264 static void truespeech_synth(TSContext *dec, int16_t *out, int quart)</p><p>265 {</p><p>266 int i, k;</p><p>267 int t[8];</p><p>268 int16_t *ptr0, *ptr1;</p><p>269</p><p>270 ptr0 = dec->tmp1;</p><p>271 ptr1 = dec->filters + quart * 8;</p><p>272 for (i = 0; i &lt; 60; i++)</p><p>273 {</p><p>274 int sum = 0;</p><p>275 for (k = 0; k &lt; 8; k++)</p><p>276 sum += ptr0[k] *ptr1[k];</p><p>277 sum = (sum + (out[i] &lt;&lt; 12) + 0x800) >> 12;</p><table><thead><tr><th>278</th><th></th><th>out[i] = clip(sum, - 0x7FFE, 0x7FFE);</th></tr></thead><tbody><tr><td>279</td><td></td><td>for (k = 7; k > 0; k--)</td></tr><tr><td>280</td><td></td><td>ptr0[k] = ptr0[k - 1];</td></tr><tr><td>281</td><td></td><td>ptr0[0] = out[i];</td></tr><tr><td>282</td><td>}</td><td></td></tr><tr><td>283</td><td></td><td></td></tr><tr><td>284 for (i = 0; i &lt; 8; i++)</td><td></td><td></td></tr></tbody></table><p>285 t[i] = (ts_5E2[i] *ptr1[i]) >> 15;</p><p>286</p><p>287 ptr0 = dec->tmp2;</p><p>288 for (i = 0; i &lt; 60; i++)</p><p>289 {</p><p>290 int sum = 0;</p><p>291 for (k = 0; k &lt; 8; k++)</p><p>292 sum += ptr0[k] *t[k];</p><p>293 for (k = 7; k > 0; k--)</p><p>294 ptr0[k] = ptr0[k - 1];</p><p>295 ptr0[0] = out[i];</p><p>296 out[i] = ((out[i] &lt;&lt; 12) - sum) >> 12;</p><p>297 }</p><p>298</p><p>299 for (i = 0; i &lt; 8; i++)</p><p>300 t[i] = (ts_5F2[i] *ptr1[i]) >> 15;</p><p>301</p><p>302 ptr0 = dec->tmp3;</p><p>303 for (i = 0; i &lt; 60; i++)</p><p>304 {</p><p>305 int sum = out[i] &lt;&lt; 12;</p><p>306 for (k = 0; k &lt; 8; k++)</p><p>307 sum += ptr0[k] *t[k];</p><p>308 for (k = 7; k > 0; k--)</p><p>309 ptr0[k] = ptr0[k - 1];</p><p>310 ptr0[0] = clip((sum + 0x800) >> 12, - 0x7FFE, 0x7FFE);</p><p>311</p><p>312 sum = ((ptr0[1]*(dec->filtval - (dec->filtval >> 2))) >> 4) + sum;</p><p>313 sum = sum - (sum >> 3);</p><p>314 out[i] = clip((sum + 0x800) >> 12, - 0x7FFE, 0x7FFE);</p><p>315 }</p><p>316 }</p><p>317</p><p>318 static void truespeech_save_prevvec(TSContext *c)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>319 {</p><p>320 int i;</p><p>321</p><p>322 for (i = 0; i &lt; 8; i++)</p><p>323 c->prevfilt[i] = c->cvector[i];</p><p>324 }</p><p>325</p><p>326 int truespeech_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)</p><p>327 {</p><p>328 TSContext *c = avctx->priv_data;</p><p>329</p><p>330 int i;</p><p>331 short *samples = data;</p><p>332 int consumed = 0;</p><p>333 int16_t out_buf[240];</p><p>334</p><p>335 if (!buf_size)</p><p>336 return 0;</p><p>337</p><p>338 while (consumed &lt; buf_size)</p><p>339 {</p><p>340 truespeech_read_frame(c, buf + consumed);</p><p>341 consumed += 32;</p><p>342</p><p>343 truespeech_correlate_filter(c);</p><p>344 truespeech_filters_merge(c);</p><p>345</p><p>346 memset(out_buf, 0, 240 *2);</p><p>347 for (i = 0; i &lt; 4; i++)</p><p>348 {</p><p>349 truespeech_apply_twopoint_filter(c, i);</p><p>350 truespeech_place_pulses(c, out_buf + i * 60, i);</p><p>351 truespeech_update_filters(c, out_buf + i * 60, i);</p><p>352 truespeech_synth(c, out_buf + i * 60, i);</p><p>353 }</p><p>354</p><p>355 truespeech_save_prevvec(c);</p><p>356</p><p>357 for (i = 0; i &lt; 240; i++) // finally output decoded frame</p><p>358 *samples++ = out_buf[i];</p><p>359<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>360 }</p><p>361</p><p>362 *data_size = consumed * 15;</p><p>363</p><p>364 return buf_size;</p><p>365 }</p><p>366</p><p>367 AVCodec truespeech_decoder =</p><p>368 {</p><p>369 "truespeech",</p><p>370 CODEC_TYPE_AUDIO,</p><p>371 CODEC_ID_TRUESPEECH,</p><p>372 sizeof(TSContext),</p><p>373 truespeech_decode_init,</p><p>374 NULL,</p><p>375 NULL,</p><p>376 truespeech_decode_frame,</p><p>377 };</p><h2 id=53-libavformat容器模块><strong>5.3 libavformat容器模块</strong></h2><h3 id=1-文件列表-2><strong>1 文件列表</strong></h3><table><thead><tr><th>文件类型</th><th>文件名</th><th>大小(bytes)</th></tr></thead><tbody><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>avformat.h</td><td>5352</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>allformats.c</td><td>299</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>cutils.c</td><td>606</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>file.c</td><td>1504</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.029.png alt></td><td>avio.h</td><td>3103</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>avio.c</td><td>2286</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>aviobuf.c</td><td>6887</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>utils_format.c</td><td>7662</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.040.png alt></td><td>avidec.c</td><td>21713</td></tr></tbody></table><h3 id=2-avformath-文件><strong>2 avformat.h 文件</strong></h3><p>2.1 功能描述</p><p>定义识别文件格式和媒体类型库使用的宏、数据结构和函数，通常这些宏、数据结构和函数在此模块内相 对全局有效。</p><p>2.2 文件注释</p><p>1 #ifndef AVFORMAT_H</p><p>2 #define AVFORMAT_H</p><p>3</p><p>4 #ifdef cplusplus</p><p>5 extern "C"</p><p>6 {</p><p>7 #endif</p><p>8</p><p>9 #define LIBAVFORMAT_VERSION_INT ((50&lt;&lt;16)+(4&lt;&lt;8)+0)</p><p>10 #define LIBAVFORMAT_VERSION 50.4.0</p><p>11 #define LIBAVFORMAT_BUILD LIBAVFORMAT_VERSION_INT</p><p>12</p><p>13 #define LIBAVFORMAT_IDENT "Lavf" AV_STRINGIFY(LIBAVFORMAT_VERSION)</p><p>14</p><p>15 #include "../libavcodec/avcodec.h"</p><p>16 #include "avio.h"</p><p>17<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.062.png alt></p><p>一些简单的宏定义</p><p>18 #define AVERROR_UNKNOWN (-1) // unknown error</p><p>19 #define AVERROR_IO (-2) // i/o error</p><p>20 #define AVERROR_NUMEXPECTED (-3) // number syntax expected in filename</p><p>21 #define AVERROR_INVALIDDATA (-4) // invalid data found</p><p>22 #define AVERROR_NOMEM (-5) // not enough memory</p><p>23 #define AVERROR_NOFMT (-6) // unknown format</p><p>24 #define AVERROR_NOTSUPP (-7) // operation not supported</p><p>25</p><p>26 #define AVSEEK_FLAG_BACKWARD 1 // seek backward</p><p>27 #define AVSEEK_FLAG_BYTE 2 // seeking based on position in bytes</p><p>28 #define AVSEEK_FLAG_ANY 4 // seek to any frame, even non keyframes</p><p>29</p><p>30 #define AVFMT_NOFILE 0x0001 // no file should be opened</p><p>31</p><p>32 #define PKT_FLAG_KEY 0x0001</p><p>33</p><p>34 #define AVINDEX_KEYFRAME 0x0001</p><p>35</p><p>36 #define AVPROBE_SCORE_MAX 100</p><p>37</p><p>38 #define MAX_STREAMS 20</p><p>39</p><p>音视频数据包定义，在瘦身后的 ffplay 中，每一个包是一个完整的数据帧。注意保存音视频数据包的内存</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.063.png alt>是 malloc 出来的，用完后应及时用 free 归还给系统。</p><p>40 typedef struct AVPacket</p><p>41 {</p><p>42 int64_t pts; // presentation time stamp in time_base units // 表示时间，对视频是显示时间</p><p>43 int64_t dts; // decompression time stamp in time_base units// 解码时间，这个不是很重要</p><p>44 int64_t pos; // byte position in stream, -1 if unknown</p><p>45 uint8_t *data; // 实际保存音视频数据缓存的首地址</p><p>46 int size; // 实际保存音视频数据缓存的大小</p><p>47 int stream_index; // 当前音视频数据包对应的流索引，在本例中用于区别音频还是视频。</p><p>48 int flags; // 数据包的一些标记，比如是否是关键帧等。</p><p>49 void(*destruct)(struct AVPacket*);</p><p>50 } AVPacket;</p><p>51</p><p>音视频数据包链表定义，注意每一个 AVPacketList 仅含有一个 AVPacket，和传统的很多很多节点的 list</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.063.png alt>不同，不要被 list 名字迷惑。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>52 typedef struct AVPacketList</p><p>53 {</p><p>54 AVPacket pkt;</p><p>55 struct AVPacketList *next; // 用于把各个 AVPacketList 串联起来。</p><p>56 } AVPacketList;</p><p>57<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.064.png alt></p><p>释放掉音视频数据包占用的内存，把首地址置空是一个很好的习惯。</p><p>58 static inline void av_destruct_packet(AVPacket *pkt)</p><p>59 {</p><p>60 av_free(pkt->data);</p><p>61 pkt->data = NULL;</p><p>62 pkt->size = 0;</p><p>63 }</p><p>64<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>判断一些指针，中转一下，释放掉音视频数据包占用的内存。</p><p>65 static inline void av_free_packet(AVPacket *pkt)</p><p>66 {</p><p>67 if (pkt && pkt->destruct)</p><p>68 pkt->destruct(pkt);</p><p>69 }</p><p>70<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.066.png alt></p><p>读文件往数据包中填数据，注意程序跑到这里时，文件偏移量已确定，要读数据的大小也确定，但是</p><p>数据包的缓存没有分配。分配好内存后，要初始化包的一些变量。</p><p>71 static inline int av_get_packet(ByteIOContext *s, AVPacket *pkt, int size)</p><p>72 {</p><p>73 int ret;</p><p>74 unsigned char *data;</p><p>75 if ((unsigned)size > (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE)</p><p>76 return AVERROR_NOMEM;</p><p>77<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>分配数据包缓存</p><p>78 data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);</p><p>79 if (!data)</p><p>80 return AVERROR_NOMEM;</p><p>81<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.064.png alt></p><p>把数据包中 pad 部分清 0，这是一个很好的习惯。 缓存清 0 不管在什么情况下都是好习惯。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>82 memset(data + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);</p><p>83<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.064.png alt></p><p>设置 AVPacket 其他的成员变量，能确定的就赋确定值，不能确定的赋初值。</p><p>84 pkt->pts = AV_NOPTS_VALUE;</p><p>85 pkt->dts = AV_NOPTS_VALUE;</p><p>86 pkt->pos = - 1;</p><p>87 pkt->flags = 0;</p><p>88 pkt->stream_index = 0;</p><p>89 pkt->data = data;</p><p>90 pkt->size = size;</p><p>91 pkt->destruct = av_destruct_packet;</p><p>92</p><p>93 pkt->pos = url_ftell(s);</p><p>94<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>实际读广义文件填充数据包，如果读文件错误时通常是到了末尾，要归还刚刚 malloc 出来的内存。</p><p>95 ret = url_fread(s, pkt->data, size);</p><p>96 if (ret &lt;= 0)</p><p>97 av_free_packet(pkt);</p><p>98 else</p><p>99 pkt->size = ret;</p><p>100</p><p>101 return ret;</p><p>102 }</p><p>103<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.067.png alt></p><p>为识别文 件格 式， 要读 一部 分文 件头数 据来 分析 匹配 ffplay 支持的文 件格 式文 件特 征。 于是</p><p>AVProbeData 结构就定义了文件名，首地址和大小。此处的读独立于其他文件操作。</p><p>104 typedef struct AVProbeData</p><p>105 {</p><p>106 const char *filename;</p><p>107 unsigned char *buf;</p><p>108 int buf_size;</p><p>109 } AVProbeData;</p><p>110<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>文件索引结构，flags 和 size 位定义是为了节省内存。</p><p>111 typedef struct AVIndexEntry</p><p>112 {</p><p>113 int64_t pos;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>114 int64_t timestamp;</p><p>115 int flags: 2;</p><p>116 int size: 30;</p><p>117 } AVIndexEntry;</p><p>118<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>AVStream 抽象的表示一个媒体流，定义了所有媒体一些通用的属性。</p><p>119 typedef struct AVStream</p><p>120 {</p><p>121 AVCodecContext *actx;// 关联到解码器//codec context,change from AVCodecContext *codec;</p><p>122</p><p>123 void *priv_data; // 在本例中，关联到 AVIStream</p><p>124</p><p>125 AVRational time_base; // 由 av_set_pts_info()函数初始化</p><p>126</p><p>127 AVIndexEntry *index_entries; // only used if the format does not support seeking natively</p><p>128 int nb_index_entries;</p><p>129 int index_entries_allocated_size;</p><p>130</p><p>131 double frame_last_delay; // 帧最后延迟</p><p>132 } AVStream;</p><p>133<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.064.png alt></p><p>AVFormatParameters 结构在瘦身后的 ffplay 中没有实际意义，为保证函数接口不变，没有删除。</p><p>134 typedef struct AVFormatParameters</p><p>135 {</p><p>136 int dbg; //only for debug</p><p>137 } AVFormatParameters;</p><p>138</p><p>AVInputFormat 定义输入文件容器格式，着重于功能函数，一种文件容器格式对应一个 AVInputFormat</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.068.png alt>结构，在程序运行时有多个实例，但瘦身后 ffplay 仅一个实例。</p><p>139 typedef struct AVInputFormat</p><p>140 {</p><p>141 const char *name; // 文件容器格式名，用于人性化阅读，维护代码</p><p>142</p><p>143 int priv_data_size; // 程序运行时，文件容器格式对应的上下文结构大小，便于内存分配。</p><p>144</p><p>145 int(*read_probe)(AVProbeData*); // 功能性函数</p><p>146</p><p>147 int(*read_header)(struct AVFormatContext *, AVFormatParameters *ap);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>148</p><p>149 int(*read_packet)(struct AVFormatContext *, AVPacket *pkt);</p><p>150</p><p>151 int(*read_close)(struct AVFormatContext*);</p><p>152</p><p>153 const char *extensions; // 此种文件容器格式对应的文件扩展名，识别文件格式的最后办法。</p><p>154</p><p>155 struct AVInputFormat *next; // 用于把 ffplay 支持的所有文件容器格式链成一个链表。</p><p>156</p><p>157 } AVInputFormat;</p><p>158</p><p>AVFormatContext 结构表示程序运行的当前文件容器格式使用的上下文，着重于所有文件容器共有的属</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.068.png alt>性，程序运行后仅一个实例。</p><p>159 typedef struct AVFormatContext // format I/O context</p><p>160 {</p><p>161 struct AVInputFormat *iformat; // 关联程序运行时，实际的文件容器格式指针。</p><p>162</p><p>163 void *priv_data; // 关联具体文件容器格式上下文的指针，在本例中是 AVIContext</p><p>164</p><p>165 ByteIOContext pb; // 关联广义输入文件</p><p>166</p><p>167 int nb_streams; // 广义输入文件中媒体流计数</p><p>168</p><p>169 AVStream *streams[MAX_STREAMS];// 关联广义输入文件中的媒体流</p><p>170</p><p>171 } AVFormatContext;</p><p>172<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.065.png alt></p><p>相关函数说明参考相应的 c 实现文件。</p><p>173 int avidec_init(void);</p><p>174</p><p>175 void av_register_input_format(AVInputFormat *format);</p><p>176</p><p>177 void av_register_all(void);</p><p>178</p><p>179 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);</p><p>180 int match_ext(const char *filename, const char *extensions);</p><p>181</p><p>182 int av_open_input_stream(AVFormatContext **ic_ptr, ByteIOContext *pb, const char *filename,</p><p>183 AVInputFormat *fmt, AVFormatParameters *ap);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>184</p><p>185 int av_open_input_file(AVFormatContext **ic_ptr, const char *filename, AVInputFormat *fmt,</p><p>186 int buf_size, AVFormatParameters *ap);</p><p>187</p><p>188 int av_read_frame(AVFormatContext *s, AVPacket *pkt);</p><p>189 int av_read_packet(AVFormatContext *s, AVPacket *pkt);</p><p>190 void av_close_input_file(AVFormatContext *s);</p><p>191 AVStream *av_new_stream(AVFormatContext *s, int id);</p><p>192 void av_set_pts_info(AVStream *s, int pts_wrap_bits, int pts_num, int pts_den);</p><p>193</p><p>194 int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);</p><p>195 int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags);</p><p>196</p><p>197 int strstart(const char *str, const char *val, const char **ptr);</p><p>198 void pstrcpy(char *buf, int buf_size, const char *str);</p><p>199</p><p>200 #ifdef cplusplus</p><p>201 }</p><p>202</p><p>203 #endif</p><p>204</p><p>205 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=3-allformatc-文件><strong>3 allformat.c 文件</strong></h3><p>3.1 功能描述</p><p>简单的注册/初始化函数，把相应的协议，文件格式，解码器等用相应的链表串起来便于查找。</p><p>3.2 文件注释</p><p>1 #include "avformat.h"</p><p>2</p><p>3 extern URLProtocol file_protocol;</p><p>4</p><p>5 void av_register_all(void)</p><p>6 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.069.png alt></p><p>7 到 11 行，in ited 变量声明成 static ，做一下比较是为了避免此函数多次调用。</p><p>编程基本原则之一，初始化函数只调用一次，不能随意多次调用。</p><p>7 static int inited = 0;</p><p>8</p><p>9 if (inited != 0)</p><p>10 return ;</p><p>11 inited = 1;</p><p>12<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.070.png alt></p><p>ffplay 把 CPU 当做一个广义的 DSP。有些计算可以用 CPU 自带的加速指令来优化，ffplay 把这类函数</p><p>独立出来放到 dsputil.h 和 dsputil.c 文件中，用函数指针的方法映射到各个 CPU 具体的加速优化实现函数， 此处初始化这些函数指针。</p><p>13 avcodec_init();</p><p>14<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.071.png alt></p><p>把所有的解码器用链表的方式都串连起来，链表头指针是 first_avcodec。</p><p>15 avcodec_register_all()</p><p>16<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.071.png alt></p><p>把所有的输入文件格式用链表的方式都串连起来，链表头指针是 first_iformat。</p><p>17 avidec_init();</p><p>18<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.071.png alt></p><p>把所有的输入协议用链表的方式都串连起来，比如 tcp/udp/file 等，链表头指针是 first_protocol。</p><p>19 register_protocol(&file_protocol);</p><p>20 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=4-cutilsc-文件><strong>4 cutils.c 文件</strong></h3><p>4.1 功能描述</p><p>ffplay 文件格式分析模块使用的两个工具类函数，都是对字符串的操作。</p><p>4.2 文件注释</p><p>1 #include "avformat.h"</p><p>2</p><p>strstart 实际的功能就是在 str 字符串中搜索 val 字符串指示的头，并且去掉头后用*ptr 返回。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.072.png alt>在本例中，在播本地文件时，在命令行输入时可能会在文件路径名前加前缀"file:", 为调用系统的 open</p><p>函数，需要把这几个前导字符去掉，仅仅传入完整有效的文件路径名。 和 rtsp://等网络协议相对应，播本地文件时应加 file:前缀。</p><p>3 int strstart(const char *str, const char *val, const char **ptr)</p><p>4 {</p><p>5 const char *p, *q;</p><p>6 p = str;</p><p>7 q = val;</p><p>8 while (*q != '\0')</p><p>9 {</p><p>10 if (*p != *q)</p><p>11 return 0;</p><p>12 p++;</p><p>13 q++;</p><p>14 }</p><p>15 if (ptr)</p><p>16 *ptr = p;</p><p>17 return 1;</p><p>18 }</p><p>19<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.073.png alt></p><p>字符串拷贝函数，拷贝的字符数由 buf_size 指定，更安全的字符串拷贝操作。</p><p>传统的 strcpy()函数是拷贝一个完整的字符串，如果目标字符串缓冲区小于源字符串长度，那么就会 发生缓冲区溢出导致错误，并且这种错误很难发现。</p><p>20 void pstrcpy(char *buf, int buf_size, const char *str)</p><p>21 {</p><p>22 int c;</p><p>23 char *q = buf;</p><p>24</p><p>25 if (buf_size &lt;= 0)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>26 return ;</p><p>27</p><p>28 for (;;)</p><p>29 {</p><p>30 c = *str++;</p><p>31 if (c == 0 || q >= buf + buf_size - 1)</p><p>32 break;</p><p>33 *q++ = c;</p><p>34 }</p><p>35 *q = '\0';</p><p>36 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=5-filec-文件><strong>5 file.c 文件</strong></h3><p>5.1 功能描述</p><p>ffplay 把 file 当做类似于 rtsp，rtp，tcp 等协议的一种协议，用 file:前缀标示 file 协议。 URLContext 结构抽象统一表示这些广义上的协议，对外提供统一的抽象接口。 各具体的广义协议实现文件实现 URLContext 接口。此文件实现了 file 广义协议的 URLContext 接口。</p><p>5.2 文件注释</p><p>1 #include "../berrno.h"</p><p>2</p><p>3 #include "avformat.h"</p><p>4 #include &lt;fcntl.h></p><p>5</p><p>6 #ifndef CONFIG_WIN32</p><p>7 #include &lt;unistd.h></p><p>8 #include &lt;sys/ioctl.h></p><p>9 #include &lt;sys/time.h></p><p>10 #else</p><p>11 #include &lt;io.h></p><p>12 #define open(fname,oflag,pmode) _open(fname,oflag,pmode)</p><p>13 #endif</p><p>14<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.074.png alt></p><p>打开本地媒体文件，把本地文件句柄作为广义文件句柄存放在 priv_data 中。</p><p>15 static int file_open(URLContext *h, const char *filename, int flags)</p><p>16 {</p><p>17 int access;</p><p>18 int fd;</p><p>19<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt></p><p>规整本地路径文件名，去掉前面可能的"file:" 字符串。ffplay 把本地文件看做广义 URL 协议。</p><p>20 strstart(filename, "file:", &filename);</p><p>21<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt></p><p>设置本地文件存取属性。</p><p>22 if (flags &URL_RDWR)</p><p>23 access = O_CREAT | O_TRUNC | O_RDWR;</p><p>24 else if (flags &URL_WRONLY)</p><p>25 access = O_CREAT | O_TRUNC | O_WRONLY;</p><p>26 else</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>27 access = O_RDONLY;</p><p>28 #if defined(CONFIG_WIN32) || defined(CONFIG_OS2) || defined( CYGWIN )</p><p>29 access |= O_BINARY;</p><p>30 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt></p><p>调用 open()打开本地文件，并把本地文件句柄作为广义的 URL 句柄存放在 priv_data 变量中。</p><table><thead><tr><th>31</th><th></th><th>fd = open(filename, access, 0666);</th></tr></thead><tbody><tr><td>32</td><td></td><td>if (fd &lt; 0)</td></tr><tr><td>33</td><td></td><td>return - ENOENT;</td></tr><tr><td>34</td><td></td><td>h->priv_data = (void*)(size_t)fd;</td></tr><tr><td>35</td><td></td><td>return 0;</td></tr><tr><td>36</td><td>}</td><td></td></tr><tr><td>37</td><td></td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt>转换广义 URL 句柄为本地文件句柄，调用 read()函数读本地文件。</td><td></td><td></td></tr></tbody></table><p>38 static int file_read(URLContext *h, unsigned char *buf, int size)</p><p>39 {</p><p>40 int fd = (size_t)h->priv_data;</p><p>41 return read(fd, buf, size);</p><p>42 }</p><p>43<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.074.png alt></p><p>转换广义 URL 句柄为本地文件句柄，调用 w ite()函数写本地文件，本播放器没实际使用此函数。</p><p>44 static int file_write(URLContext *h, unsigned char *buf, int size)</p><p>45 {</p><p>46 int fd = (size_t)h->priv_data;</p><p>47 return write(fd, buf, size);</p><p>48 }</p><p>49<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt></p><p>转换广义 URL 句柄为本地文件句柄，调用 lseek()函数设置本地文件读指针。</p><p>50 static offset_t file_seek(URLContext *h, offset_t pos, int whence)</p><p>51 {</p><p>52 int fd = (size_t)h->priv_data;</p><p>53 return lseek(fd, pos, whence);</p><p>54 }</p><p>55<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.075.png alt></p><p>转换广义 URL 句柄为本地文件句柄，调用 close()函数关闭本地文件。</p><p>56 static int file_close(URLContext *h)</p><p>57 {</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>58 int fd = (size_t)h->priv_data;</p><p>59 return close(fd);</p><p>60 }</p><p>61<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.074.png alt></p><p>用 file 协议相应函数初始化 URLProtocol 结构。</p><p>62 URLProtocol file_protocol =</p><p>63 {</p><p>64 "file",</p><p>65 file_open,</p><p>66 file_read,</p><p>67 file_write,</p><p>68 file_seek,</p><p>69 file_close,</p><p>70 };<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=6-avioh-文件><strong>6 avio.h 文件</strong></h3><p>6.1 功能描述</p><p>文件读写模块定义的数据结构和函数声明，ffplay 把这些全部放到这个.h 文件中。</p><p>6.2 文件注释</p><p>1 #ifndef AVIO_H</p><p>2 #define AVIO_H</p><p>3</p><p>4 #define URL_EOF (-1)</p><p>5</p><p>6 typedef int64_t offset_t;</p><p>7<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.076.png alt></p><p>简单的文件存取宏定义</p><p>8 #define URL_RDONLY 0</p><p>9 #define URL_WRONLY 1</p><p>10 #define URL_RDWR 2</p><p>11<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.077.png alt></p><p>URLContex t 结构表示程序运行的当前广义文件协议使用的上下文，着重于所有广义文件协议共有的 属性(并且是在程序运行时才能确定其值)和关联其他结构的字段。</p><p>12 typedef struct URLContext</p><p>13 {</p><p>14 struct URLProtocol *prot; // 关联相应的广义输入文件协议。</p><p>15 int flags;</p><p>16 int max_packet_size; // 如果非 0，表示最大包大小，用于分配足够的缓存。</p><p>17 void *priv_data; // 在本例中，关联一个文件句柄</p><p>18 char filename[1]; // 在本例中，存取本地文件名，filename 仅指示本地文件名首地址。</p><p>19 } URLContext;</p><p>20<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.078.png alt></p><p>URLProtocol 定义广义的文件协议，着重于功能函数，一种广义的文件协议对应一个 URLProtocol 结 构，本例删掉了 pipe，udp，tcp 等输入协议，仅保留一个 file 协议。</p><p>21 typedef struct URLProtocol</p><p>22 {</p><p>23 const char *name; // 协议文件名，便于人性化阅读理解。</p><p>24 int(*url_open)(URLContext *h, const char *filename, int flags);</p><p>25 int(*url_read)(URLContext *h, unsigned char *buf, int size);</p><p>26 int(*url_write)(URLContext *h, unsigned char *buf, int size);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>27 offset_t(*url_seek)(URLContext *h, offset_t pos, int whence);</p><p>28 int(*url_close)(URLContext *h);</p><p>29 struct URLProtocol *next; // 把所有支持的输入协议串链起来，便于遍历查找。</p><p>30 } URLProtocol;</p><p>31</p><p>ByteIOCon tex t 结构扩展 URLProtocol 结构成内部有缓冲机制的广泛意义上的文件，改善广义输入</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.080.png alt></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.079.png alt>文件的 IO 性能。 主要变量间的逻辑位置关系简单示意如下：</p><p>32 typedef struct ByteIOContext</p><p>33 {</p><p>34 unsigned char *buffer; // 缓存首地址</p><p>35 int buffer_size; // 缓存大小</p><p>36 unsigned char *buf_ptr, *buf_end; // 缓存读指针和末指针</p><p>37 void *opaque; // 指向 URLContext 结构的指针，便于跳转</p><p>38 int(*read_packet)(void *opaque, uint8_t *buf, int buf_size);</p><p>39 int(*write_packet)(void *opaque, uint8_t *buf, int buf_size);</p><p>40 offset_t(*seek)(void *opaque, offset_t offset, int whence);</p><p>41 offset_t pos; // position in the file of the current buffer</p><p>42 int must_flush; // true if the next seek should flush</p><p>43 int eof_reached; // true if eof reached</p><p>44 int write_flag; // true if open for writing</p><p>45 int max_packet_size; // 如果非 0，表示最大数据帧大小，用于分配足够的缓存。</p><p>46 int error; // contains the error code or 0 if no error happened</p><p>47 } ByteIOContext;</p><p>48</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.081.png alt>相关函数说明参考相应的 c 实现文件。</p><p>49 int url_open(URLContext **h, const char *filename, int flags);</p><p>50 int url_read(URLContext *h, unsigned char *buf, int size);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>51 int url_write(URLContext *h, unsigned char *buf, int size);</p><p>52 offset_t url_seek(URLContext *h, offset_t pos, int whence);</p><p>53 int url_close(URLContext *h);</p><p>54 int url_get_max_packet_size(URLContext *h);</p><p>55</p><p>56 int register_protocol(URLProtocol *protocol);</p><p>57</p><p>58 int init_put_byte(ByteIOContext *s,</p><p>59 unsigned char *buffer,</p><p>60 int buffer_size,</p><p>61 int write_flag,</p><p>62 void *opaque,</p><p>63 int(*read_buf)(void *opaque, uint8_t *buf, int buf_size),</p><p>64 int(*write_buf)(void *opaque, uint8_t *buf, int buf_size),</p><p>65 offset_t(*seek)(void *opaque, offset_t offset, int whence));</p><p>66</p><p>67 offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence);</p><p>68 void url_fskip(ByteIOContext *s, offset_t offset);</p><p>69 offset_t url_ftell(ByteIOContext *s);</p><p>70 offset_t url_fsize(ByteIOContext *s);</p><p>71 int url_feof(ByteIOContext *s);</p><p>72 int url_ferror(ByteIOContext *s);</p><p>73</p><p>74 int url_fread(ByteIOContext *s, unsigned char *buf, int size); // get_buffer</p><p>75 int get_byte(ByteIOContext *s);</p><p>76 unsigned int get_le32(ByteIOContext *s);</p><p>77 unsigned int get_le16(ByteIOContext *s);</p><p>78</p><p>79 int url_setbufsize(ByteIOContext *s, int buf_size);</p><p>80 int url_fopen(ByteIOContext *s, const char *filename, int flags);</p><p>81 int url_fclose(ByteIOContext *s);</p><p>82</p><p>83 int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags);</p><p>84 int url_close_buf(ByteIOContext *s);</p><p>85</p><p>86 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=7-avioc-文件><strong>7 avio.c 文件</strong></h3><p>7.1 功能描述</p><p>此文件实现了 URLProtocol 抽象层广义文件操作函数，由于 URLProtocol 是底层其他具体文件 (file,pipe 等)</p><p>的简单封装，这一层只是一个中转站，大部分函数都是简单中转到底层的具体实现函数。</p><p>7.2 文件注释</p><p>1 #include "../berrno.h"</p><p>2 #include "avformat.h"</p><p>3</p><p>4 URLProtocol *first_protocol = NULL;</p><p>5</p><p>ffplay 抽象底层的 file ，pipe 等为 URLProtocol，然后把这些 URLProtocol 串联起来做成链表，便于查找 。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.082.png alt>register_protocol 实际就是串联的各个 URLProtocol，全局表头为 first_protocol。</p><p>6 int register_protocol(URLProtocol *protocol)</p><p>7 {</p><p>8 URLProtocol **p;</p><p>9 p = &first_protocol;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.083.png alt></p><p>移动指针到 URLProtocol 链表末尾。</p><p>10 while (*p != NULL)</p><p>11 p = &(*p)->next;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.084.png alt></p><p>在 URLProtocol 链表末尾直接挂接当前的 URLProtocol 指针。</p><p>12 *p = protocol;</p><p>13 protocol->next = NULL;</p><p>14 return 0;</p><p>15 }</p><p>16<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.085.png alt></p><p>打开广义输入文件。此函数主要有三部分逻辑，首先从文件路径名中分离出协议字符串到 proto_str</p><p>字符数组中，接着遍历 URLProtocol 链表查找匹配 proto_str 字符数组中的字符串来确定使用的协议，最 后调用相应的文件协议的打开函数打开输入文件。</p><p>17 int url_open(URLContext **puc, const char *filename, int flags)</p><p>18 {</p><p>19 URLContext *uc;</p><p>20 URLProtocol *up;</p><p>21 const char *p;</p><p>22 char proto_str[128], *q;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>23 int err;</p><p>24</p><p>以冒号和结束符作为边界从文件名中分离出的协议字符串到 proto_str 字符数组。由于协议只能是字符 ，</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.086.png alt>所以在边界前识别到非字符就断定是 file。</p><p>25 p = filename;</p><p>26 q = proto_str;</p><p>27 while (*p != '\0' && *p != ':')</p><p>28 {</p><p>29 if (!isalpha(*p)) // protocols can only contain alphabetic chars</p><p>30 goto file_proto;</p><p>31 if ((q - proto_str) &lt; sizeof(proto_str) - 1)</p><p>32 *q++ = *p;</p><p>33 p++;</p><p>34 }</p><p>35<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.087.png alt></p><p>如果协议字符串只有一个字符，我们就认为是 w indow s 下的逻辑盘符，断定是 file 。</p><p>36 if (*p == '\0' || (q - proto_str) &lt;= 1)</p><p>37 {</p><p>38 file_proto:</p><p>39 strcpy(proto_str, "file");</p><p>40 }</p><p>41 else</p><p>42 {</p><p>43 *q = '\0';</p><p>44 }</p><p>45<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.087.png alt></p><p>遍历 URLProtocol 链表匹配使用的协议，如果没有找到就返回错误码。</p><p>46 up = first_protocol;</p><p>47 while (up != NULL)</p><p>48 {</p><p>49 if (!strcmp(proto_str, up->name))</p><p>50 goto found;</p><p>51 up = up->next;</p><p>52 }</p><p>53 err = - ENOENT;</p><p>54 goto fail;</p><p>55 found:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>如果找到就分配 URLContext 结构内存，特别注意内存大小要加上文件名长度，文件名字符串结束标</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.088.png alt>记 0 也要预先分配 1 个字节内存，这 1 个字节就是 URLContext 结构中的 char filename[1]。</p><p>56 uc = av_malloc(sizeof(URLContext) + strlen(filename));</p><p>57 if (!uc)</p><p>58 {</p><p>59 err = - ENOMEM;</p><p>60 goto fail;</p><p>61 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.089.png alt></p><p>strcpy 函数会自动在 filename 字符数组后面补 0 作为字符串结束标记，所以不用特别赋值为 0。</p><p>62 strcpy(uc->filename, filename);</p><p>63 uc->prot = up;</p><p>64 uc->flags = flags;</p><p>65 uc->max_packet_size = 0; // default: stream file</p><p>接着调用相应协议的文件打开函数实质打开文件。如果文件打开错误，就需要释放 malloc 出来的内</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.056.png alt>存，并返回错误码。</p><p>66 err = up->url_open(uc, filename, flags);</p><p>67 if (err &lt; 0)</p><p>68 {</p><p>69 av_free(uc); // 打开失败，释放刚刚分配的内存。</p><p>70 *puc = NULL;</p><p>71 return err;</p><p>72 }</p><p>73 *puc = uc;</p><p>74 return 0;</p><p>75 fail:</p><p>76 *puc = NULL;</p><p>77 return err;</p><p>78 }</p><p>79<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>简单的中转读操作到底层协议的读函数，完成读操作。</p><p>80 int url_read(URLContext *h, unsigned char *buf, int size)</p><p>81 {</p><p>82 int ret;</p><p>83 if (h->flags &URL_WRONLY)</p><p>84 return AVERROR_IO;</p><p>85 ret = h->prot->url_read(h, buf, size);</p><p>86 return ret;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>87 }</p><p>88<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.046.png alt></p><p>简单的中转 seek 操作到底层协议的 seek 函数，完成 seek 操作。</p><p>89 offset_t url_seek(URLContext *h, offset_t pos, int whence)</p><p>90 {</p><p>91 offset_t ret;</p><p>92</p><p>93 if (!h->prot->url_seek)</p><p>94 return - EPIPE;</p><p>95 ret = h->prot->url_seek(h, pos, whence);</p><p>96 return ret;</p><p>97 }</p><p>98<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.090.png alt></p><p>简单的中转关闭操作到底层协议的关闭函数，完成关闭操作，并释放在 url_open()函数中 malloc 出</p><p>来的内存。</p><p>99 int url_close(URLContext *h)</p><p>100 {</p><p>101 int ret;</p><p>102</p><p>103 ret = h->prot->url_close(h);</p><p>104 av_free(h);</p><p>105 return ret;</p><p>106 }</p><p>107<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.061.png alt></p><p>取最大数据包大小，如果非 0，必须是实质有效的。</p><p>108 int url_get_max_packet_size(URLContext *h)</p><p>109 {</p><p>110 return h->max_packet_size;</p><p>111 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=8-aviobufc-文件><strong>8 aviobuf.c 文件</strong></h3><p>8.1 功能描述</p><p>有缓存的广义文件 ByteIOContext 相关的文件操作，比如 open，read，close，seek 等等。</p><p>8.2 文件注释</p><p>1 #include "../berrno.h"</p><p>2 #include "avformat.h"</p><p>3 #include "avio.h"</p><p>4 #include &lt;stdarg.h></p><p>5</p><p>6 #define IO_BUFFER_SIZE 32768</p><p>7<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>初始化广义文件 ByteIOContext 结构，一些简单的赋值操作。</p><p>8 int init_put_byte(ByteIOContext *s,</p><table><thead><tr><th>9</th><th></th><th>unsigned char *buffer,</th></tr></thead><tbody><tr><td>10</td><td></td><td>int buffer_size,</td></tr><tr><td>11</td><td></td><td>int write_flag,</td></tr><tr><td>12</td><td></td><td>void *opaque,</td></tr><tr><td>13</td><td></td><td>int(*read_buf)(void *opaque, uint8_t *buf, int buf_size),</td></tr><tr><td>14</td><td></td><td>int(*write_buf)(void *opaque, uint8_t *buf, int buf_size),</td></tr><tr><td>15</td><td></td><td>offset_t(*seek)(void *opaque, offset_t offset, int whence))</td></tr><tr><td>16</td><td>{</td><td></td></tr><tr><td>17</td><td></td><td>s->buffer = buffer;</td></tr><tr><td>18</td><td></td><td>s->buffer_size = buffer_size;</td></tr><tr><td>19</td><td></td><td>s->buf_ptr = buffer;</td></tr><tr><td>20</td><td></td><td>s->write_flag = write_flag;</td></tr><tr><td>21</td><td></td><td>if (!s->write_flag)</td></tr><tr><td>22</td><td></td><td>s->buf_end = buffer; // 初始情况下，缓存中没有效数据，所以 buf_end 指向缓存首地址。</td></tr><tr><td>23</td><td></td><td>else</td></tr><tr><td>24</td><td></td><td>s->buf_end = buffer + buffer_size;</td></tr><tr><td>25</td><td></td><td>s->opaque = opaque;</td></tr><tr><td>26</td><td></td><td>s->write_buf = write_buf;</td></tr><tr><td>27</td><td></td><td>s->read_buf = read_buf;</td></tr><tr><td>28</td><td></td><td>s->seek = seek;</td></tr><tr><td>29</td><td></td><td>s->pos = 0;</td></tr><tr><td>30</td><td></td><td>s->must_flush = 0;</td></tr><tr><td>31</td><td></td><td>s->eof_reached = 0;</td></tr><tr><td>32</td><td></td><td>s->error = 0;</td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>33 s->max_packet_size = 0;</p><p>34 return 0;</p><p>35 }</p><p>36</p><p>广义文件 ByteIOContext 的 seek 操作。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.092.png alt>输入变量：s 为广义文件句柄，offset 为偏移量，whence 为定位方式。 输出变量：相对广义文件开始的偏移量。</p><p>37 offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)</p><p>38 {</p><p>39 offset_t offset1;</p><p>40<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.092.png alt></p><p>只支持 SEEK_CU R 和 SEEK_SET 定位方式，不支持 SEEK_END 方式。</p><p>SEEK_CUR:从文件当前读写位置为基准偏移 offset 字节。 SEEK_SET:从文件开始位置偏移 offset 字节。</p><p>41 if (whence != SEEK_CUR && whence != SEEK_SET)</p><p>42 return - EINVAL;</p><p>43</p><p>ffplay 把 SEEK_CU R 和 SEEK_SET 统一成 SEEK_SET 方式处理，所以如果是 SEEK_CU R 方式就要转 换成 SEEK_SET 的偏移量。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.093.png alt>offset1 = s->pos - (s->buf_end - s->buffer) + (s->buf_ptr - s->buffer) 算式关系请参照 3.6</p><p>节的示意图，表示广义文件的当前实际偏移。</p><p>44 if (whence == SEEK_CUR)</p><table><thead><tr><th>45</th><th>{</th><th></th></tr></thead><tbody><tr><td>46</td><td></td><td>offset1 = s->pos - (s->buf_end - s->buffer) + (s->buf_ptr - s->buffer);</td></tr><tr><td>47</td><td></td><td>if (offset == 0)</td></tr><tr><td>48</td><td></td><td>return offset1; // 如果偏移量为 0，返回实际偏移位置。</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt>计算绝对偏移量，赋值给 offset。</td><td></td><td></td></tr></tbody></table><p>49 offset += offset1; // 加上实际偏移量，统一成相对广义文件开始的绝对偏移量</p><p>50 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>计算绝对偏移量相对当前缓存的偏移量，赋值给 offset1。</p><p>51 offset1 = offset - (s->pos - (s->buf_end - s->buffer));<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判断绝对偏移量是否在当前缓存中，如果在当前缓存中，就简单的修改 buf_ptr 指针。</p><p>52 if (offset1 >= 0 && offset1 &lt;= (s->buf_end - s->buffer))</p><p>53 {</p><p>54 s->buf_ptr = s->buffer + offset1; // can do the seek inside the buffer<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>55 }</p><p>56 else</p><p>57 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>判断当前广义文件是否可以 seek，如果不能 seek 就返回错误。</p><p>58 if (!s->seek)</p><p>59 return - EPIPE;</p><p>调用底层具体的文件系统的 seek 函数完成实际的 seek 操作，此时缓存需重新初始化，buf_end 重新指</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.095.png alt>向缓存首地址，并修改 pos 变量为广义文件当前实际偏移量。</p><p>60 s->buf_ptr = s->buffer;</p><p>61 s->buf_end = s->buffer;</p><p>62 if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t) - EPIPE)</p><p>63 return - EPIPE;</p><p>64 s->pos = offset;</p><p>65 }</p><p>66 s->eof_reached = 0;</p><p>67<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>返回广义文件当前的实际偏移量。</p><p>68 return offset;</p><p>69 }</p><p>70<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>广义文件 ByteIOContext 的当前实际偏移量再偏移 offset 字节，调用 url_fseek 实现。</p><p>71 void url_fskip(ByteIOContext *s, offset_t offset)</p><p>72 {</p><p>73 url_fseek(s, offset, SEEK_CUR);</p><p>74 }</p><p>75<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>返回广义文件 ByteIOContext 的当前实际偏移量。</p><p>76 offset_t url_ftell(ByteIOContext *s)</p><p>77 {</p><p>78 return url_fseek(s, 0, SEEK_CUR);</p><p>79 }</p><p>80<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>返回广义文件 ByteIOContext 的大小。</p><p>81 offset_t url_fsize(ByteIOContext *s)</p><p>82 {</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>83 offset_t size;</p><p>84<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判断当前广义文件 ByteIOContext 是否能 seek，如果不能就返回错误</p><p>85 if (!s->seek)</p><p>86 return - EPIPE;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>调用底层的 seek 函数取得文件大小。</p><p>87 size = s->seek(s->opaque, - 1, SEEK_END) + 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>注意 seek 操作改变了读指针，所以要重新 seek 到当前读指针位置。</p><p>88 s->seek(s->opaque, s->pos, SEEK_SET);</p><p>89 return size;</p><p>90 }</p><p>91<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判断当前广义文件 ByteIOContext 是否到末尾</p><p>92 int url_feof(ByteIOContext *s)</p><p>93 {</p><p>94 return s->eof_reached;</p><p>95 }</p><p>96<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>返回当前广义文件 ByteIOContext 操作错误码</p><p>97 int url_ferror(ByteIOContext *s)</p><p>98 {</p><p>99 return s->error;</p><p>100 }</p><p>101</p><p>102 // Input stream</p><p>103<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>填充广义文件 ByteIOContext 内部的数据缓存区。</p><p>104 static void fill_buffer(ByteIOContext *s)</p><p>105 {</p><p>106 int len;</p><p>107<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果到了广义文件 ByteIOContext 末尾就直接返回。</p><p>108 if (s->eof_reached)</p><p>109 return ;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>110<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.096.png alt></p><p>调用底层文件系统的读函数实际读数据填到缓存，注意这里经过了好几次跳转才到底层读函数。首先</p><p>跳转的 url_read_buf()函数，再跳转到 url_read()，再跳转到实际文件协议的读函数完成读操作。</p><p>111 len = s->read_buf(s->opaque, s->buffer, s->buffer_size); // url_read_buf //</p><p>112 if (len &lt;= 0)</p><p>113 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>如果是到达文件末尾就不要改 buffer 参数，这样不用重新读数据就可以做 seek back 操作。</p><p>114 s->eof_reached = 1;</p><p>115<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>设置错误码，便于分析定位。</p><p>116 if (len &lt; 0)</p><p>117 s->error = len;</p><p>118 }</p><p>119 else</p><p>120 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>如果正确读取，修改一下基本参数。参加 3.6 节中的示意图。</p><table><thead><tr><th>121</th><th></th><th>s->pos += len;</th></tr></thead><tbody><tr><td>122</td><td></td><td>s->buf_ptr = s->buffer;</td></tr><tr><td>123</td><td></td><td>s->buf_end = s->buffer + len;</td></tr><tr><td>124</td><td>}</td><td></td></tr><tr><td>125 }</td><td></td><td></td></tr></tbody></table><p>126<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>从广义文件 ByteIOContext 中读取一个字节。</p><p>127 int get_byte(ByteIOContext *s)</p><p>128 {</p><p>129 if (s->buf_ptr &lt; s->buf_end)</p><p>130 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果广义文件 ByteIOContext 内部缓存有数据，就修改读指针，返回读取的数据。</p><p>131 return *s->buf_ptr++;</p><p>132 }</p><p>133 else</p><p>134 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>如果广义文件 ByteIOContext 内部缓存没有数据，就先填充内部缓存。</p><p>135 fill_buffer(s);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>如果广义文件 ByteIOContext 内部缓存有数据，就修改读指针，返回读取的数据。如果没有数据就是</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.097.png alt>到了文件末尾，返回 0。</p><p>NOTE: return 0 if EOF, so you cannot use it if EOF handling is necessary</p><p>136 if (s->buf_ptr &lt; s->buf_end)</p><p>137 return *s->buf_ptr++;</p><p>138 else</p><p>139 return 0;</p><p>140 }</p><p>141 }</p><p>142<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>从广义文件 ByteIOContext 中以小端方式读取两个字节,实现代码充分复用 get_byte()函数。</p><p>143 unsigned int get_le16(ByteIOContext *s)</p><p>144 {</p><p>145 unsigned int val;</p><p>146 val = get_byte(s);</p><p>147 val |= get_byte(s) &lt;&lt; 8;</p><p>148 return val;</p><p>149 }</p><p>150<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>从广义文件 ByteIOContext 中以小端方式读取四个字节,实现代码充分复用 get_le16()函数。</p><p>151 unsigned int get_le32(ByteIOContext *s)</p><p>152 {</p><p>153 unsigned int val;</p><p>154 val = get_le16(s);</p><p>155 val |= get_le16(s) &lt;&lt; 16;</p><p>156 return val;</p><p>157 }</p><p>158</p><p>159 #define url_write_buf NULL</p><p>160<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>简单中转读操作函数。</p><p>161 static int url_read_buf(void *opaque, uint8_t *buf, int buf_size)</p><p>162 {</p><p>163 URLContext *h = opaque;</p><p>164 return url_read(h, buf, buf_size);</p><p>165 }</p><p>166<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.098.png alt></p><p>简单中转 seek 操作函数。</p><p>167 static offset_t url_seek_buf(void *opaque, offset_t offset, int whence)</p><p>168 {</p><p>169 URLContext *h = opaque;</p><p>170 return url_seek(h, offset, whence);</p><p>171 }</p><p>172<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>设置并分配广义文件 ByteIOContext 内部缓存的大小。更多的应用在修改内部缓存大小场合。</p><p>173 int url_setbufsize(ByteIOContext *s, int buf_size) // must be called before any I/O</p><p>174 {</p><p>175 uint8_t *buffer;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>分配广义文件 ByteIOContext 内部缓存。</p><p>176 buffer = av_malloc(buf_size);</p><p>177 if (!buffer)</p><p>178 return - ENOMEM;</p><p>179<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>释放掉原来广义文件 ByteIOContext 的内部缓存，这是一个保险的操作。</p><p>180 av_free(s->buffer);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>设置广义文件 ByteIOContext 内部缓存相关参数。</p><p>181 s->buffer = buffer;</p><p>182 s->buffer_size = buf_size;</p><p>183 s->buf_ptr = buffer;</p><p>184 if (!s->write_flag)</p><p>185 s->buf_end = buffer; // 因为此时只是分配了内存,并没有读入数据,所以 buf_end 指向首地址</p><p>186 else</p><p>187 s->buf_end = buffer + buf_size;</p><p>188 return 0;</p><p>189 }</p><p>190<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>打开广义文件 ByteIOContext</p><p>191 int url_fopen(ByteIOContext *s, const char *filename, int flags)</p><p>192 {</p><p>193 URLContext *h;</p><p>194 uint8_t *buffer;</p><p>195 int buffer_size, max_packet_size;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>196 int err;</p><p>197<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>调用底层文件系统的 open 函数实质性打开文件</p><p>198 err = url_open(&h, filename, flags);</p><p>199 if (err &lt; 0)</p><p>200 return err;</p><p>201</p><p>读取底层文件系统支持的最大包大小。如果非 0，则设置为内部缓存的大小；否则内部缓存设置为默认</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.099.png alt>大小 IO_BUFFER_SIZE(32768 字节)。</p><p>202 max_packet_size = url_get_max_packet_size(h);</p><p>203 if (max_packet_size)</p><p>204 {</p><p>205 buffer_size = max_packet_size; // no need to bufferize more than one packet</p><p>206 }</p><p>207 else</p><p>208 {</p><p>209 buffer_size = IO_BUFFER_SIZE;</p><p>210 }</p><p>211<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.100.png alt></p><p>分配广义文件 ByteIOContext 内部缓存，如果错误就关闭文件返回错误码。</p><p>212 buffer = av_malloc(buffer_size);</p><p>213 if (!buffer)</p><p>214 {</p><p>215 url_close(h);</p><p>216 return - ENOMEM;</p><p>217 }</p><p>218<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>初始化广义文件 ByteIOContext 数据结构，如果错误就关闭文件，释放内部缓存，返回错误码</p><p>219 if (init_put_byte(s,</p><table><thead><tr><th>220</th><th></th><th>buffer,</th></tr></thead><tbody><tr><td>221</td><td></td><td>buffer_size,</td></tr><tr><td>222</td><td></td><td>(h->flags &URL_WRONLY</td></tr><tr><td>223</td><td></td><td>h,</td></tr><tr><td>224</td><td></td><td>url_read_buf,</td></tr><tr><td>225</td><td></td><td>url_write_buf,</td></tr><tr><td>226</td><td></td><td>url_seek_buf) &lt; 0)</td></tr><tr><td>227</td><td>{</td><td></td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>228 url_close(h);</p><p>229 av_free(buffer);</p><p>230 return AVERROR_IO;</p><p>231 }</p><p>232<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.101.png alt></p><p>保存最大包大小。</p><p>233 s->max_packet_size = max_packet_size;</p><p>234</p><p>235 return 0;</p><p>236 }</p><p>237</p><p>关闭广义文件 ByteIOContext，首先释放掉内部使用的缓存，再把自己的字段置 0，最后转入底层文件</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.096.png alt>系统的关闭函数实质性关闭文件。</p><p>238 int url_fclose(ByteIOContext *s)</p><p>239 {</p><p>240 URLContext *h = s->opaque;</p><p>241</p><p>242 av_free(s->buffer);</p><p>243 memset(s, 0, sizeof(ByteIOContext));</p><p>244 return url_close(h);</p><p>245 }</p><p>246</p><p>广义文件 ByteIOContext 读操作，注意此函数从 get_buffer 改名而来，更贴切函数功能，也为了完备</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.095.png alt>广义文件操作函数集。</p><p>247 int url_fread(ByteIOContext *s, unsigned char *buf, int size) // get_buffer</p><p>248 {</p><p>249 int len, size1;</p><p>250</p><p>考虑到 size 可能比缓存中的数据大得多，此时就多次读缓存，所以用 size1 保存要读取的总字节数，size</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.095.png alt>意义变更为还需要读取的字节数。</p><p>251 size1 = size;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>如果还需要读的字节数大于 0，就进入循环继续读。</p><p>252 while (size > 0)</p><p>253 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.103.png alt></p><p>计算当次循环应该读取的字节数 len ，首先设置 len 为内部缓存数据长度，再和需要读的字节数 size 比，</p><p>有条件修正 len 的值。</p><p>254 len = s->buf_end - s->buf_ptr;</p><p>255 if (len > size)</p><p>256 len = size;</p><p>257 if (len == 0)</p><p>258 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果内部缓存没有数据。</p><p>259 if (size > s->buffer_size) // 读操作是否绕过内部缓存的判别条件</p><p>260 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果要读取的数据量比内部缓存数据量大，就调用底层函数读取数据绕过内部缓存直接到目标缓存。</p><p>261 len = s->read_buf(s->opaque, buf, size);</p><p>262 if (len &lt;= 0)</p><p>263 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果底层文件系统读错误，设置文件末尾标记和错误码，跳出循环，返回实际读到的字节数。</p><p>264 s->eof_reached = 1;</p><p>265 if (len &lt; 0)</p><p>266 s->error = len;</p><p>267 break;</p><p>268 }</p><p>269 else</p><p>270 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>如果底层文件系统正确读，修改相关参数，进入下一轮循环。特别注意此处读文件绕过了内部缓存。</p><table><thead><tr><th>271</th><th></th><th>s->pos += len;</th></tr></thead><tbody><tr><td><p>272</p><p>273</p><p></p></td><td></td><td><p>size -= len;</p><p>buf += len; // 因为绕过了内部缓存，特别注意此处的修改</p><p></p></td></tr><tr><td><p>274</p><p></p></td><td></td><td><p>s->buf_ptr = s->buffer;</p><p></p></td></tr><tr><td><p>275</p><p></p></td><td></td><td><p>s->buf_end = s->buffer /* +len */;//因为绕过了内部缓存,特别注意此处</p><p></p></td></tr><tr><td>276</td><td><p>}</p><p></p></td><td></td></tr><tr><td>277</td><td><p>}</p><p></p></td><td></td></tr><tr><td>278</td><td><p>else</p><p></p></td><td></td></tr><tr><td>279</td><td><p>{</p><p></p></td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt>如果要读取的数据量比内部缓存数据量小，就调用底层函数读取数据到内部缓存，判断读成果否。</td><td></td><td></td></tr></tbody></table><p>280 fill_buffer(s);</p><p>281 len = s->buf_end - s->buf_ptr;</p><table><thead><tr><th>282</th><th></th><th>if (len == 0)</th></tr></thead><tbody><tr><td>283</td><td></td><td>break;</td></tr><tr><td>284</td><td>}</td><td></td></tr><tr><td>285</td><td>}</td><td></td></tr><tr><td>286</td><td>else</td><td></td></tr><tr><td>287</td><td>{</td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt>如果内部缓存有数据，就拷贝 len 长度的数据到缓存区，并修改相关参数，进入下一个循环的条件判断。</td><td></td><td></td></tr></tbody></table><p>288 memcpy(buf, s->buf_ptr, len);</p><p>289 buf += len;</p><p>290 s->buf_ptr += len;</p><p>291 size -= len;</p><p>292 }</p><p>293 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>返回实际读取的字节数。</p><p>294 return size1 - size;</p><p>295 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><h3 id=9-utils_formatc-文件><strong>9 utils_format.c 文件</strong></h3><p>9.1 功能描述</p><p>识别文件格式和媒体格式部分使用的一些工具类函数。</p><p>9.2 文件注释</p><p>1 #include "../berrno.h"</p><p>2 #include "avformat.h"</p><p>3 #include &lt;assert.h></p><p>4</p><p>5 #define UINT_MAX (0xffffffff)</p><p>6</p><p>7 #define PROBE_BUF_MIN 2048</p><p>8 #define PROBE_BUF_MAX 131072</p><p>9</p><p>10 AVInputFormat *first_iformat = NULL;</p><p>11<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>注册文件容器格式。ffplay 把所有支持的文件容器格式用链表串联起来，表头是 first_iformat。</p><p>12 void av_register_input_format(AVInputFormat *format)</p><p>13 {</p><p>14 AVInputFormat **p;</p><p>15 p = &first_iformat;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>循环移动节点指针到最后一个文件容器格式。</p><p>16 while (*p != NULL)</p><p>17 p = &(*p)->next;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>直接挂接要注册的文件容器格式。</p><p>18 *p = format;</p><p>19 format->next = NULL;</p><p>20 }</p><p>21<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>比较文件的扩展名来识别文件类型。</p><p>22 int match_ext(const char *filename, const char *extensions)</p><p>23 {</p><p>24 const char *ext, *p;</p><p>25 char ext1[32], *q;</p><p>26<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.104.png alt></p><p>如果输入文件为空就直接返回。</p><p>27 if (!filename)</p><p>28 return 0;</p><p>29<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>用'.'号作为扩展名分割符，在文件名中找扩展名分割符。</p><p>30 ext = strrchr(filename, '.');</p><p>31 if (ext)</p><table><thead><tr><th>32</th><th>{</th><th></th></tr></thead><tbody><tr><td>33</td><td></td><td>ext++;</td></tr><tr><td>34</td><td></td><td>p = extensions;</td></tr><tr><td>35</td><td></td><td>for (;;)</td></tr><tr><td>36</td><td></td><td>{</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.099.png alt>文件名中可能有多个标点符号，取两个标点符号间或一个标点和一个结束符间的字符串和扩展名比较 来判断文件类型，所以可能要多次比较，所以这里有一个循环。</td><td></td><td></td></tr></tbody></table><p>37 q = ext1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>定位下一个标点符号或字符串结束符，把这之间的字符拷贝到扩展名字符数组中。</p><p>38 while (*p != '\0' && *p != ',' && q - ext1 &lt; sizeof(ext1) - 1)</p><p>39 *q++ = *p++;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>添加扩展名字符串结束标记 0。</p><p>40 *q = '\0';<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>比较识别的扩展名是否后给定的扩展名相同，如果相同就返回 1，否则继续。</p><p>41 if (!strcasecmp(ext1, ext))</p><p>42 return 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判断是否到了文件名末尾，如果是就返回，否则进入下一个循环</p><p>43 if (*p == '\0')</p><p>44 break;</p><p>45 p++;</p><p>46 }</p><p>47 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果在前面的循环中没有匹配到扩展名，就是不识别的文件类型，返回 0</p><p>48 return 0;</p><p>49 }</p><p>50</p><p>探测输入的文件容器格式，返回识别出来的文件格式。如果没有识别出来，就返回初始值 NULL。</p><p>51 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)</p><p>52 {</p><p>53 AVInputFormat *fmt1, *fmt;</p><p>54 int score, score_max;</p><p>55</p><p>56 fmt = NULL;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.105.png alt></p><p>score，score_max 可以理解识别文件容器格式的正确级别。文件容器格式识别结果，如果完全正确可</p><p>以设定为 100，如果可能正确可以设定为 50，没识别出来设定为 0。识别方法不同导致等级不同。</p><p>57 score_max = 0;</p><p>58 for (fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next)</p><p>59 {</p><p>60 if (!is_opened)</p><p>61 continue;</p><p>62</p><p>63 score = 0;</p><p>64 if (fmt1->read_probe)</p><p>65 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.106.png alt></p><p>读取文件头，判断文件头的内容来识别文件容器格式，这种识别方法非常可靠，设定 score 为 100。</p><p>66 score = fmt1->read_probe(pd);</p><p>67 }</p><p>68 else if (fmt1->extensions)</p><p>69 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.096.png alt></p><p>通过文件扩展名来识别文件容器格式，因为文件扩展名任何人都可以改，如果改变扩展名，这种方法</p><p>就错误，如果不改变扩展名，这种识别方法有点可靠，综合等级为 50。</p><table><thead><tr><th>70</th><th></th><th>if (match_ext(pd->filename, fmt1->extensions))</th></tr></thead><tbody><tr><td>71</td><td></td><td>score = 50;</td></tr><tr><td>72</td><td>}</td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.107.png alt>如果识别出来的等级大于最大要求的等级，就认为正确识别，相关参数赋值后，进下一个循环，最后 返回最高级别对应的文件容器格式。</td><td></td><td></td></tr></tbody></table><p>73 if (score > score_max)</p><p>74 {</p><p>75 score_max = score;</p><p>76 fmt = fmt1;</p><p>77 }</p><p>78 }</p><p>返回文件容器格式，如果没有识别出来，返回的是初始值 NULL。</p><p>79 return fmt;</p><p>80 }</p><p>81<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>打开输入流，其中 AVFormatParameters *ap 参数在瘦身后的 ffplay 中没有用到，保留为了不改变接口。</p><p>82 int av_open_input_stream(AVFormatContext **ic_ptr, ByteIOContext *pb, const char *filename,</p><p>83 AVInputFormat *fmt, AVFormatParameters *ap)</p><p>84 {</p><p>85 int err;</p><p>86 AVFormatContext *ic;</p><p>87 AVFormatParameters default_ap;</p><p>88</p><p>89 if (!ap)</p><p>90 {</p><p>91 ap = &default_ap;</p><p>92 memset(ap, 0, sizeof(default_ap));</p><p>93 }</p><p>94</p><p>分配 AVFormatContext 内存，部分成员变量在接下来的程序代码中赋值，部分成员变量在下面调用的</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.099.png alt>ic->iformat->read_header(ic, ap)函数中赋值。</p><p>95 ic = av_mallocz(sizeof(AVFormatContext));</p><p>96 if (!ic)</p><p>97 {</p><p>98 err = AVERROR_NOMEM;</p><p>99 goto fail;</p><p>100 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>关联 AVFormatContext 和 AVInputFormat</p><p>101 ic->iformat = fmt;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>关联 AVFormatContext 和广义文件 ByteIOContext</p><p>102 if (pb)</p><p>103 ic->pb = *pb;</p><p>104</p><p>105 if (fmt->priv_data_size > 0)</p><p>106 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>分配 priv_data 指向的内存。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>107 ic->priv_data = av_mallocz(fmt->priv_data_size);</p><p>108 if (!ic->priv_data)</p><p>109 {</p><p>110 err = AVERROR_NOMEM;</p><p>111 goto fail;</p><p>112 }</p><p>113 }</p><p>114 else</p><p>115 {</p><p>116 ic->priv_data = NULL;</p><p>117 }</p><p>118<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>读取文件头，识别媒体流格式。</p><p>119 err = ic->iformat->read_header(ic, ap);</p><p>120 if (err &lt; 0)</p><p>121 goto fail;</p><p>122</p><p>123 *ic_ptr = ic;</p><p>124 return 0;</p><p>125<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>简单常规的错误处理。</p><p>126 fail:</p><p>127 if (ic)</p><p>128 av_freep(&ic->priv_data);</p><p>129</p><p>130 av_free(ic);</p><p>131 *ic_ptr = NULL;</p><p>132 return err;</p><p>133 }</p><p>134<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>打开输入文件，并识别文件格式，然后调用函数识别媒体流格式。</p><p>135 int av_open_input_file(AVFormatContext **ic_ptr, const char *filename, AVInputFormat *fmt,</p><p>136 int buf_size, AVFormatParameters *ap)</p><p>137 {</p><p>138 int err, must_open_file, file_opened, probe_size;</p><p>139 AVProbeData probe_data, *pd = &probe_data;</p><p>140 ByteIOContext pb1, *pb = &amp;pb1;</p><p>141<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>142 file_opened = 0;</p><p>143 pd->filename = "";</p><p>144 if (filename)</p><p>145 pd->filename = filename;</p><p>146 pd->buf = NULL;</p><p>147 pd->buf_size = 0;</p><p>148</p><p>149 must_open_file = 1;</p><p>150</p><p>151 if (!fmt || must_open_file)</p><p>152 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>打开输入文件，关联 ByteIOContext，经过跳转几次后才实质调用文件系统 open()函数实质打开文件。</p><p>153 if (url_fopen(pb, filename, URL_RDONLY) &lt; 0)</p><p>154 {</p><p>155 err = AVERROR_IO;</p><p>156 goto fail;</p><p>157 }</p><p>158 file_opened = 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果程序指定 ByteIOContext 内部使用的缓存大小，就重新设置内部缓存大小。通常不指定大小。</p><p>159 if (buf_size > 0)</p><p>160 url_setbufsize(pb, buf_size);</p><p>161</p><p>先读 PROBE_ BUF_ MIN(2048)字节文件开始数据识别文件格式，如果不能识别文件格式，就把识别文</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.108.png alt>件缓存以 2 倍的增长扩大再读文件开始数据识别，直到识别出文件格式或者超过 131072 字节缓存。</p><p>162 for (probe_size = PROBE_BUF_MIN; probe_size &lt;= PROBE_BUF_MAX && !fmt; probe_size &lt;&lt;= 1)</p><p>163 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>重新分配缓存，重新读文件开始数据。</p><p>164 pd->buf = av_realloc(pd->buf, probe_size);</p><p>165 pd->buf_size = url_fread(pb, pd->buf, probe_size);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>把文件读指针 seek 到文件开始处，便于下一次读。</p><p>166 if (url_fseek(pb, 0, SEEK_SET) == (offset_t) - EPIPE)</p><p>167 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>如果 seek 错误，关闭文件，再重新打开。</p><p>168 url_fclose(pb);</p><p>169 if (url_fopen(pb, filename, URL_RDONLY) &lt; 0)</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>170 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>重新打开文件出错，设置错误码，跳到错误处理。</p><p>171 file_opened = 0;</p><p>172 err = AVERROR_IO;</p><p>173 goto fail;</p><p>174 }</p><p>175 }</p><p>176<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>重新识别文件格式，因为一次比一次数据多，数据少的时候可能识别不出，数据多了可能就可以了。</p><p>177 fmt = av_probe_input_format(pd, 1);</p><p>178 }</p><p>179 av_freep(&pd->buf);</p><p>180 }</p><p>181</p><p>182 if (!fmt)</p><p>183 {</p><p>184 err = AVERROR_NOFMT;</p><p>185 goto fail;</p><p>186 }</p><p>187<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>识别出文件格式后，调用函数识别流 av_open_input_stream 格式。</p><p>188 err = av_open_input_stream(ic_ptr, pb, filename, fmt, ap);</p><p>189 if (err)</p><p>190 goto fail;</p><p>191 return 0;</p><p>192</p><p>193 fail:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>简单的异常错误处理。</p><p>194 av_freep(&pd->buf);</p><p>195 if (file_opened)</p><p>196 url_fclose(pb);</p><p>197 *ic_ptr = NULL;</p><p>198 return err;</p><p>199 }</p><p>200<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>一次读取一个数据包，在瘦身后的 ffplay 中，一次读取一个完整的数据帧，数据包。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>201 int av_read_packet(AVFormatContext *s, AVPacket *pkt)</p><p>202 {</p><p>203 return s->iformat->read_packet(s, pkt);</p><p>204 }</p><p>205</p><p>添加索引到索引表。有些媒体文件为便于 seek，有音视频数据帧有索引，ffplay 把这些索引以时间排</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.109.png alt>序放到一个数据中。返回值添加项的索引。</p><p>206 int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)</p><p>207 {</p><p>208 AVIndexEntry *entries, *ie;</p><p>209 int index;</p><p>210<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>索引项越界判断，如果占有内存达到 UINT_MAX 时，返回。</p><p>211 if ((unsigned)st->nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))</p><p>212 return - 1;</p><p>213</p><p>重新分配索引内存。注意 av_fast_realloc()函数并不是每次调用就一定会重新分配内存，那样效率就</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.105.png alt>太低了。</p><p>214 entries = av_fast_realloc(st->index_entries, &st->index_entries_allocated_size,</p><p>215 (st->nb_index_entries + 1) * sizeof(AVIndexEntry));</p><p>216 if (!entries)</p><p>217 return - 1;</p><p>218<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>保持重新分配内存后，索引的首地址。</p><p>219 st->index_entries = entries;</p><p>220<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>以时间为顺序查找当前索引应该插在索引表的位置。</p><p>221 index = av_index_search_timestamp(st, timestamp, AVSEEK_FLAG_ANY);</p><p>222</p><p>223 if (index &lt; 0)</p><p>224 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>续补，既接着最后一个插入，索引计算加 1，取得索引项指针，便于后面赋值操作。</p><p>225 index = st->nb_index_entries++;</p><p>226 ie = &entries[index];</p><p>227 assert(index == 0 || ie[ - 1].timestamp &lt; timestamp);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>228 }</p><p>229 else</p><p>230 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>中插，既插入索引表的中间，取得索引项指针，便于后面赋值操作。</p><p>231 ie = &entries[index];</p><p>232 if (ie->timestamp != timestamp)</p><p>233 {</p><p>234 if (ie->timestamp &lt;= timestamp)</p><p>235 return - 1;</p><p>236<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>把索引项后面的项全部后移一项，空出当前索引项。</p><p>237 memmove(entries + index + 1, entries + index,</p><p>238 sizeof(AVIndexEntry)*(st->nb_index_entries - index));</p><p>239<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>索引项计数加 1。</p><p>240 st->nb_index_entries++;</p><p>241 }</p><p>242 }</p><p>243<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>修改索引项参数，完成排序添加。</p><p>244 ie->pos = pos;</p><p>245 ie->timestamp = timestamp;</p><p>246 ie->size = size;</p><p>247 ie->flags = flags;</p><p>248<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.110.png alt></p><p>返回索引。</p><p>249 return index;</p><p>250 }</p><p>251<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>以时间为关键字查找当前索引应排在索引表中的位置。</p><p>252 int av_index_search_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)</p><p>253 {</p><p>254 AVIndexEntry *entries = st->index_entries;</p><p>255 int nb_entries = st->nb_index_entries;</p><p>256 int a, b, m;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>257 int64_t timestamp;</p><p>258</p><p>259 a = - 1;</p><p>260 b = nb_entries;</p><p>261<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>以时间为关键字折半查找位置，请仔细理解。</p><p>262 while (b - a > 1)</p><p>263 {</p><p>264 m = (a + b) >> 1;</p><p>265 timestamp = entries[m].timestamp;</p><p>266 if (timestamp >= wanted_timestamp)</p><p>267 b = m;</p><p>268 if (timestamp &lt;= wanted_timestamp)</p><p>269 a = m;</p><p>270 }</p><p>271</p><p>272 m = (flags &AVSEEK_FLAG_BACKWARD) ? a : b;</p><p>273</p><p>274 if (!(flags &AVSEEK_FLAG_ANY))</p><p>275 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>Seek 时，找关键帧，从关键帧开始解码，注意有些帧解码但不显示。</p><p>276 while (m >= 0 && m &lt; nb_entries && !(entries[m].flags &AVINDEX_KEYFRAME))</p><p>277 {</p><p>278 m += (flags &AVSEEK_FLAG_BACKWARD) ? - 1: 1;</p><p>279 }</p><p>280 }</p><p>281</p><p>282 if (m == nb_entries)</p><p>283 return - 1;</p><p>284<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>返回找到的位置。</p><p>285 return m;</p><p>286 }</p><p>287<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>关闭输入媒体文件，一大堆的关闭释放操作。</p><p>288 void av_close_input_file(AVFormatContext *s)</p><p>289 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>290 int i;</p><p>291 AVStream *st;</p><p>292</p><p>293 if (s->iformat->read_close)</p><p>294 s->iformat->read_close(s);</p><p>295</p><p>296 for (i = 0; i &lt; s->nb_streams; i++)</p><p>297 {</p><p>298 st = s->streams[i];</p><p>299 av_free(st->index_entries);</p><p>300 av_free(st->actx);</p><p>301 av_free(st);</p><p>302 }</p><p>303</p><p>304 url_fclose(&s->pb);</p><p>305</p><p>306 av_freep(&s->priv_data);</p><p>307 av_free(s);</p><p>308 }</p><p>309<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>new 一个新的媒体流，返回 AVStream 指针</p><p>310 AVStream *av_new_stream(AVFormatContext *s, int id)</p><p>311 {</p><p>312 AVStream *st;</p><p>313<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判断媒体流的数目是否超限，如果超过就丢弃当前流返回 NULL。</p><p>314 if (s->nb_streams >= MAX_STREAMS)</p><p>315 return NULL;</p><p>316<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>分配一块 AVStream 内存。</p><p>317 st = av_mallocz(sizeof(AVStream));</p><p>318 if (!st)</p><p>319 return NULL;</p><p>320<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>通过 avcodec_alloc_context 分配一块 AVFormatContext 内存，并关联到 AVStream。</p><p>321 st->actx = avcodec_alloc_context();</p><p>322<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.111.png alt></p><p>关联 AVFormatContext 和 AVStream。</p><p>323 s->streams[s->nb_streams++] = st;</p><p>324 return st;</p><p>325 }</p><p>326<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>设置计算 pts 时钟的相关参数。</p><p>327 void av_set_pts_info(AVStream *s, int pts_wrap_bits, int pts_num, int pts_den)</p><p>328 {</p><p>329 s->time_base.num = pts_num;</p><p>330 s->time_base.den = pts_den;</p><p>331 }</p><h3 id=images2020ffmpegasposewordsa0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4020png10-avidecc-文件><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><strong>10 avidec.c 文件</strong></h3><p>10.1 功能描述</p><p>AVI 文件解析的相关函数，注意有些地方有些技巧性代码。</p><p>注意 1：AVI 文件容器媒体数据有两种存放方式，非交织存放和交织存放。交织存放就是音视频数据以帧为最 小连续单位，相互间隔存放，这样音视频帧互相交织在一起，并且存放的间隔没有特别规定；非交织存放就是把 单一媒体的所有数据帧连续存放在一起，非交织存放的 avi 文件很少。</p><p>注意 2：AVI 文件索引结构 AVIINDEXENTRY 中的 dwChunkOffset 字段指示的偏移有的是相对文件开始字节的偏 移，有的事相对文件数据块 chunk 的偏移。</p><p>注意 3：附带的 avi 测试文件是交织存放的。</p><p>10.2 文件注释</p><p>1 #include "avformat.h"</p><p>2</p><p>3 #include &lt;assert.h></p><p>4<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>几个简单的宏定义。</p><p>5 #define AVIIF_INDEX 0x10</p><p>6</p><p>7 #define AVIF_HASINDEX 0x00000010 // Index at end of file?</p><p>8 #define AVIF_MUSTUSEINDEX 0x00000020</p><p>9</p><p>10 #define INT_MAX 2147483647</p><p>11</p><p>12 #define MKTAG(a,b,c,d) (a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24))</p><p>13</p><p>14 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))</p><p>15 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))</p><p>16</p><p>17 static int avi_load_index(AVFormatContext *s);</p><p>18 static int guess_ni_flag(AVFormatContext *s);</p><p>19<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>AVI 文件中的流参数定义，和 AVStream 数据结构协作。</p><p>20 typedef struct AVIStream</p><p>21 {</p><p>22 int64_t frame_offset; // 帧偏移，视频用帧计数，音频用字节计数，用于计算 pts 表示时间</p><p>23 int remaining; // 表示需要读的数据大小，初值是帧裸数组大小，全部读完后为 0。</p><p>24 int packet_size; // 包大小，非交织和帧裸数据大小相同，交织比帧裸数据大小大 8 字节。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>25</p><p>26 int scale;</p><p>27 int rate;</p><p>28 int sample_size; // size of one sample (or packet) (in the rate/scale sense) in bytes</p><p>29</p><p>30 int64_t cum_len; // temporary storage (used during seek)</p><p>31</p><p>32 int prefix; // normally 'd'&lt;&lt;8 + 'c' or 'w'&lt;&lt;8 + 'b'</p><p>33 int prefix_count;</p><p>34 } AVIStream;</p><p>35<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>AVI 文件中的文件格式参数相关定义，和 AVFormatContext 协作。</p><p>36 typedef struct</p><p>37 {</p><p>38 int64_t riff_end; // RIFF 块大小</p><p>39 int64_t movi_list; // 媒体数据块开始字节相对文件开始字节的偏移</p><p>40 int64_t movi_end; // 媒体数据块开始字节相对文件开始字节的偏移</p><p>41 int non_interleaved;// 指示是否是非交织 AVI</p><p>42 int stream_index_2; // 为了和 AVPacket 中的 stream_index 相区别加一个后缀。</p><p>// 指示当前应该读取的流的索引。初值为-1，表示没有确定应该读的流。</p><p>// 实际表示 AVFormatContext 结构中 AVStream *streams[] 数组中的索引。</p><p>43 } AVIContext;</p><p>44<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>CodecTag 数据结构，用于关联具体媒体格式的 ID 和 Tag 标签。</p><p>45 typedef struct CodecTag</p><p>46 {</p><p>47 int id; // ID 号码</p><p>48 unsigned int tag; // 标签</p><p>49 } CodecTag;</p><p>50<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>瘦身后的 ffplay 支持的一些视频媒体 ID 和 Tag 标签数组。</p><p>51 const CodecTag codec_bmp_tags[] =</p><p>52 {</p><p>53 {CODEC_ID_MSRLE, MKTAG('m', 'r', 'l', 'e')},</p><p>54 {CODEC_ID_MSRLE, MKTAG(0x1, 0x0, 0x0, 0x0)},</p><p>55 {CODEC_ID_NONE, 0},</p><p>56 };</p><p>57<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.112.png alt></p><p>瘦身后的 ffplay 支持的一些音频媒体 ID 和 Tag 标签数组。</p><p>58 const CodecTag codec_wav_tags[] =</p><p>59 {</p><p>60 {CODEC_ID_TRUESPEECH, 0x22},</p><p>61 {0, 0},</p><p>62 };</p><p>63<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>以媒体 tag 标签为关键字，查找 codec_bmp_tags 或 codec_wav_tags 数组，返回媒体 ID。</p><p>64 enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag)</p><p>65 {</p><p>66 while (tags->id != CODEC_ID_NONE)</p><p>67 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>比较 Tag 关键字，相等时返回对应媒体 ID。</p><p>68 if (toupper((tag >> 0) &0xFF) == toupper((tags->tag >> 0) &0xFF)</p><p>69 && toupper((tag >> 8) &0xFF) == toupper((tags->tag >> 8) &0xFF)</p><p>70 && toupper((tag >> 16)&0xFF) == toupper((tags->tag >> 16)&0xFF)</p><p>71 && toupper((tag >> 24)&0xFF) == toupper((tags->tag >> 24)&0xFF))</p><p>72 return tags->id;</p><p>73<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>比较 Tag 关键字，不等移到数组的下一项。</p><p>74 tags++;</p><p>75 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>所有关键字都不匹配，返回 CODEC_ID_NONE。</p><p>76 return CODEC_ID_NONE;</p><p>77 }</p><p>78<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>校验 AVI 文件，读取 AVI 文件媒体数据块的偏移大小信息，和 avi_probe()函数部分相同。</p><p>79 static int get_riff(AVIContext *avi, ByteIOContext *pb)</p><p>80 {</p><p>81 uint32_t tag;</p><p>82 tag = get_le32(pb);</p><p>83<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>校验 AVI 文件开始关键字串"RIFF"。</p><p>84 if (tag != MKTAG('R', 'I', 'F', 'F'))<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>85 return - 1;</p><p>86</p><p>87 avi->riff_end = get_le32(pb); // RIFF chunk size</p><p>88 avi->riff_end += url_ftell(pb); // RIFF chunk end</p><p>89 tag = get_le32(pb);</p><p>90<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>校验 AVI 文件关键字串"AVI "或"AVIX"。</p><p>91 if (tag != MKTAG('A', 'V', 'I', ' ') && tag != MKTAG('A', 'V', 'I', 'X'))</p><p>92 return - 1;</p><p>93<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果通过 AVI 文件关键字串"RIFF"和"AVI "或"AVIX"校验，就认为是 AVI 文件，这种方式非常可靠。</p><p>94 return 0;</p><p>95 }</p><p>96<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>排序建立 AVI 索引表，函数名为 clean_index,不准确，功能以具体的实现代码为准。</p><p>97 static void clean_index(AVFormatContext *s)</p><p>98 {</p><p>99 int i, j;</p><p>100</p><p>101 for (i = 0; i &lt; s->nb_streams; i++)</p><p>102 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>对每个流都建一个独立的索引表。</p><p>103 AVStream *st = s->streams[i];</p><p>104 AVIStream *ast = st->priv_data;</p><p>105 int n = st->nb_index_entries;</p><p>106 int max = ast->sample_size;</p><p>107 int64_t pos, size, ts;</p><p>108<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果索引表项大于 1，则认为索引表已建好，不再排序重建。如果 sample_size 为 0,则没办法重建。</p><p>109 if (n != 1 || ast->sample_size == 0)</p><p>110 continue;</p><p>111<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.113.png alt></p><p>此种情况多半是用在非交织存储的 avi 音频流。不管交织还是非交织存储，视频流通常都有索引。</p><p>防止包太小需要太多的索引项占有大量内存，设定最小帧 size 阈值为 1024。比如有些音频流，最小解 码帧只十多个字节，如果文件比较大则在索引上耗费太多内存。<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>112 while (max &lt; 1024)</p><p>113 max += max;</p><p>114<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>取位置，大小，时钟等基本参数。</p><p>115 pos = st->index_entries[0].pos;</p><p>116 size = st->index_entries[0].size;</p><p>117 ts = st->index_entries[0].timestamp;</p><p>118</p><p>119 for (j = 0; j &lt; size; j += max)</p><p>120 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>以 max 指定的字节打包成帧，添加到索引表。</p><p>121 av_add_index_entry(st, pos + j, ts + j / ast->sample_size, FFMIN(max, size - j), 0, AVINDEX_KEYFRAME);</p><p>122 }</p><p>123 }</p><p>124 }</p><p>125<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>读取 AVI 文件头，读取 AVI 文件索引，并识别具体的媒体格式，关联一些数据结构。</p><p>126 static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap)</p><p>127 {</p><p>128 AVIContext *avi = s->priv_data;</p><p>129 ByteIOContext *pb = &s->pb;</p><p>130 uint32_t tag, tag1, handler;</p><p>131 int codec_type, stream_index, frame_period, bit_rate;</p><p>132 unsigned int size, nb_frames;</p><p>133 int i, n;</p><p>134 AVStream *st;</p><p>135 AVIStream *ast;</p><p>136<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>当前应该读取的流的索引赋初值为-1，表示没有确定应该读的流。</p><p>137 avi->stream_index_2 = - 1;</p><p>138<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>校验 AVI 文件，读取 AVI 文件媒体数据块的偏移大小信息。</p><p>139 if (get_riff(avi, pb) &lt; 0)</p><p>140 return - 1;</p><p>141<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.114.png alt></p><p>简单变量符初值。</p><p>142 stream_index = - 1; // first list tag</p><p>143 codec_type = - 1;</p><p>144 frame_period = 0;</p><p>145</p><p>146 for (;;)</p><p>147 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>AVI 文件的基本结构是块，一个文件有多个块，并且块还可以内嵌，在这里循环读文件头中的块。</p><p>148 if (url_feof(pb))</p><p>149 goto fail;</p><p>150<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>读取每个块的标签和大小。</p><p>151 tag = get_le32(pb);</p><p>152 size = get_le32(pb);</p><p>153</p><p>154 switch (tag)</p><p>155 {</p><p>156 case MKTAG('L', 'I', 'S', 'T'): // ignored, except when start of video packets</p><p>157 tag1 = get_le32(pb);</p><p>158 if (tag1 == MKTAG('m', 'o', 'v', 'i'))</p><p>159 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>读取 movi 媒体数据块的偏移和大小。</p><p>160 avi->movi_list = url_ftell(pb) - 4;</p><p>161 if (size)</p><p>162 avi->movi_end = avi->movi_list + size;</p><p>163 else</p><p>164 avi->movi_end = url_fsize(pb);</p><p>165<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>AVI 文件头后面是 movi 媒体数据块，所以到了 movi 块，文件头肯定读完，需要跳出循环。</p><p>166 goto end_of_header; //</p><p>167 }</p><p>168 break;</p><p>169 case MKTAG('a', 'v', 'i', 'h'): // avi header, using frame_period is bad idea</p><p>170 frame_period = get_le32(pb);</p><p>171 bit_rate = get_le32(pb) *8;</p><p>172 get_le32(pb);</p><p>读取 non_interleaved 的初值。</p><p>173 avi->non_interleaved |= get_le32(pb) & AVIF_MUSTUSEINDEX;</p><p>174</p><p>175 url_fskip(pb, 2 *4);</p><p>176 n = get_le32(pb);</p><p>177 for (i = 0; i &lt; n; i++)</p><p>178 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.115.png alt></p><p>读取流数目 n 后，分配 AVStream 和 AVIStream 数据结构，在 187 行把它们关联起来。</p><p>特别注意 av_new_stream()函数关联 AVFormatContext 和 AVStream 结构，分配关联 AVCodecContext 结构</p><p>179 AVIStream *ast;</p><p>180 st = av_new_stream(s, i);</p><p>181 if (!st)</p><p>182 goto fail;</p><p>183</p><p>184 ast = av_mallocz(sizeof(AVIStream));</p><p>185 if (!ast)</p><p>186 goto fail;</p><p>187 st->priv_data = ast;</p><p>188</p><p>189 st->actx->bit_rate = bit_rate;</p><p>190 }</p><p>191 url_fskip(pb, size - 7 * 4);</p><p>192 break;</p><p>193 case MKTAG('s', 't', 'r', 'h'): // stream header<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>指示当前流在 AVFormatContext 结构中 AVStream *streams[MAX_STREAMS]数组中的索引。</p><p>194 stream_index++;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>从 strh 块读取所有流共有的一些信息，跳过有些不用的字段，填写需要的字段。</p><p>195 tag1 = get_le32(pb);</p><p>196 handler = get_le32(pb);</p><p>197</p><p>198 if (stream_index >= s->nb_streams)</p><p>199 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>出现这种情况通常代表媒体文件数据有错，ffplay 简单的跳过。</p><table><thead><tr><th>200</th><th></th><th>url_fskip(pb, size - 8);</th></tr></thead><tbody><tr><td>201</td><td></td><td>break;</td></tr><tr><td>202</td><td>}</td><td></td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>203 st = s->streams[stream_index];</p><p>204 ast = st->priv_data;</p><p>205</p><p>206 get_le32(pb); // flags</p><p>207 get_le16(pb); // priority</p><p>208 get_le16(pb); // language</p><p>209 get_le32(pb); // initial frame</p><p>210 ast->scale = get_le32(pb);</p><p>211 ast->rate = get_le32(pb);</p><p>212 if (ast->scale && ast->rate)</p><p>213 {}</p><p>214 else if (frame_period)</p><p>215 {</p><p>216 ast->rate = 1000000;</p><p>217 ast->scale = frame_period;</p><p>218 }</p><p>219 else</p><p>220 {</p><p>221 ast->rate = 25;</p><p>222 ast->scale = 1;</p><p>223 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>设置当前流的时间信息，用于计算 pts 表示时间，进而同步。</p><p>224 av_set_pts_info(st, 64, ast->scale, ast->rate);</p><p>225</p><p>226 ast->cum_len = get_le32(pb); // start</p><p>227 nb_frames = get_le32(pb);</p><p>228</p><p>229 get_le32(pb); // buffer size</p><p>230 get_le32(pb); // quality</p><p>231 ast->sample_size = get_le32(pb); // sample ssize</p><p>232</p><p>233 switch (tag1)</p><p>234 {</p><p>235 case MKTAG('v', 'i', 'd', 's'): codec_type = CODEC_TYPE_VIDEO;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>特别注意视频流的每一帧大小不同，所以 sample_size 设置为 0；对比音频流每一帧大小固定的情况。</p><p>236 ast->sample_size = 0;</p><p>237 break;</p><p>238 case MKTAG('a', 'u', 'd', 's'): codec_type = CODEC_TYPE_AUDIO;</p><p>239 break;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>240 case MKTAG('t', 'x', 't', 's'): //FIXME</p><p>241 codec_type = CODEC_TYPE_DATA; //CODEC_TYPE_SUB ? FIXME</p><p>242 break;</p><p>243 case MKTAG('p', 'a', 'd', 's'): codec_type = CODEC_TYPE_UNKNOWN;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果是填充流，stream_index 减 1 就实现了简单的丢弃，不计入流数目总数。</p><p>244 stream_index--;</p><p>245 break;</p><p>246 default:</p><p>247 goto fail;</p><p>248 }</p><p>249 ast->frame_offset = ast->cum_len * FFMAX(ast->sample_size, 1);</p><p>250 url_fskip(pb, size - 12 * 4);</p><p>251 break;</p><p>252 case MKTAG('s', 't', 'r', 'f'): // stream header</p><p>从 strf 块读取流中编解码器的一些信息，跳过有些不用的字段，填写需要的字段。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.109.png alt>注意有些编解码器需要的附加信息从此块中读出，保持至 extradata 并最终传给相应的编解码器。</p><p>253 if (stream_index >= s->nb_streams)</p><p>254 {</p><p>255 url_fskip(pb, size);</p><p>256 }</p><p>257 else</p><p>258 {</p><p>259 st = s->streams[stream_index];</p><p>260 switch (codec_type)</p><p>261 {</p><p>262 case CODEC_TYPE_VIDEO: // BITMAPINFOHEADER</p><p>263 get_le32(pb); // size</p><p>264 st->actx->width = get_le32(pb);</p><p>265 st->actx->height = get_le32(pb);</p><p>266 get_le16(pb); // panes</p><p>267 st->actx->bits_per_sample = get_le16(pb); // depth</p><p>268 tag1 = get_le32(pb);</p><p>269 get_le32(pb); // ImageSize</p><p>270 get_le32(pb); // XPelsPerMeter</p><p>271 get_le32(pb); // YPelsPerMeter</p><p>272 get_le32(pb); // ClrUsed</p><p>273 get_le32(pb); // ClrImportant</p><p>274</p><p>275 if (size > 10 *4 && size &lt; (1 &lt;&lt; 30))<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>276 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>对视频，extradata 通常是保存的是 BITMAPINFO</p><p>277 st->actx->extradata_size = size - 10 * 4;</p><p>278 st->actx->extradata = av_malloc(st->actx->extradata_size +</p><p>279 FF_INPUT_BUFFER_PADDING_SIZE);</p><p>280 url_fread(pb, st->actx->extradata, st->actx->extradata_size);</p><p>281 }</p><p>282</p><p>283 if (st->actx->extradata_size &1)</p><p>284 get_byte(pb);</p><p>285</p><p>286 /* Extract palette from extradata if bpp &lt;= 8 */</p><p>287 /* This code assumes that extradata contains only palette */</p><p>288 /* This is true for all paletted codecs implemented in ffmpeg */</p><p>289 if (st->actx->extradata_size && (st->actx->bits_per_sample &lt;= 8))</p><p>290 {</p><p>291 int min = FFMIN(st->actx->extradata_size, AVPALETTE_SIZE);</p><p>292</p><p>293 st->actx->palctrl = av_mallocz(sizeof(AVPaletteControl));</p><p>294 memcpy(st->actx->palctrl->palette, st->actx->extradata, min);</p><p>295 st->actx->palctrl->palette_changed = 1;</p><p>296 }</p><p>297</p><p>298 st->actx->codec_type = CODEC_TYPE_VIDEO;</p><p>299 st->actx->codec_id = codec_get_id(codec_bmp_tags, tag1);</p><p>300</p><p>301 st->frame_last_delay = 1.0 * ast->scale / ast->rate;</p><p>302</p><p>303 break;</p><p>304 case CODEC_TYPE_AUDIO:</p><table><thead><tr><th>305</th><th>{</th><th></th></tr></thead><tbody><tr><td>306</td><td></td><td>AVCodecContext *actx = st->actx;</td></tr><tr><td>307</td><td></td><td></td></tr><tr><td>308</td><td></td><td>int id = get_le16(pb);</td></tr><tr><td>309</td><td></td><td>actx->codec_type = CODEC_TYPE_AUDIO;</td></tr><tr><td>310</td><td></td><td>actx->channels = get_le16(pb);</td></tr><tr><td>311</td><td></td><td>actx->sample_rate = get_le32(pb);</td></tr><tr><td>312</td><td></td><td>actx->bit_rate = get_le32(pb) *8;</td></tr><tr><td>313</td><td></td><td>actx->block_align = get_le16(pb);</td></tr><tr><td>314</td><td></td><td>if (size == 14) // We're dealing with plain vanilla WAVEFORMAT</td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>315 actx->bits_per_sample = 8;</p><p>316 else</p><p>317 actx->bits_per_sample = get_le16(pb);</p><p>318 actx->codec_id = codec_get_id(codec_wav_tags, id);</p><p>319</p><p>320 if (size > 16)</p><table><thead><tr><th>321</th><th>{</th><th></th></tr></thead><tbody><tr><td>322</td><td></td><td>actx->extradata_size = get_le16(pb);</td></tr><tr><td>323</td><td></td><td>if (actx->extradata_size > 0)</td></tr><tr><td>324</td><td></td><td>{</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt>对音频，extradata 通常是保存的是 WAVEFORMATEX</td><td></td><td></td></tr></tbody></table><p>325 if (actx->extradata_size > size - 18)</p><p>326 actx->extradata_size = size - 18;</p><p>327 actx->extradata = av_mallocz(actx->extradata_size +</p><p>328 FF_INPUT_BUFFER_PADDING_SIZE);</p><p>329 url_fread(pb, actx->extradata, actx->extradata_size);</p><p>330 }</p><p>331 else</p><p>332 {</p><p>333 actx->extradata_size = 0;</p><p>334 }</p><p>335</p><p>336 // It is possible for the chunk to contain garbage at the end</p><p>337 if (size - actx->extradata_size - 18 > 0)</p><p>338 url_fskip(pb, size - actx->extradata_size - 18);</p><p>339 }</p><p>340 }</p><p>341</p><p>342 if (size % 2) // 2-aligned (fix for Stargate SG-1 - 3x18 - Shades of</p><p>Grey.avi)</p><p>343 url_fskip(pb, 1);</p><p>344</p><p>345 break;</p><p>346 default:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>对其他流类型，ffplay 简单的设置为 data 流。常规的是音频流和视频流，其他的少见。</p><p>347 st->actx->codec_type = CODEC_TYPE_DATA;</p><p>348 st->actx->codec_id = CODEC_ID_NONE;</p><p>349 url_fskip(pb, size);</p><p>350 break;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>351 }</p><p>352 }</p><p>353 break;</p><p>354 default: // skip tag<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>对其他不识别的块 chunk，跳过。</p><p>355 size += (size &1);</p><p>356 url_fskip(pb, size);</p><p>357 break;</p><p>358 }</p><p>359 }</p><p>360</p><p>361 end_of_header:</p><p>362 if (stream_index != s->nb_streams - 1)</p><p>363 {</p><p>364 fail:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>校验流的数目，如果有误，释放相关资源，返回-1 错误。</p><p>365 for (i = 0; i &lt; s->nb_streams; i++)</p><p>366 {</p><p>367 av_freep(&s->streams[i]->actx->extradata);</p><p>368 av_freep(&s->streams[i]);</p><p>369 }</p><p>370 return - 1;</p><p>371 }</p><p>372<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>加载 AVI 文件索引。</p><p>373 avi_load_index(s);</p><p>374<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>判别是否是非交织 avi。</p><p>375 avi->non_interleaved |= guess_ni_flag(s);</p><p>376 if (avi->non_interleaved)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>对那些非交织存储的媒体流，人工的补上索引，便于读取操作。</p><p>377 clean_index(s);</p><p>378</p><p>379 return 0;</p><p>380 }</p><p>381</p><p>avi 文件可以简单认为音视频媒体数据时间基相同，因此音视频数据需要同步读取，同步解码，播放才</p><p>能同步。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.116.png alt>交织存储的 avi 文件，临近存储的音视频帧解码时间表示时间相近，微小的解码时间表示时间差别可 以用帧缓存队列抵消，所以可以简单的按照文件顺序读取媒体数据。</p><p>非交织存储的 avi 文件，视频和音频这两种媒体数据相隔甚远，小缓存简单的顺序读文件时，不能同 时读到音频和视频数据，最后导致不同步，ffplay 采取按最近时间点来决定读音频还是视频数据。</p><p>382 int avi_read_packet(AVFormatContext *s, AVPacket *pkt)</p><p>383 {</p><p>384 AVIContext *avi = s->priv_data;</p><p>385 ByteIOContext *pb = &s->pb;</p><p>386 int n, d[8], size;</p><p>387 offset_t i, sync;</p><p>388</p><p>389 if (avi->non_interleaved)</p><p>390 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果是非交织 AVI，用最近时间点来决定读取视频还是音频数据。</p><p>391 int best_stream_index = 0;</p><p>392 AVStream *best_st = NULL;</p><p>393 AVIStream *best_ast;</p><p>394 int64_t best_ts = INT64_MAX;</p><p>395 int i;</p><p>396</p><p>397 for (i = 0; i &lt; s->nb_streams; i++)</p><p>398 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>遍历所有媒体流，按照已经播放的流数据，计算下一个最近的时间点。</p><p>399 AVStream *st = s->streams[i];</p><p>400 AVIStream *ast = st->priv_data;</p><p>401 int64_t ts = ast->frame_offset;</p><p>402<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>把帧偏移换算成帧数。</p><p>403 if (ast->sample_size)</p><p>404 ts /= ast->sample_size;</p><p>405<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>把帧数换算成 pts 表示时间。</p><p>406 ts = av_rescale(ts, AV_TIME_BASE *(int64_t)st->time_base.num, st->time_base.den);</p><p>407<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.117.png alt></p><p>取最小的时间点对应的时间，流指针，流索引作为要读取的最佳 (读取)流参数。</p><p>408 if (ts &lt; best_ts) // 每次读取时间点(ast->frame_offset)最近的包</p><p>409 {</p><p>410 best_ts = ts;</p><p>411 best_st = st;</p><p>412 best_stream_index = i;</p><p>413 }</p><p>414 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>保存最佳流对应的 AVIStream，便于 432 行赋值并传递参数 packet_size 和 remaining。</p><p>415 best_ast = best_st->priv_data;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.096.png alt></p><p>换算最小的时间点，查找索引表取出对应的索引。在缓存足够大，一次性完整读取帧数据时，此时</p><p>best_ast->remaining 参数为 0。</p><p>416 best_ts = av_rescale(best_ts,best_st->time_base.den,AV_TIME_BASE *(int64_t)best_st->time_base.num);</p><p>417 if (best_ast->remaining)</p><p>418 i = av_index_search_timestamp(best_st, best_ts, AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD);</p><p>419 else</p><p>420 i = av_index_search_timestamp(best_st, best_ts, AVSEEK_FLAG_ANY);</p><p>421</p><p>422 if (i >= 0)</p><p>423 {</p><p>找到最佳索引，取出其他参数，在 426 行 seek 到相应位置，在 430 行保存最佳流索引，在 432 行保存</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.096.png alt>并传递要读取的数据大小(通过最佳流索引找到最佳流，再找到对应 AVIStream 结构，再找到数据大小)。</p><p>424 int64_t pos = best_st->index_entries[i].pos;</p><p>425 pos += best_ast->packet_size - best_ast->remaining;</p><p>426 url_fseek(&s->pb, pos + 8, SEEK_SET);</p><p>427</p><p>428 assert(best_ast->remaining &lt;= best_ast->packet_size);</p><p>429</p><p>430 avi->stream_index_2 = best_stream_index;</p><p>431 if (!best_ast->remaining)</p><p>432 best_ast->packet_size = best_ast->remaining = best_st->index_entries[i].size;</p><p>433 }</p><p>434 }</p><p>435</p><p>436 resync:</p><p>437</p><p>438 if (avi->stream_index_2 >= 0)</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>439 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>如果找到最佳流索引，以此为根参数，取出其他参数和读取媒体数据。</p><p>440 AVStream *st = s->streams[avi->stream_index_2];</p><p>441 AVIStream *ast = st->priv_data;</p><p>442 int size;</p><p>443</p><p>444 if (ast->sample_size &lt;= 1) // minorityreport.AVI block_align=1024 sample_size=1 IMA- ADPCM</p><p>445 size = INT_MAX;</p><p>446 else if (ast->sample_size &lt; 32)</p><p>447 size = 64 * ast->sample_size;</p><p>448 else</p><p>449 size = ast->sample_size;</p><p>450<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>在缓存足够大，一次全部读取一帧媒体数据的情况下，451 行判断不成立，size 等于 ast->sample_size</p><p>451 if (size > ast->remaining)</p><p>452 size = ast->remaining;</p><p>453<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>调用 av_get_packet()函数实际读取媒体数据到 pkt 包中。</p><p>454 av_get_packet(pb, pkt, size);</p><p>455<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>修改媒体流的一些其他参数。</p><p>456 pkt->dts = ast->frame_offset;</p><p>457</p><p>458 if (ast->sample_size)</p><p>459 pkt->dts /= ast->sample_size;</p><p>460</p><p>461 pkt->stream_index = avi->stream_index_2;</p><p>462<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>在简单情况顺序播放时，463 行到 487 行没有什么实际意义。</p><p>463 if (st->actx->codec_type == CODEC_TYPE_VIDEO)</p><p>464 {</p><p>465 if (st->index_entries)</p><p>466 {</p><p>467 AVIndexEntry *e;</p><p>468 int index;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>469</p><p>470 index = av_index_search_timestamp(st, pkt->dts, 0);</p><p>471 e = &st->index_entries[index];</p><p>472</p><p>473 if (index >= 0 && e->timestamp == ast->frame_offset)</p><p>474 {</p><p>475 if (e->flags &AVINDEX_KEYFRAME)</p><p>476 pkt->flags |= PKT_FLAG_KEY;</p><p>477 }</p><p>478 }</p><p>479 else</p><p>480 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果没有索引，较好的办法是把所有帧都设为关键帧。</p><p>|481||pkt->flags |= PKT_FLAG_KEY;|
| - | - | - |
|482|}||
|483|}||
|484|else||
|485|{||
486 pkt->flags |= PKT_FLAG_KEY;</p><p>487 }</p><p>488<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>修改帧偏移。</p><p>489 if (ast->sample_size)</p><p>490 ast->frame_offset += pkt->size;</p><p>491 else</p><p>492 ast->frame_offset++;</p><p>493</p><p>494 ast->remaining -= size;</p><p>495 if (!ast->remaining)</p><p>496 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>缓存足够大时，程序一定跑到这里，复位标志性参数。</p><p>497 avi->stream_index_2 = - 1;</p><p>498 ast->packet_size = 0;</p><p>499 if (size &1)</p><table><thead><tr><th>500</th><th>{</th><th></th></tr></thead><tbody><tr><td>501</td><td></td><td>get_byte(pb);</td></tr><tr><td>502</td><td></td><td>size++;</td></tr><tr><td>503</td><td>}</td><td></td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>504 }</p><p>505<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>返回实际读到的数据大小。</p><p>506 return size;</p><p>507 }</p><p>508</p><p>509 memset(d, - 1, sizeof(int) *8);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>把数组 d[8]清为-1，为了在下面的流标记查找时不会出错。</p><p>510 for (i = sync = url_ftell(pb); !url_feof(pb); i++)</p><p>511 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>交织 avi 时顺序读取文件，媒体数据。</p><p>512 int j;</p><p>513</p><p>514 if (i >= avi->movi_end)</p><p>515 break;</p><p>516</p><p>首先要找到流标记，比如 00db,00dc,01w b 等。在 32bit CPU 上为存取数据方便，把 avi 文件中的帧标记</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.095.png alt>和帧大小共 8 个字节对应赋值到 in t 型数组 d[8]中，这样每次是整数操作。</p><p>517 for (j = 0; j &lt; 7; j++)</p><p>518 d[j] = d[j + 1];</p><p>519<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>518 行把整型缓存前移一个单位。520 行从文件中读一个字节补充到整型缓存，计算包大小和流索引。</p><p>520 d[7] = get_byte(pb);</p><p>521</p><p>522 size = d[4] + (d[5] &lt;&lt; 8) + (d[6] &lt;&lt; 16) + (d[7] &lt;&lt; 24);</p><p>523</p><p>524 if (d[2] >= '0' && d[2] &lt;= '9' && d[3] >= '0' && d[3] &lt;= '9')</p><p>525 {</p><p>526 n = (d[2] - '0') *10+(d[3] - '0');</p><p>527 }</p><p>528 else</p><p>529 {</p><p>530 n = 100; //invalid stream id</p><p>531 }</p><p>532<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.118.png alt></p><p>校验 size 大小，如果偏移位置加 size 超过数据块大小就不是有效的流标记。</p><p>校验流索引，如果&lt;0 就不是有效的流标记。流索引从 0 开始计数，媒体文件通常不超过 10 个流。</p><p>533 if (i + size > avi->movi_end || d[0] &lt; 0)</p><p>534 continue;</p><p>535<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>536 行到 541 行代码处理诸如 jun k 等需要跳过的块。</p><p>536 if ((d[0] == 'i' && d[1] == 'x' && n &lt; s->nb_streams)</p><p>537 || (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K'))</p><p>538 {</p><p>539 url_fskip(pb, size);</p><p>540 goto resync;</p><p>541 }</p><p>542<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>计算流索引号 n。</p><p>543 if (d[0] >= '0' && d[0] &lt;= '9' && d[1] >= '0' && d[1] &lt;= '9')</p><p>544 {</p><p>545 n = (d[0] - '0') *10+(d[1] - '0');</p><p>546 }</p><p>547 else</p><p>548 {</p><p>549 n = 100; //invalid stream id</p><p>550 }</p><p>551</p><p>552 //parse ##dc/##wb</p><p>553 if (n &lt; s->nb_streams)</p><p>554 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果流索引号 n 比流总数小，认为有效。(我个人认为这个校验不太严格。)</p><p>555 AVStream *st;</p><p>556 AVIStream *ast;</p><p>557 st = s->streams[n];</p><p>558 ast = st->priv_data;</p><p>559</p><p>560 if (((ast->prefix_count &lt; 5 || sync + 9 > i) && d[2] &lt; 128 && d[3] &lt; 128)</p><p>561 || d[2] * 256 + d[3] == ast->prefix)</p><p>562 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>if(d[2]*256+d[3]==ast->prefix)为真表示 "db","dc","wb"等字串匹配，找到正确帧标记。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.119.png alt>判断 d[2]&lt;128 && d[3]&lt;128 是因为 'd','b','c','w'等字符的 ascii 码小于 128。</p><p>判断 ast->prefix_count&lt;5 || sync + 9 > i，是判断单一媒体的 5 帧内或找帧标记超过 9 个字节。</p><p>563 行到 569 行是单一媒体帧边界初次识别成功和以后识别成功的简单处理，计数自增或保存标记。</p><p>563 if (d[2] * 256 + d[3] == ast->prefix)</p><p>564 ast->prefix_count++;</p><p>565 else</p><p>566 {</p><p>567 ast->prefix = d[2] *256+d[3];</p><p>568 ast->prefix_count = 0;</p><p>569 }</p><p>570<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>找到相应的流索引后，保存相关参数，跳转到实质性读媒体程序。</p><p>571 avi->stream_index_2 = n;</p><p>572 ast->packet_size = size + 8;</p><p>573 ast->remaining = size;</p><p>574 goto resync;</p><p>575 }</p><p>576 }</p><p>577 // palette changed chunk</p><p>578 if (d[0] >= '0' && d[0] &lt;= '9' && d[1] >= '0' && d[1] &lt;= '9'</p><p>579 && (d[2] == 'p' && d[3] == 'c') && n &lt; s->nb_streams && i + size &lt;= avi->movi_end)</p><p>580 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.102.png alt></p><p>处理调色板改变块数据，读取调色板数据到编解码器上下文的调色板数组中。</p><p>581 AVStream *st;</p><p>582 int first, clr, flags, k, p;</p><p>583</p><p>584 st = s->streams[n];</p><p>585</p><p>586 first = get_byte(pb);</p><p>587 clr = get_byte(pb);</p><p>588 if (!clr) // all 256 colors used</p><p>589 clr = 256;</p><p>590 flags = get_le16(pb);</p><p>591 p = 4;</p><p>592 for (k = first; k &lt; clr + first; k++)</p><p>593 {</p><p>594 int r, g, b;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>595 r = get_byte(pb);</p><p>596 g = get_byte(pb);</p><p>597 b = get_byte(pb);</p><p>598 get_byte(pb);</p><p>599 st->actx->palctrl->palette[k] = b + (g &lt;&lt; 8) + (r &lt;&lt; 16);</p><p>600 }</p><p>601 st->actx->palctrl->palette_changed = 1;</p><p>602 goto resync;</p><p>603 }</p><p>604 }</p><p>605</p><p>606 return - 1;</p><p>607 }</p><p>608<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>实质读取 AVI 文件的索引。</p><p>609 static int avi_read_idx1(AVFormatContext *s, int size)</p><p>610 {</p><p>611 AVIContext *avi = s->priv_data;</p><p>612 ByteIOContext *pb = &s->pb;</p><p>613 int nb_index_entries, i;</p><p>614 AVStream *st;</p><p>615 AVIStream *ast;</p><p>616 unsigned int index, tag, flags, pos, len;</p><p>617 unsigned last_pos = - 1;</p><p>618</p><p>619 nb_index_entries = size / 16;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>如果没有索引块 chunk，直接返回。</p><p>620 if (nb_index_entries &lt;= 0)</p><p>621 return - 1;</p><p>622<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>遍历整个索引项。</p><p>623 for (i = 0; i &lt; nb_index_entries; i++)</p><p>624 {</p><p>625 tag = get_le32(pb);</p><p>626 flags = get_le32(pb);</p><p>627 pos = get_le32(pb);</p><p>628 len = get_le32(pb);</p><p>629</p><p>如果第一个索引指示的偏移量大于数据块的偏移量，则索引指示的偏移量是相对文件开始字节的偏移</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.120.png alt>量。索引加载到内存后，如果是相对数据块的偏移量就要换算成相对于文件开始字节的偏移量，便于 seek</p><p>操作。在 631 行和 633 行统一处理这两个情况。</p><p>630 if (i == 0 && pos > avi->movi_list)</p><p>631 avi->movi_list = 0;</p><p>632</p><p>633 pos += avi->movi_list;</p><p>634<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>计算流 ID，如索引块中的 00dc，01w b 等关键字表示的流 ID 分别为数字 0 和 1。</p><p>635 index = ((tag &0xff) - '0') *10;</p><p>636 index += ((tag >> 8) &0xff) - '0';</p><p>637 if (index >= s->nb_streams)</p><p>638 continue;</p><p>639</p><p>640 st = s->streams[index];</p><p>641 ast = st->priv_data;</p><p>642</p><p>643 if (last_pos == pos)</p><p>644 avi->non_interleaved = 1;</p><p>645 else</p><p>646 av_add_index_entry(st, pos, ast->cum_len, len, 0, (flags&AVIIF_INDEX)?AVINDEX_KEYFRAME:0);</p><p>647</p><p>648 if (ast->sample_size)</p><p>649 ast->cum_len += len / ast->sample_size;</p><p>650 else</p><p>651 ast->cum_len++;</p><p>652 last_pos = pos;</p><p>653 }</p><p>654 return 0;</p><p>655 }</p><p>656</p><p>判断是否是非交织存放媒体数据，其中 ni 是 non_interleaved 的缩写，非交织的意思。如果是非交织</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.121.png alt>存放返回 1，交织存放返回 0。</p><p>非交织存放的 avi 文件，如果有多个媒体流，肯定有某个流的开始字节文件偏移量大于其他某个流的 末尾字节的文件偏移量。程序利用这个来判断是否是非交织存放，否则认定为交织存放。</p><p>657 static int guess_ni_flag(AVFormatContext *s)</p><p>658 {</p><p>659 int i;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>660 int64_t last_start = 0;</p><p>661 int64_t first_end = INT64_MAX;</p><p>662<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.101.png alt></p><p>遍历 AVI 文件中所有的索引，取流开始偏移量的最大值和末尾偏移量的最小值判断。</p><p>663 for (i = 0; i &lt; s->nb_streams; i++)</p><p>664 {</p><p>665 AVStream *st = s->streams[i];</p><p>666 int n = st->nb_index_entries;</p><p>667<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.101.png alt></p><p>如果某个流没有 index 项，认为这个流没有数据，这个流忽略不计。</p><p>668 if (n &lt;= 0)</p><p>669 continue;</p><p>670<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.101.png alt></p><p>遍历 AVI 文件中所有的索引，取流开始偏移量的最大值。</p><p>671 if (st->index_entries[0].pos > last_start)</p><p>672 last_start = st->index_entries[0].pos;</p><p>673<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.101.png alt></p><p>遍历 AVI 文件中所有的索引，取流末尾偏移量的最小值。</p><p>674 if (st->index_entries[n - 1].pos &lt; first_end)</p><p>675 first_end = st->index_entries[n - 1].pos;</p><p>676 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.100.png alt></p><p>如果某个流的开始最大值大于某个流的末尾最小值，认为是非交织存储，否则是交织存储。</p><p>677 return last_start > first_end;</p><p>678 }</p><p>679</p><p>加载 AVI 文件索引块 chunk，特别注意在 avi_read_ idx1()函数调用的 av_add_index_entry()函数是分媒</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.109.png alt>体类型按照时间顺序重新排序的。</p><p>680 static int avi_load_index(AVFormatContext *s)</p><p>681 {</p><p>682 AVIContext *avi = s->priv_data;</p><p>683 ByteIOContext *pb = &s->pb;</p><p>684 uint32_t tag, size;</p><p>685 offset_t pos = url_ftell(pb);</p><p>686</p><p>687 url_fseek(pb, avi->movi_end, SEEK_SET);</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>688</p><p>689 for (;;)</p><p>690 {</p><p>691 if (url_feof(pb))</p><p>692 break;</p><p>693 tag = get_le32(pb);</p><p>694 size = get_le32(pb);</p><p>695</p><p>696 switch (tag)</p><p>697 {</p><p>698 case MKTAG('i', 'd', 'x', '1'):</p><p>699 if (avi_read_idx1(s, size) &lt; 0)</p><p>700 goto skip;</p><p>701 else</p><p>702 goto the_end;</p><p>703 break;</p><p>704 default:</p><p>705 skip:</p><p>706 size += (size &1);</p><p>707 url_fskip(pb, size);</p><p>708 break;</p><p>709 }</p><p>710 }</p><p>711 the_end:</p><p>712 url_fseek(pb, pos, SEEK_SET);</p><p>713 return 0;</p><p>714 }</p><p>715<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.094.png alt></p><p>关闭 AVI 文件，释放内存和其他相关资源。</p><p>716 static int avi_read_close(AVFormatContext *s)</p><p>717 {</p><p>718 int i;</p><p>719 AVIContext *avi = s->priv_data;</p><p>720</p><p>721 for (i = 0; i &lt; s->nb_streams; i++)</p><p>722 {</p><p>723 AVStream *st = s->streams[i];</p><p>724 AVIStream *ast = st->priv_data;</p><p>725 av_free(ast);</p><p>726 av_free(st->actx->extradata);</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>727 av_free(st->actx->palctrl);</p><p>728 }</p><p>729</p><p>730 return 0;</p><p>731 }</p><p>732<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>AVI 文件判断，取 AVI 文件的关键字串"RIFF"和"AVI "判断，和 get_riff()函数部分相同。</p><p>733 static int avi_probe(AVProbeData *p)</p><p>734 {</p><p>735 if (p->buf_size &lt;= 32) // check file header</p><p>736 return 0;</p><p>737 if (p->buf[0] == 'R' && p->buf[1] == 'I' && p->buf[2] == 'F' && p->buf[3] == 'F'</p><p>738 && p->buf[8] == 'A' && p->buf[9] == 'V' && p->buf[10] == 'I'&& p->buf[11] == ' ')</p><p>739 return AVPROBE_SCORE_MAX;</p><p>740 else</p><p>741 return 0;</p><p>742 }</p><p>743<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>初始化 AVI 文件格式 AVInputFormat 结构，直接的赋值操作。</p><p>744 AVInputFormat avi_iformat =</p><p>745 {</p><p>746 "avi",</p><p>747 sizeof(AVIContext),</p><p>748 avi_probe,</p><p>749 avi_read_header,</p><p>750 avi_read_packet,</p><p>751 avi_read_close,</p><p>752 };</p><p>753<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.091.png alt></p><p>注册 avi 文件格式，ffplay 把所有支持的文件格式用链表串联起来，表头是 first_iformat，便于查找。</p><p>754 int avidec_init(void)</p><p>755 {</p><p>756 av_register_input_format(&avi_iformat);</p><p>757 return 0;</p><p>758 }</p><p>759</p><h2 id=54-libswscale视频色彩空间转换><strong>5.4 libswscale视频色彩空间转换</strong></h2><h2 id=55-libswresample音频重采样><strong>5.5 libswresample音频重采样</strong></h2><h2 id=56-libavfilter音视频滤器><strong>5.6 libavfilter音视频滤器</strong></h2><h2 id=57-libavdevice设备输入和输出容器><strong>5.7 libavdevice设备输入和输出容器</strong></h2><h2 id=58-libpostproc视频后期处理><strong>5.8 libpostproc视频后期处理</strong></h2><h1 id=第六章-播放器><strong>第六章 播放器</strong></h1><h2 id=61-视频播放器><strong>6.1 视频播放器</strong></h2><h3 id=611-ffmpeg库的配置><strong>6.1.1 ffmpeg库的配置</strong></h3><p>从http://ffmpeg.zeranoe.com/builds/网站上</p><p>1.下载Dev版本，里面包含了ffmpeg的xxx.h头文件以及xxx.lib库文件；</p><p>2.下载Shared版本，里面包含了ffmpeg的dll文件；</p><p>3.将这两部分文件拷贝到VC工程下面就可以了。</p><p><strong>FFMPEG 库移植到 VC 需要的步骤：</strong></p><p>在VC下使用FFMPEG编译好的库，不仅仅是把.h，.lib，.dll拷贝到工程中就行了，还需要做以下几步。（此方法适用于自己使用MinGW编译的库，也同样适用于从网上下载的编译好的库，例如http://ffmpeg.zeranoe.com/builds/）。</p><p>（1）像其他额外库一样，设置VC的Include路径为你c:\msys\local\include,设置VClib路径为次c:\msys\local\bin，增加操作系统的一个Path c:\msys\local\bin（这一步好像不是必须的）。</p><p>（2）将mingw安装目录下的include的inttypes.h，stdint.h，_mingw.h三个文件拷到你ffmpeg库的目录下的include</p><p>（3）在_mingw.h文件的结尾处(在#endif 一行之前)添加了一行：</p><p>#define __restrict__</p><p>（4）把所有long long改成了__int64，如果是直接在vs2008下编译，则这个修改应该是不需要的(这步我没有遇到)</p><p>（5）</p><p>#ifdef __cplusplus</p><p>#include "stdio.h"</p><p>#include "stdlib.h"</p><p>#include "string.h"</p><p>#include "SDL/SDL.h"</p><p>//#include "windows.h"</p><p>extern "C"</p><p>{</p><p><code></code>#include "ffmpeg/avutil.h"</p><p><code></code>#include "ffmpeg/avcodec.h"</p><p><code></code>#include "ffmpeg/avformat.h"</p><p>}</p><p>#endif</p><p>#pragma comment(lib,"avutil.lib")</p><p>#pragma comment(lib,"avcodec.lib")</p><p>#pragma comment(lib,"avformat.lib")</p><p>（6）如果遇到error C3861: 'UINT64_C': identifier not found</p><p>在common.h里加入定义如下：</p><p>#ifndef INT64_C</p><p>#define INT64_C(c) (c ## LL)</p><p>#define UINT64_C(c) (c ## ULL)</p><p>#endif</p><h3 id=612-一个简单的视频播放器><strong>6.1.2 一个简单的视频播放器</strong></h3><p>该播放器虽然简单，但是几乎包含了使用FFMPEG播放一个视频所有必备的API，并且使用SDL显示解码出来的视频。</p><p>并且支持流媒体等多种视频输入，处于简单考虑，没有音频部分，同时视频播放采用直接延时40ms的方式</p><p>平台使用VC2010</p><p>使用了最新的FFMPEG类库</p><p>int _tmain(int argc, _TCHAR* argv[])</p><p>{</p><p><code></code>AVFormatContext *pFormatCtx;</p><p><code></code>int i, videoindex;</p><p><code></code>AVCodecContext *pCodecCtx;</p><p><code></code>AVCodec *pCodec;</p><p><code></code>char filepath[]="nwn.mp4";</p><p><code></code>av_register_all();</p><p><code></code>avformat_network_init();</p><p><code></code>pFormatCtx = avformat_alloc_context();</p><p><code></code>if(avformat_open_input(&pFormatCtx,filepath,NULL,NULL)!=0){</p><p><code></code>printf("无法打开文件\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>if(av_find_stream_info(pFormatCtx)&lt;0)</p><p><code></code>{</p><p><code></code>printf("Couldn't find stream information.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>videoindex=-1;</p><p><code></code>for(i=0; i<pformatctx->nb_streams; i++)</p><p><code></code>if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)</p><p><code></code>{</p><p><code></code>videoindex=i;</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>if(videoindex==-1)</p><p><code></code>{</p><p><code></code>printf("Didn't find a video stream.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>pCodecCtx=pFormatCtx->streams[videoindex]->codec;</p><p><code></code>pCodec=avcodec_find_decoder(pCodecCtx->codec_id);</p><p><code></code>if(pCodec==NULL)</p><p><code></code>{</p><p><code></code>printf("Codec not found.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>if(avcodec_open(pCodecCtx, pCodec)&lt;0)</p><p><code></code>{</p><p><code></code>printf("Could not open codec.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>AVFrame *pFrame,*pFrameYUV;</p><p><code></code>pFrame=avcodec_alloc_frame();</p><p><code></code>pFrameYUV=avcodec_alloc_frame();</p><p><code></code>uint8_t *out_buffer;</p><p><code></code>out_buffer=new uint8_t[avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height)];</p><p><code></code>avpicture_fill((AVPicture *)pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx->width, pCodecCtx->height);</p><p>//------------SDL----------------</p><p><code></code>if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {</p><p><code></code>printf( "Could not initialize SDL - %s\n", SDL_GetError());</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>SDL_Surface *screen;</p><p><code></code>screen = SDL_SetVideoMode(pCodecCtx->width, pCodecCtx->height, 0, 0);</p><p><code></code>if(!screen) { printf("SDL: could not set video mode - exiting\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>SDL_Overlay *bmp;</p><p><code></code>bmp = SDL_CreateYUVOverlay(pCodecCtx->width, pCodecCtx->height,SDL_YV12_OVERLAY, screen);</p><p><code></code>SDL_Rect rect;</p><p>//---------------</p><p><code></code>int ret, got_picture;</p><p><code></code>static struct SwsContext *img_convert_ctx;</p><p><code></code>int y_size = pCodecCtx->width * pCodecCtx->height;</p><p><code></code>AVPacket *packet=(AVPacket *)malloc(sizeof(AVPacket));</p><p><code></code>av_new_packet(packet, y_size);</p><p><code></code>//输出一下信息-----------------------------</p><p><code></code>printf("文件信息-----------------------------------------\n");</p><p><code></code>av_dump_format(pFormatCtx,0,filepath,0);</p><p><code></code>printf("-------------------------------------------------\n");</p><p><code></code>//------------------------------</p><p><code></code>while(av_read_frame(pFormatCtx, packet)>=0)</p><p><code></code>{</p><p><code></code>if(packet->stream_index==videoindex)</p><p><code></code>{</p><p><code></code>ret = avcodec_decode_video2(pCodecCtx, pFrame, &got_picture, packet);</p><p><code></code>if(ret &lt; 0)</p><p><code></code>{</p><p><code></code>printf("解码错误\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>if(got_picture)</p><p><code></code>{</p><p><code></code>img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height, pCodecCtx->pix_fmt, pCodecCtx->width, pCodecCtx->height, PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);</p><p><code></code>sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame->data, pFrame->linesize, 0, pCodecCtx->height, pFrameYUV->data, pFrameYUV->linesize);</p><p><code></code>SDL_LockYUVOverlay(bmp);</p><p><code></code>bmp->pixels[0]=pFrameYUV->data[0];</p><p><code></code>bmp->pixels[2]=pFrameYUV->data[1];</p><p><code></code>bmp->pixels[1]=pFrameYUV->data[2];</p><p><code></code>bmp->pitches[0]=pFrameYUV->linesize[0];</p><p><code></code>bmp->pitches[2]=pFrameYUV->linesize[1];</p><p><code></code>bmp->pitches[1]=pFrameYUV->linesize[2];</p><p><code></code>SDL_UnlockYUVOverlay(bmp);</p><p><code></code>rect.x = 0;</p><p><code></code>rect.y = 0;</p><p><code></code>rect.w = pCodecCtx->width;</p><p><code></code>rect.h = pCodecCtx->height;</p><p><code></code>SDL_DisplayYUVOverlay(bmp, &rect);</p><p><code></code>//延时40ms</p><p><code></code>SDL_Delay(40);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>av_free_packet(packet);</p><p><code></code>}</p><p><code></code>delete[] out_buffer;</p><p><code></code>av_free(pFrameYUV);</p><p><code></code>avcodec_close(pCodecCtx);</p><p><code></code>avformat_close_input(&pFormatCtx);</p><p><code></code>return 0;</p><p>}</p><h2 id=62-音频播放器><strong>6.2 音频播放器</strong></h2><p>注意：</p><p>1.程序输出的解码后PCM音频数据可以使用Audition打开播放</p><p>2.m4a,aac文件可以直接播放。mp3文件需要调整SDL音频帧大小为4608（默认是4096），否则播放会不流畅</p><p>3.也可以播放视频中的音频</p><p>#include &lt;stdlib.h></p><p>#include &lt;string.h></p><p>extern "C"</p><p>{</p><p>#include "libavcodec/avcodec.h"</p><p>#include "libavformat/avformat.h"</p><p>//SDL</p><p>#include "sdl/SDL.h"</p><p>#include "sdl/SDL_thread.h"</p><p>};</p><p>#include "decoder.h"</p><p>//#include "wave.h"</p><p>//#define _WAVE_</p><p>//全局变量---------------------</p><p><code></code>static Uint8 *audio_chunk;</p><p><code></code>static Uint32 audio_len;</p><p><code></code>static Uint8 *audio_pos;</p><p>//-----------------</p><p><code></code>/* The audio function callback takes the following parameters:</p><p><code></code>stream: A pointer to the audio buffer to be filled</p><p><code></code>len: The length (in bytes) of the audio buffer (这是固定的4096？)</p><p><code></code>回调函数</p><p><code></code>注意：mp3为什么播放不顺畅？</p><p><code></code>len=4096;audio_len=4608;两个相差512！为了这512，还得再调用一次回调函数。。。</p><p><code></code>m4a,aac就不存在此问题(都是4096)！</p><p><code></code>*/</p><p><code></code>void fill_audio(void *udata,Uint8 *stream,int len){</p><p><code></code>/* Only play if we have data left */</p><p><code></code>if(audio_len==0)</p><p><code></code>return;</p><p><code></code>/* Mix as much data as possible */</p><p><code></code>len=(len>audio_len?audio_len:len);</p><p><code></code>SDL_MixAudio(stream,audio_pos,len,SDL_MIX_MAXVOLUME);</p><p><code></code>audio_pos += len;</p><p><code></code>audio_len -= len;</p><p><code></code>}</p><p>//-----------------</p><p>int decode_audio(char* no_use)</p><p>{</p><p><code></code>AVFormatContext *pFormatCtx;</p><p><code></code>int i, audioStream;</p><p><code></code>AVCodecContext *pCodecCtx;</p><p><code></code>AVCodec *pCodec;</p><p><code></code>char url[300]={0};</p><p><code></code>strcpy(url,no_use);</p><p><code></code>//Register all available file formats and codecs</p><p><code></code>av_register_all();</p><p><code></code>//支持网络流输入</p><p><code></code>avformat_network_init();</p><p><code></code>//初始化</p><p><code></code>pFormatCtx = avformat_alloc_context();</p><p><code></code>//有参数avdic</p><p><code></code>//if(avformat_open_input(&pFormatCtx,url,NULL,&avdic)!=0){</p><p><code></code>if(avformat_open_input(&pFormatCtx,url,NULL,NULL)!=0){</p><p><code></code>printf("Couldn't open file.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>// Retrieve stream information</p><p><code></code>if(av_find_stream_info(pFormatCtx)&lt;0)</p><p><code></code>{</p><p><code></code>printf("Couldn't find stream information.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>// Dump valid information onto standard error</p><p><code></code>av_dump_format(pFormatCtx, 0, url, false);</p><p><code></code>// Find the first audio stream</p><p><code></code>audioStream=-1;</p><p><code></code>for(i=0; i &lt; pFormatCtx->nb_streams; i++)</p><p><code></code>//原为codec_type==CODEC_TYPE_AUDIO</p><p><code></code>if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_AUDIO)</p><p><code></code>{</p><p><code></code>audioStream=i;</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>if(audioStream==-1)</p><p><code></code>{</p><p><code></code>printf("Didn't find a audio stream.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>// Get a pointer to the codec context for the audio stream</p><p><code></code>pCodecCtx=pFormatCtx->streams[audioStream]->codec;</p><p><code></code>// Find the decoder for the audio stream</p><p><code></code>pCodec=avcodec_find_decoder(pCodecCtx->codec_id);</p><p><code></code>if(pCodec==NULL)</p><p><code></code>{</p><p><code></code>printf("Codec not found.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>// Open codec</p><p><code></code>if(avcodec_open(pCodecCtx, pCodec)&lt;0)</p><p><code></code>{</p><p><code></code>printf("Could not open codec.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>/********* For output file ******************/</p><p><code></code>FILE *pFile;</p><p>#ifdef _WAVE_</p><p><code></code>pFile=fopen("output.wav", "wb");</p><p><code></code>fseek(pFile, 44, SEEK_SET); //预留文件头的位置</p><p>#else</p><p><code></code>pFile=fopen("output.pcm", "wb");</p><p>#endif</p><p><code></code>// Open the time stamp file</p><p><code></code>FILE *pTSFile;</p><p><code></code>pTSFile=fopen("audio_time_stamp.txt", "wb");</p><p><code></code>if(pTSFile==NULL)</p><p><code></code>{</p><p><code></code>printf("Could not open output file.\n");</p><p><code></code>return -1;</p><p><code></code>}</p><p><code></code>fprintf(pTSFile, "Time Base: %d/%d\n", pCodecCtx->time_base.num, pCodecCtx->time_base.den);</p><p><code></code>/*** Write audio into file ******/</p><p><code></code>//把结构体改为指针</p><p><code></code>AVPacket *packet=(AVPacket *)malloc(sizeof(AVPacket));</p><p><code></code>av_init_packet(packet);</p><p><code></code>//音频和视频解码更加统一！</p><p><code></code>//新加</p><p><code></code>AVFrame *pFrame;</p><p><code></code>pFrame=avcodec_alloc_frame();</p><p><code></code>//---------SDL--------------------------------------</p><p><code></code>//初始化</p><p><code></code>if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {</p><p><code></code>printf( "Could not initialize SDL - %s\n", SDL_GetError());</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>//结构体，包含PCM数据的相关信息</p><p><code></code>SDL_AudioSpec wanted_spec;</p><p><code></code>wanted_spec.freq = pCodecCtx->sample_rate;</p><p><code></code>wanted_spec.format = AUDIO_S16SYS;</p><p><code></code>wanted_spec.channels = pCodecCtx->channels;</p><p><code></code>wanted_spec.silence = 0;</p><p><code></code>wanted_spec.samples = 1024; //播放AAC，M4a，缓冲区的大小</p><p><code></code>//wanted_spec.samples = 1152; //播放MP3，WMA时候用</p><p><code></code>wanted_spec.callback = fill_audio;</p><p><code></code>wanted_spec.userdata = pCodecCtx;</p><p><code></code>if (SDL_OpenAudio(&wanted_spec, NULL)&lt;0)//步骤（2）打开音频设备</p><p><code></code>{</p><p><code></code>printf("can't open audio.\n");</p><p><code></code>return 0;</p><p><code></code>}</p><p><code></code>//-----------------------------------------------------</p><p><code></code>printf("比特率 %3d\n", pFormatCtx->bit_rate);</p><p><code></code>printf("解码器名称 %s\n", pCodecCtx->codec->long_name);</p><p><code></code>printf("time_base %d \n", pCodecCtx->time_base);</p><p><code></code>printf("声道数 %d \n", pCodecCtx->channels);</p><p><code></code>printf("sample per second %d \n", pCodecCtx->sample_rate);</p><p><code></code>//新版不再需要</p><p>// short decompressed_audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * 3) / 2];</p><p>// int decompressed_audio_buf_size;</p><p><code></code>uint32_t ret,len = 0;</p><p><code></code>int got_picture;</p><p><code></code>int index = 0;</p><p><code></code>while(av_read_frame(pFormatCtx, packet)>=0)</p><p><code></code>{</p><p><code></code>if(packet->stream_index==audioStream)</p><p><code></code>{</p><p><code></code>//decompressed_audio_buf_size = (AVCODEC_MAX_AUDIO_FRAME_SIZE * 3) / 2;</p><p><code></code>//原为avcodec_decode_audio2</p><p><code></code>//ret = avcodec_decode_audio4( pCodecCtx, decompressed_audio_buf,</p><p><code></code>//&decompressed_audio_buf_size, packet.data, packet.size );</p><p><code></code>//改为</p><p><code></code>ret = avcodec_decode_audio4( pCodecCtx, pFrame,</p><p><code></code>&got_picture, packet);</p><p><code></code>if ( ret &lt; 0 ) // if error len = -1</p><p><code></code>{</p><p><code></code>printf("Error in decoding audio frame.\n");</p><p><code></code>exit(0);</p><p><code></code>}</p><p><code></code>if ( got_picture > 0 )</p><p><code></code>{</p><p>#if 1</p><p><code></code>printf("index %3d\n", index);</p><p><code></code>printf("pts %5d\n", packet->pts);</p><p><code></code>printf("dts %5d\n", packet->dts);</p><p><code></code>printf("packet_size %5d\n", packet->size);</p><p><code></code>//printf("test %s\n", rtmp->m_inChunkSize);</p><p>#endif</p><p><code></code>//直接写入</p><p><code></code>//注意：数据是data【0】，长度是linesize【0】</p><p>#if 1</p><p><code></code>fwrite(pFrame->data[0], 1, pFrame->linesize[0], pFile);</p><p><code></code>//fwrite(pFrame, 1, got_picture, pFile);</p><p><code></code>//len+=got_picture;</p><p><code></code>index++;</p><p><code></code>//fprintf(pTSFile, "%4d,%5d,%8d\n", index, decompressed_audio_buf_size, packet.pts);</p><p>#endif</p><p><code></code>}</p><p>#if 1</p><p><code></code>//---------------------------------------</p><p><code></code>//printf("begin....\n");</p><p><code></code>//设置音频数据缓冲,PCM数据</p><p><code></code>audio_chunk = (Uint8*) pFrame->data[0];</p><p><code></code>//设置音频数据长度</p><p><code></code>audio_len = pFrame->linesize[0];</p><p><code></code>//audio_len = 4096;</p><p><code></code>//播放mp3的时候改为audio_len = 4096</p><p><code></code>//则会比较流畅，但是声音会变调！MP3一帧长度4608</p><p><code></code>//使用一次回调函数（4096字节缓冲）播放不完，所以还要使用一次回调函数，导致播放缓慢。。。</p><p><code></code>//设置初始播放位置</p><p><code></code>audio_pos = audio_chunk;</p><p><code></code>//回放音频数据</p><p><code></code>SDL_PauseAudio(0);</p><p><code></code>//printf("don't close, audio playing...\n");</p><p><code></code>while(audio_len>0)//等待直到音频数据播放完毕!</p><p><code></code>SDL_Delay(1);</p><p><code></code>//---------------------------------------</p><p>#endif</p><p><code></code>}</p><p><code></code>// Free the packet that was allocated by av_read_frame</p><p><code></code>//已改</p><p><code></code>av_free_packet(packet);</p><p><code></code>}</p><p><code></code>//printf("The length of PCM data is %d bytes.\n", len);</p><p>#ifdef _WAVE_</p><p><code></code>fseek(pFile, 0, SEEK_SET);</p><p><code></code>struct WAVE_HEADER wh;</p><p><code></code>memcpy(wh.header.RiffID, "RIFF", 4);</p><p><code></code>wh.header.RiffSize = 36 + len;</p><p><code></code>memcpy(wh.header.RiffFormat, "WAVE", 4);</p><p><code></code>memcpy(wh.format.FmtID, "fmt ", 4);</p><p><code></code>wh.format.FmtSize = 16;</p><p><code></code>wh.format.wavFormat.FormatTag = 1;</p><p><code></code>wh.format.wavFormat.Channels = pCodecCtx->channels;</p><p><code></code>wh.format.wavFormat.SamplesRate = pCodecCtx->sample_rate;</p><p><code></code>wh.format.wavFormat.BitsPerSample = 16;</p><p><code></code>calformat(wh.format.wavFormat); //Calculate AvgBytesRate and BlockAlign</p><p><code></code>memcpy(wh.data.DataID, "data", 4);</p><p><code></code>wh.data.DataSize = len;</p><p><code></code>fwrite(&wh, 1, sizeof(wh), pFile);</p><p>#endif</p><p><code></code>SDL_CloseAudio();//关闭音频设备</p><p><code></code>// Close file</p><p><code></code>fclose(pFile);</p><p><code></code>// Close the codec</p><p><code></code>avcodec_close(pCodecCtx);</p><p><code></code>// Close the video file</p><p><code></code>av_close_input_file(pFormatCtx);</p><p><code></code>return 0;</p><p>}</p><h2 id=63-一个完整的播放器--ffplay><strong>6.3 一个完整的播放器--ffplay</strong></h2><h3 id=631-ffplay流程图><strong>6.3.1 ffplay流程图</strong></h3><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.122.jpeg alt></p><h3 id=632-ffplay源码剖析><strong>6.3.2 ffplay源码剖析</strong></h3><p>ffplay.c 文件</p><p>1 功能描述</p><p>主控文件，初始化运行环境，把各个数据结构和功能函数有机组织起来，协调数据流和功能函数，响应用户 操作，启动并控制程序运行。</p><p>2 文件注释</p><p>1 #include "./libavformat/avformat.h"</p><p>2</p><p>3 #if defined(CONFIG_WIN32)</p><p>4 #include &lt;sys/types.h></p><p>5 #include &lt;sys/timeb.h></p><p>6 #include &lt;windows.h></p><p>7 #else</p><p>8 #include &lt;fcntl.h></p><p>9 #include &lt;sys/time.h></p><p>10 #endif</p><p>11</p><p>12 #include &lt;time.h></p><p>13</p><p>14 #include &lt;math.h></p><p>15 #include &lt;SDL.h></p><p>16 #include &lt;SDL_thread.h></p><p>17</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>SDL 里面定义了 main 函数，所以在这里取消 sdl 中的 main 定义，避免重复定义。</p><p>18 #ifdef CONFIG_WIN32</p><p>19 #undef main // We don't want SDL to override our main()</p><p>20 #endif</p><p>21</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>导入 SDL 库。</p><p>22 #pragma comment(lib, "SDL.lib")</p><p>23</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>简单的几个常数定义。</p><p>24 #define FF_QUIT_EVENT (SDL_USEREVENT + 2)</p><p>25</p><p>26 #define MAX_VIDEOQ_SIZE (5 * 256 * 1024)</p><p>27 #define MAX_AUDIOQ_SIZE (5 * 16 * 1024)</p><p>28</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>29 #define VIDEO_PICTURE_QUEUE_SIZE 1</p><p>30</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>音视频数据包/数据帧队列数据结构定义，几个数据成员一看就明白，不详述。</p><p>31 typedef struct PacketQueue</p><p>32 {</p><p>33 AVPacketList *first_pkt, *last_pkt;</p><p>34 int size;</p><p>35 int abort_request;</p><p>36 SDL_mutex *mutex;</p><p>37 SDL_cond *cond;</p><p>38 } PacketQueue;</p><p>39</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>视频图像数据结构定义，几个数据成员一看就明白，不详述。</p><p>40 typedef struct VideoPicture</p><p>41 {</p><p>42 SDL_Overlay *bmp;</p><p>43 int width, height; // source height & width</p><p>44 } VideoPicture;</p><p>45</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.123.png alt>总控数据结构，把其他核心数据结构整合在一起，起一个中转的作用，便于在各个子结构之间跳转。</p><p>46 typedef struct VideoState</p><p>47 {</p><p>48 SDL_Thread *parse_tid; // Demux 解复用线程指针</p><p>49 SDL_Thread *video_tid; // video 解码线程指针</p><p>50</p><p>51 int abort_request; // 异常退出请求标记</p><p>52</p><p>53 AVFormatContext *ic; // 输入文件格式上下文指针，和 iformat 配套使用</p><p>54</p><p>55 int audio_stream; // 音频流索引，表示 AVFormatContext 中 AVStream *streams[] 数组索引</p><p>56 int video_stream; // 视频流索引，表示 AVFormatContext 中 AVStream *streams[] 数组索引</p><p>57</p><p>58 AVStream *audio_st; // 音频流指针</p><p>59 AVStream *video_st; // 视频流指针</p><p>60</p><p>61 PacketQueue audioq; // 音频数据帧/数据包队列</p><p>62 PacketQueue videoq; // 视频数据帧/数据包队列</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>63</p><p>64 VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE]; // 解码后视频图像队列数组</p><p>65 double frame_last_delay; // 视频帧延迟，可简单认为是显示间隔时间</p><p>66</p><p>67 uint8_t audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE *3) / 2]; // 输出音频缓存</p><p>68 unsigned int audio_buf_size; // 解码后音频数据大小</p><p>69 int audio_buf_index; // 已输出音频数据大小</p><p>70 AVPacket audio_pkt; // 如果一个音频包中有多个帧，用于保存中间状态</p><p>71 uint8_t *audio_pkt_data; // 音频包数据首地址，配合 audio_pkt 保存中间状态</p><p>72 int audio_pkt_size; // 音频包数据大小，配合 audio_pkt 保存中间状态</p><p>73</p><p>74 SDL_mutex *video_decoder_mutex; // 视频数据包队列同步操作而定义的互斥量指针</p><p>75 SDL_mutex *audio_decoder_mutex; // 音频数据包队列同步操作而定义的互斥量指针</p><p>76</p><p>77 char filename[240]; // 媒体文件名</p><p>78</p><p>79 } VideoState;</p><p>80</p><p>81 static AVInputFormat *file_iformat;</p><p>82 static const char *input_filename;</p><p>83 static VideoState *cur_stream;</p><p>84<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>SDL 库需要的显示表面。</p><p>85 static SDL_Surface *screen;</p><p>86<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>取得当前时间，以 1/1000000 秒为单位，为便于在各个平台上移植，由宏开关控制编译的代码。</p><p>87 int64_t av_gettime(void)</p><p>88 {</p><p>89 #if defined(CONFIG_WINCE)</p><p>90 return timeGetTime() *int64_t_C(1000);</p><p>91 #elif defined(CONFIG_WIN32)</p><p>92 struct _timeb tb;</p><p>93 _ftime(&tb);</p><p>94 return ((int64_t)tb.time *int64_t_C(1000) + (int64_t)tb.millitm) *int64_t_C(1000);</p><p>95 #else</p><p>96 struct timeval tv;</p><p>97 gettimeofday(&tv, NULL);</p><p>98 return (int64_t)tv.tv_sec *1000000+tv.tv_usec;</p><p>99 #endif<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>100 }</p><p>101</p><p>数据帧/数据包生命周期：</p><p>1：在 av_get_packet()函数中调用 av_malloc()函数分配内存，并调用 url_fread()填充媒体数据。</p><p>2：如果是视频包调用 packet_queue_put()进 is->videoq 队列，如果是音频包进 is->audioq 队列， 如果是其他包，就调用 av_free_packet()函数直接释放内存。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.126.png alt></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.125.png alt>3：进入队列的包，用 packet_queue_get()取出队列，用 av_free_packet()释放内存。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt>初始化队列，初始化为 0 后再创建线程同步使用的互斥和条件。</p><p>102 static void packet_queue_init(PacketQueue *q) // packet queue handling</p><p>103 {</p><p>104 memset(q, 0, sizeof(PacketQueue));</p><p>105 q->mutex = SDL_CreateMutex();</p><p>106 q->cond = SDL_CreateCond();</p><p>107 }</p><p>108</p><p>刷新队列，释放掉队列中所有动态分配的内存，包括音视频裸数据占用的内存和 AVPacketList 结构占</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.127.png alt>用的内存，参考上面示意图。</p><p>109 static void packet_queue_flush(PacketQueue *q)</p><p>110 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>111 AVPacketList *pkt, *pkt1;</p><p>112<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>由于是多线程程序，需要同步，所以在遍历队列释放所有动态分配内存前，加锁。</p><p>113 SDL_LockMutex(q->mutex);</p><p>114 for (pkt = q->first_pkt; pkt != NULL; pkt = pkt1)</p><p>115 {</p><p>116 pkt1 = pkt->next;</p><p>117 av_free_packet(&pkt->pkt); // 释放音视频数据内存</p><p>118 av_freep(&pkt); // 释放 AVPacketList 结构</p><p>119 }</p><p>120 q->last_pkt = NULL;</p><p>121 q->first_pkt = NULL;</p><p>122 q->size = 0;</p><p>123 SDL_UnlockMutex(q->mutex);</p><p>124 }</p><p>125<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>释放队列占用所有资源，首先释放掉所有动态分配的内存，接着释放申请的互斥量和条件量。</p><p>126 static void packet_queue_end(PacketQueue *q)</p><p>127 {</p><p>128 packet_queue_flush(q);</p><p>129 SDL_DestroyMutex(q->mutex);</p><p>130 SDL_DestroyCond(q->cond);</p><p>131 }</p><p>132<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>往音视频队列中挂接音视频数据帧/数据包。</p><p>133 static int packet_queue_put(PacketQueue *q, AVPacket *pkt)</p><p>134 {</p><p>135 AVPacketList *pkt1;</p><p>136<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>先分配一个 AVPacketList 结构内存，接着，140 行从 AVPacket 浅复制数据，141 行链表尾置空。</p><p>137 pkt1 = av_malloc(sizeof(AVPacketList));</p><p>138 if (!pkt1)</p><p>139 return - 1;</p><p>140 pkt1->pkt = *pkt;</p><p>141 pkt1->next = NULL;</p><p>142</p><p>143 SDL_LockMutex(q->mutex);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>144<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>往队列中挂接 AVPacketList，并且在 150 行统计缓存的媒体数据大小。</p><p>145 if (!q->last_pkt)</p><p>146 q->first_pkt = pkt1;</p><p>147 else</p><p>148 q->last_pkt->next = pkt1;</p><p>149 q->last_pkt = pkt1;</p><p>150 q->size += pkt1->pkt.size;</p><p>151<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>设置条件量为有信号状态，如果解码线程因等待而睡眠就及时唤醒。</p><p>152 SDL_CondSignal(q->cond);</p><p>153</p><p>154 SDL_UnlockMutex(q->mutex);</p><p>155 return 0;</p><p>156 }</p><p>157<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>设置 异常请求退出 状态。</p><p>158 static void packet_queue_abort(PacketQueue *q)</p><p>159 {</p><p>160 SDL_LockMutex(q->mutex);</p><p>161</p><p>162 q->abort_request = 1; // 请求异常退出</p><p>163</p><p>164 SDL_CondSignal(q->cond);</p><p>165</p><p>166 SDL_UnlockMutex(q->mutex);</p><p>167 }</p><p>168<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>从队列中取出一帧/包数据。</p><p>169 /* return &lt; 0 if aborted, 0 if no packet and > 0 if packet. */</p><p>170 static int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block)</p><p>171 {</p><p>172 AVPacketList *pkt1;</p><p>173 int ret;</p><p>174</p><p>175 SDL_LockMutex(q->mutex);</p><p>176<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>177 for (;;)</p><p>178 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>如果异常请求退出标记置位，就带错误码返回。</p><p>179 if (q->abort_request)</p><p>180 {</p><p>181 ret = - 1;</p><p>182 break;</p><p>183 }</p><p>184</p><p>185 pkt1 = q->first_pkt;</p><p>186 if (pkt1)</p><p>187 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>如果队列中有数据，就取第一个数据包，在 191 行修正缓存的媒体大小，在 192 行浅复制帧/包数据</p><p>188 q->first_pkt = pkt1->next;</p><p>189 if (!q->first_pkt)</p><p>190 q->last_pkt = NULL;</p><p>191 q->size -= pkt1->pkt.size;</p><p>192 *pkt = pkt1->pkt;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>释放掉 AVPacketList 结构，此结构在 packet_queue_put()函数中动态分配(137 行代码处)。</p><p>193 av_free(pkt1);</p><p>194 ret = 1;</p><p>195 break;</p><p>196 }</p><p>197 else if (!block)</p><p>198 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>如果是非阻塞模式，没数据就直接返回 0。</p><p>199 ret = 0;</p><p>200 break;</p><p>201 }</p><p>202 else</p><p>203 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>如果是阻塞模式，没数据就进入睡眠状态等待，packet_queue_put()中唤醒(152 行代码处)。</p><p>204 SDL_CondWait(q->cond, q->mutex);</p><p>205 }</p><p>206 }</p><p>207 SDL_UnlockMutex(q->mutex);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>208 return ret;</p><p>209 }</p><p>210<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.124.png alt></p><p>分配 SDL 库需要的 Overlay 显示表面，并设置长宽属性。</p><p>211 static void alloc_picture(void *opaque)</p><p>212 {</p><p>213 VideoState *is = opaque;</p><p>214 VideoPicture *vp;</p><p>215</p><p>216 vp = &is->pictq[0];</p><p>217</p><p>218 if (vp->bmp)</p><p>219 SDL_FreeYUVOverlay(vp->bmp);</p><p>220</p><p>221 vp->bmp = SDL_CreateYUVOverlay(is->video_st->actx->width,</p><p>222 is->video_st->actx->height,</p><p>223 SDL_YV12_OVERLAY,</p><p>224 screen);</p><p>225</p><p>226 vp->width = is->video_st->actx->width;</p><p>227 vp->height = is->video_st->actx->height;</p><p>228 }</p><p>229</p><p>解码后的视频图像在等待显示间隔时间后，做颜色空间转换，调用 SDL 库显示。简单认为 cpu 耗在</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.128.png alt>前面读文件，解复用，解码的时间为 0，做简单的同步处理逻辑。</p><p>230 static int queue_picture(VideoState *is, AVFrame *src_frame, double pts)</p><p>231 {</p><p>232 VideoPicture *vp;</p><p>233 int dst_pix_fmt;</p><p>234 AVPicture pict;</p><p>235</p><p>236 if (is->videoq.abort_request)</p><p>237 return - 1;</p><p>238</p><p>239 vp = &is->pictq[0];</p><p>240</p><p>241 /* if the frame is not skipped, then display it */</p><p>242 if (vp->bmp)</p><p>243 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>244 SDL_Rect rect;</p><p>245<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>等待显示间隔时间，调用 Sleep() 函数简单实现。</p><p>246 if (pts)</p><p>247 Sleep((int)(is->frame_last_delay *1000));</p><p>248</p><p>249 /* get a pointer on the bitmap */</p><p>250 SDL_LockYUVOverlay(vp->bmp);</p><p>251<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>设置显示图像的属性。</p><p>252 dst_pix_fmt = PIX_FMT_YUV420P;</p><p>253 pict.data[0] = vp->bmp->pixels[0];</p><p>254 pict.data[1] = vp->bmp->pixels[2];</p><p>255 pict.data[2] = vp->bmp->pixels[1];</p><p>256</p><p>257 pict.linesize[0] = vp->bmp->pitches[0];</p><p>258 pict.linesize[1] = vp->bmp->pitches[2];</p><p>259 pict.linesize[2] = vp->bmp->pitches[1];</p><p>260<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>把解码后的颜色空间转换为显示颜色空间。</p><p>261 img_convert(&pict,</p><p>262 dst_pix_fmt,</p><p>263 (AVPicture*)src_frame,</p><p>264 is->video_st->actx->pix_fmt,</p><p>265 is->video_st->actx->width,</p><p>266 is->video_st->actx->height);</p><p>267</p><p>268 SDL_UnlockYUVOverlay(vp->bmp); /* update the bitmap content */</p><p>269</p><p>270 rect.x = 0;</p><p>271 rect.y = 0;</p><p>272 rect.w = is->video_st->actx->width;</p><p>273 rect.h = is->video_st->actx->height;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>实质性显示，刷屏操作。</p><p>274 SDL_DisplayYUVOverlay(vp->bmp, &rect);</p><p>275 }</p><p>276 return 0;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>277 }</p><p>278</p><p>视频解码线程，主要功能是分配解码帧缓存和 SDL 显示缓存后进入解码循环(从队列中取数据帧，解</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.131.png alt>码，计算时钟，显示)，释放视频数据帧/数据包缓存。</p><p>279 static int video_thread(void *arg)</p><p>280 {</p><p>281 VideoState *is = arg;</p><p>282 AVPacket pkt1, *pkt = &amp;pkt1;</p><p>283 int len1, got_picture;</p><p>284 double pts = 0;</p><p>285<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>分配解码帧缓存</p><p>286 AVFrame *frame = av_malloc(sizeof(AVFrame));</p><p>287 memset(frame, 0, sizeof(AVFrame));</p><p>288<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>分配 SDL 显示缓存</p><p>289 alloc_picture(is);</p><p>290</p><p>291 for (;;)</p><p>292 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>从队列中取数据帧/数据包</p><p>293 if (packet_queue_get(&is->videoq, pkt, 1) &lt; 0)</p><p>294 break;</p><p>295<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>实质性解码</p><p>296 SDL_LockMutex(is->video_decoder_mutex);</p><p>297 len1 = avcodec_decode_video(is->video_st->actx, frame, &got_picture, pkt->data, pkt->size);</p><p>298 SDL_UnlockMutex(is->video_decoder_mutex);</p><p>299<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>计算同步时钟</p><p>300 if (pkt->dts != AV_NOPTS_VALUE)</p><p>301 pts = av_q2d(is->video_st->time_base) *pkt->dts;</p><p>302</p><p>303 if (got_picture)</p><p>304 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.132.png alt></p><p>判断得到图像，调用显示函数同步显示视频图像。</p><table><thead><tr><th>305</th><th></th><th>if (queue_picture(is, frame, pts) &lt; 0)</th></tr></thead><tbody><tr><td>306</td><td></td><td>goto the_end;</td></tr><tr><td>307</td><td>}</td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt>释放视频数据帧/数据包内存，此数据包内存是在 av_get_packet()函数中调用 av_malloc()分配的。</td><td></td><td></td></tr></tbody></table><p>308 av_free_packet(pkt);</p><p>309 }</p><p>310</p><p>311 the_end:</p><p>312 av_free(frame);</p><p>313 return 0;</p><p>314 }</p><p>315</p><p>解码一个音频帧，返回解压的数据大小。特别注意一个音频包可能包含多个音频帧，但一次只解码一</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.133.png alt>个音频帧，所以一包可能要多次才能解码完。程序首先用 w hile 语句判断包数据是否全部解完，如果没 有就解码当前包中的帧，修改状态参数；否则，释放数据包，再从队列中取，记录初始值，再进循环。</p><p>316 /* decode one audio frame and returns its uncompressed size */</p><p>317 static int audio_decode_frame(VideoState *is, uint8_t *audio_buf, double *pts_ptr)</p><p>318 {</p><p>319 AVPacket *pkt = &is->audio_pkt;</p><p>320 int len1, data_size;</p><p>321</p><p>322 for (;;)</p><p>323 {</p><p>324</p><p>特别注意，一个音频包可能包含多个音频帧，可能需多次解码，VideoState 用一个 AVPacket 型变量</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.131.png alt>保存多次解码的中间状态。如果多次解码但不是最后次解码，audio_decode_frame 直接进 while 循环。</p><p>325 while (is->audio_pkt_size > 0)</p><p>326 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>调用解码函数解码，avcodec_decode_audio()函数返回解码用掉的字节数。</p><p>327 SDL_LockMutex(is->audio_decoder_mutex);</p><p>328 len1 = avcodec_decode_audio(is->audio_st->actx, (int16_t*)audio_buf,</p><p>329 &data_size, is->audio_pkt_data, is->audio_pkt_size);</p><p>330</p><p>331 SDL_UnlockMutex(is->audio_decoder_mutex);</p><p>332 if (len1 &lt; 0)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>333 {</p><p>334<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>如果发生错误，跳过当前帧，跳出底层循环。</p><p>335 is->audio_pkt_size = 0;</p><p>336 break;</p><p>337 }</p><p>338<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>修正解码后的音频帧缓存首地址和大小。</p><p>339 is->audio_pkt_data += len1;</p><p>340 is->audio_pkt_size -= len1;</p><p>341 if (data_size &lt;= 0)</p><p>如果没有得到解码后的数据，继续解码。可能有些帧第一次解码时只解一个帧头就返回，此时需要继</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.131.png alt>续解码数据帧。</p><p>342 continue;</p><p>343<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>返回解码后的数据大小。</p><p>344 return data_size;</p><p>345 }</p><p>346<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>程序到这里，可能是初始时 audio_pkt 没有赋值；或者一包已经解码完，此时需要释放包数据内存。</p><p>347 /* free the current packet */</p><p>348 if (pkt->data)</p><p>349 av_free_packet(pkt);</p><p>350<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>读取下一个数据包。</p><p>351 /* read next packet */</p><p>352 if (packet_queue_get(&is->audioq, pkt, 1) &lt; 0)</p><p>353 return - 1;</p><p>354</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.134.png alt>初始化数据包首地址和大小，用于一包中包含多个音频帧需多次解码的情况。</p><p>355 is->audio_pkt_data = pkt->data;</p><p>356 is->audio_pkt_size = pkt->size;</p><p>357 }</p><p>358 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>359</p><p>音频输出回调函数，每次音频输出缓存为空时，系统就调用此函数填充音频输出缓存。目前采用比较</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.135.png alt>简单的同步方式，音频按照自己的节拍往前走即可，不需要 synchronize_audio()函数同步处理。</p><p>360 /* prepare a new audio buffer */</p><p>361 void sdl_audio_callback(void *opaque, Uint8 *stream, int len)</p><p>362 {</p><p>363 VideoState *is = opaque;</p><p>364 int audio_size, len1;</p><p>365 double pts = 0;</p><p>366</p><p>367 while (len > 0)</p><p>368 {</p><p>369 if (is->audio_buf_index >= is->audio_buf_size)</p><p>370 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>如果解码后的数据已全部输出，就进行音频解码，并在 381 行保存解码数据大小，在383 行读索引置0。</p><p>371 audio_size = audio_decode_frame(is, is->audio_buf, &pts);</p><p>372 if (audio_size &lt; 0)</p><p>373 {</p><p>374 /* if error, just output silence */</p><p>375 is->audio_buf_size = 1024;</p><p>376 memset(is->audio_buf, 0, is->audio_buf_size);</p><p>377 }</p><p>378 else</p><p>379 {</p><p>380 // audio_size = synchronize_audio(is, (int16_t*)is->audio_buf, audio_size, pts);</p><p>381 is->audio_buf_size = audio_size;</p><p>382 }</p><p>383 is->audio_buf_index = 0;</p><p>384 }</p><p>385 到 391 行，拷贝适当的数据到输出缓存，并修改解码缓存的参数，进下一轮循环。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.136.png alt>特别注意：由进下一轮循环可知，程序应填满 SDL 库给出的输出缓存。</p><p>385 len1 = is->audio_buf_size - is->audio_buf_index;</p><p>386 if (len1 > len)</p><p>387 len1 = len;</p><p>388 memcpy(stream, (uint8_t*)is->audio_buf + is->audio_buf_index, len1);</p><p>389 len -= len1;</p><p>390 stream += len1;</p><p>391 is->audio_buf_index += len1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>392 }</p><p>393 }</p><p>394</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.134.png alt>打开流模块，核心功能是打开相应 codec，启动解码线程(我们把音频回调函数看做一个广义的线程)。</p><p>395 /* open a given stream. Return 0 if OK */</p><p>396 static int stream_component_open(VideoState *is, int stream_index) // 核心功能 open codec</p><p>397 {</p><p>398 AVFormatContext *ic = is->ic;</p><p>399 AVCodecContext *enc;</p><p>400 AVCodec *codec;</p><p>401 SDL_AudioSpec wanted_spec, spec;</p><p>402</p><p>403 if (stream_index &lt; 0 || stream_index >= ic->nb_streams)</p><p>404 return - 1;</p><p>405<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>找到从文件格式分析中得到的解码器上下文指针，便于引用其中的参数。</p><p>406 enc = ic->streams[stream_index]->actx;</p><p>407</p><p>408 /* prepare audio output */</p><p>409 if (enc->codec_type == CODEC_TYPE_AUDIO)</p><p>410 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>初始化音频输出参数，并调用 SDL_OpenAudio()设置到 SDL 库。</p><p>411 wanted_spec.freq = enc->sample_rate;</p><p>412 wanted_spec.format = AUDIO_S16SYS;</p><p>413 /* hack for AC3. XXX: suppress that */</p><p>414 if (enc->channels > 2)</p><p>415 enc->channels = 2;</p><p>416 wanted_spec.channels = enc->channels;</p><p>417 wanted_spec.silence = 0;</p><p>418 wanted_spec.samples = 1024; //SDL_AUDIO_BUFFER_SIZE;</p><p>419 wanted_spec.callback = sdl_audio_callback; // 此处设定回调函数</p><p>420 wanted_spec.userdata = is;</p><p>421 if (SDL_OpenAudio(&wanted_spec, &spec) &lt; 0)</p><p>422 {</p><p>wanted_spec 是应用程序设定给 SDL 库的音频参数，spec 是 SDL 库返回给应用程序它能支持的音频</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.137.png alt>参数，通常是一致的。如果超过 SDL 支持的参数范围，会返回最相近的参数。</p><p>423 fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError());</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt>424 return - 1;</p><p>425 }</p><p>426 }</p><p>427<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>依照编解码上下文的 codec_id，遍历编解码器链表，找到相应的功能函数。</p><p>428 codec = avcodec_find_decoder(enc->codec_id);</p><p>429</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.134.png alt>核心功能之一,打开编解码器，初始化具体编解码器的运行环境。</p><p>430 if (!codec || avcodec_open(enc, codec) &lt; 0)</p><p>431 return - 1;</p><p>432</p><p>433 switch (enc->codec_type)</p><p>434 {</p><p>435 case CODEC_TYPE_AUDIO:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>在 VideoState 中记录音频流参数。</p><p>436 is->audio_stream = stream_index;</p><p>437 is->audio_st = ic->streams[stream_index];</p><p>438 is->audio_buf_size = 0;</p><p>439 is->audio_buf_index = 0;</p><p>440<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>初始化音频队列，并在 443 行启动广义的音频解码线程。</p><p>441 memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));</p><p>442 packet_queue_init(&is->audioq);</p><p>443 SDL_PauseAudio(0);</p><p>444 break;</p><p>445 case CODEC_TYPE_VIDEO:<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>在 VideoState 中记录视频流参数。</p><p>446 is->video_stream = stream_index;</p><p>447 is->video_st = ic->streams[stream_index];</p><p>448</p><p>449 is->frame_last_delay = is->video_st->frame_last_delay;</p><p>450<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>初始化视频队列，并在 452 行直接启动视频解码线程。</p><p>451 packet_queue_init(&is->videoq);</p><p>452 is->video_tid = SDL_CreateThread(video_thread, is);<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>453 break;</p><p>454 default:</p><p>455 break;</p><p>456 }</p><p>457 return 0;</p><p>458 }</p><p>459<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.131.png alt></p><p>关闭流模块，停止解码线程，释放队列资源。</p><p>通过 packet_queue_abort()函数置 abort_request 标志位，解码线程判别此标志位并安全退出线程。</p><p>460 static void stream_component_close(VideoState *is, int stream_index)</p><p>461 {</p><p>462 AVFormatContext *ic = is->ic;</p><p>463 AVCodecContext *enc;</p><p>464<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.138.png alt></p><p>简单的流索引参数校验。</p><p>465 if (stream_index &lt; 0 || stream_index >= ic->nb_streams)</p><p>466 return ;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.129.png alt></p><p>找到从文件格式分析中得到的解码器上下文指针，便于引用其中的参数。</p><p>467 enc = ic->streams[stream_index]->actx;</p><p>468</p><p>469 switch (enc->codec_type)</p><p>470 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>停止解码线程，释放队列资源。</p><p>471 case CODEC_TYPE_AUDIO:</p><p>472 packet_queue_abort(&is->audioq);</p><p>473 SDL_CloseAudio();</p><p>474 packet_queue_end(&is->audioq);</p><p>475 break;</p><p>476 case CODEC_TYPE_VIDEO:</p><p>477 packet_queue_abort(&is->videoq);</p><p>478 SDL_WaitThread(is->video_tid, NULL);</p><p>479 packet_queue_end(&is->videoq);</p><p>480 break;</p><p>481 default:</p><p>482 break;</p><p>483 }</p><p>484<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.139.png alt></p><p>释放编解码器上下文资源</p><p>485 avcodec_close(enc);</p><p>486 }</p><p>487</p><p>文件解析线程，函数名有点不名副其实。完成三大功能，直接识别文件格式和间接识别媒体格式，</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.140.png alt>打开具体的编解码器并启动解码线程，分离音视频媒体包并挂接到相应队列。</p><p>488 static int decode_thread(void *arg)</p><p>489 {</p><p>490 VideoState *is = arg;</p><p>491 AVFormatContext *ic;</p><p>492 int err, i, ret, video_index, audio_index;</p><p>493 AVPacket pkt1, *pkt = &amp;pkt1;</p><p>494 AVFormatParameters params, *ap = &amp;params;</p><p>495</p><p>496 int flags = SDL_HWSURFACE | SDL_ASYNCBLIT | SDL_HWACCEL | SDL_RESIZABLE;</p><p>497<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>498 到 502 行，初始化基本变量指示没有相应的流。</p><p>498 video_index = - 1;</p><p>499 audio_index = - 1;</p><p>500</p><p>501 is->video_stream = - 1;</p><p>502 is->audio_stream = - 1;</p><p>503</p><p>504 memset(ap, 0, sizeof(*ap));</p><p>505<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>调用函数直接识别文件格式，在此函数中再调用其他函数间接识别媒体格式。</p><p>506 err = av_open_input_file(&ic, is->filename, NULL, 0, ap);</p><p>507 if (err &lt; 0)</p><table><thead><tr><th>508</th><th>{</th><th></th></tr></thead><tbody><tr><td>509</td><td></td><td>ret = - 1;</td></tr><tr><td>510</td><td></td><td>goto fail;</td></tr><tr><td>511</td><td>}</td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt>保存文件格式上下文，便于各数据结构间跳转。</td><td></td><td></td></tr></tbody></table><p>512 is->ic = ic;</p><p>513</p><p>514 for (i = 0; i &lt; ic->nb_streams; i++)</p><table><thead><tr><th>515</th><th>{</th><th></th></tr></thead><tbody><tr><td>516</td><td></td><td>AVCodecContext *enc = ic->streams[i]->actx;</td></tr><tr><td>517</td><td></td><td>switch (enc->codec_type)</td></tr><tr><td>518</td><td></td><td>{</td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt>保存音视频流索引，并把显示视频参数设置到 SDL 库。</td><td></td><td></td></tr></tbody></table><p>519 case CODEC_TYPE_AUDIO:</p><p>520 if (audio_index &lt; 0)</p><p>521 audio_index = i;</p><p>522 break;</p><p>523 case CODEC_TYPE_VIDEO:</p><p>524 if (video_index &lt; 0)</p><p>525 video_index = i;</p><p>526</p><p>527 screen = SDL_SetVideoMode(enc->width, enc->height, 0, flags);</p><p>528</p><p>529 SDL_WM_SetCaption("FFplay", "FFplay"); // 修改是为了适配视频大小</p><p>530</p><p>531 // schedule_refresh(is, 40);</p><p>532 break;</p><p>533 default:</p><p>534 break;</p><p>535 }</p><p>536 }</p><p>537<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>如果有音频流，就调用函数打开音频编解码器并启动音频广义解码线程。</p><p>538 if (audio_index >= 0)</p><p>539 stream_component_open(is, audio_index);</p><p>540<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>如果有视频流，就调用函数打开视频编解码器并启动视频解码线程。</p><p>541 if (video_index >= 0)</p><p>542 stream_component_open(is, video_index);</p><p>543</p><p>544 if (is->video_stream &lt; 0 && is->audio_stream &lt; 0)</p><p>545 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>如果既没有音频流，又没有视频流，就设置错误码返回。</p><p>546 fprintf(stderr, "%s: could not open codecs\n", is->filename);</p><p>547 ret = - 1;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>548 goto fail;</p><p>549 }</p><p>550</p><p>551 for (;;)</p><p>552 {</p><p>553 if (is->abort_request)<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>如果异常退出请求置位，就退出文件解析线程。</p><p>554 break;</p><p>555</p><p>556 if (is->audioq.size > MAX_AUDIOQ_SIZE || is->videoq.size > MAX_VIDEOQ_SIZE || url_feof(&ic->pb))</p><p>557 {<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>如果队列满，就稍微延时一下。</p><p>558 SDL_Delay(10); // if the queue are full, no need to read more,wait 10 ms</p><p>559 continue;</p><p>560 }<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>从媒体文件中完整的读取一包音视频数据。</p><p>561 ret = av_read_packet(ic, pkt); //av_read_frame(ic, pkt);</p><p>562 if (ret &lt; 0)</p><p>563 {</p><p>564 if (url_ferror(&ic->pb) == 0)</p><table><thead><tr><th>565</th><th></th><th>{</th><th></th></tr></thead><tbody><tr><td>566</td><td></td><td></td><td>SDL_Delay(100); // wait for user event</td></tr><tr><td>567</td><td></td><td></td><td>continue;</td></tr><tr><td>568</td><td></td><td>}</td><td></td></tr><tr><td>569</td><td></td><td>else</td><td></td></tr><tr><td>570</td><td></td><td>break;</td><td></td></tr><tr><td>571</td><td>}</td><td></td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt>判断包数据的类型，分别挂接到相应队列，如果是不识别的类型，就直接释放丢弃掉。</td><td></td><td></td><td></td></tr></tbody></table><p>572 if (pkt->stream_index == is->audio_stream)</p><p>573 {</p><p>574 packet_queue_put(&is->audioq, pkt);</p><p>575 }</p><p>576 else if (pkt->stream_index == is->video_stream)</p><p>577 {</p><p>578 packet_queue_put(&is->videoq, pkt);</p><p>579 }</p><p>580 else<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>581 {</p><p>582 av_free_packet(pkt);</p><p>583 }</p><p>584 }</p><p>585<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>简单的延时，让后面的线程有机会把数据解码显示完。当然丢弃掉最后的一点点数据也可以。</p><table><thead><tr><th>586</th><th>while (!is->abort_request)</th><th>// wait until the end</th></tr></thead><tbody><tr><td>587</td><td>{</td><td></td></tr><tr><td>588</td><td>SDL_Delay(100);</td><td></td></tr><tr><td>589</td><td>}</td><td></td></tr><tr><td>590</td><td></td><td></td></tr><tr><td>591</td><td>ret = 0;</td><td></td></tr><tr><td>592</td><td></td><td></td></tr><tr><td><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt>释放掉在本线程中分配的各种资源，体现了谁申请谁释放的程序自封闭性。</td><td></td><td></td></tr></tbody></table><p>593 fail:</p><p>594 if (is->audio_stream >= 0)</p><p>595 stream_component_close(is, is->audio_stream);</p><p>596</p><p>597 if (is->video_stream >= 0)</p><p>598 stream_component_close(is, is->video_stream);</p><p>599</p><p>600 if (is->ic)</p><p>601 {</p><p>602 av_close_input_file(is->ic);</p><p>603 is->ic = NULL;</p><p>604 }</p><p>605</p><p>606 if (ret != 0)</p><p>607 {</p><p>608 SDL_Event event;</p><p>609</p><p>610 event.type = FF_QUIT_EVENT;</p><p>611 event.user.data1 = is;</p><p>612 SDL_PushEvent(&event);</p><p>613 }</p><p>614 return 0;</p><p>615 }</p><p>616<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>打开流，这个名字也有点名不符实。主要功能是分配全局总控数据结构，初始化相关参数，启动文</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.141.png alt>件解析线程。</p><p>617 static VideoState *stream_open(const char *filename, AVInputFormat *iformat)</p><p>618 {</p><p>619 VideoState *is;</p><p>620</p><p>621 is = av_mallocz(sizeof(VideoState));</p><p>622 if (!is)</p><p>623 return NULL;</p><p>624 pstrcpy(is->filename, sizeof(is->filename), filename);</p><p>625</p><p>626 is->audio_decoder_mutex = SDL_CreateMutex();</p><p>627 is->video_decoder_mutex = SDL_CreateMutex();</p><p>628</p><p>629 is->parse_tid = SDL_CreateThread(decode_thread, is);</p><p>630 if (!is->parse_tid)</p><p>631 {</p><p>632 av_free(is);</p><p>633 return NULL;</p><p>634 }</p><p>635 return is;</p><p>636 }</p><p>637<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>关闭流，这个名字也有点名不符实。主要功能是释放资源。</p><p>639 static void stream_close(VideoState *is)</p><p>640 {</p><p>641 VideoPicture *vp;</p><p>642 int i;</p><p>643</p><p>644 is->abort_request = 1;</p><p>645 SDL_WaitThread(is->parse_tid, NULL);</p><p>646</p><p>647 for (i = 0; i &lt; VIDEO_PICTURE_QUEUE_SIZE; i++)</p><p>648 {</p><p>649 vp = &is->pictq[i];</p><p>650 if (vp->bmp)</p><p>651 {</p><p>652 SDL_FreeYUVOverlay(vp->bmp);</p><p>653 vp->bmp = NULL;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>654 }</p><p>655 }</p><p>656</p><p>657 SDL_DestroyMutex(is->audio_decoder_mutex);</p><p>658 SDL_DestroyMutex(is->video_decoder_mutex);</p><p>659 }</p><p>660<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>程序退出时调用的函数，关闭释放一些资源。</p><p>661 void do_exit(void)</p><p>662 {</p><p>663 if (cur_stream)</p><p>664 {</p><p>665 stream_close(cur_stream);</p><p>666 cur_stream = NULL;</p><p>667 }</p><p>668</p><p>669 SDL_Quit();</p><p>670 exit(0);</p><p>671 }</p><p>672<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>SDL 库的消息事件循环。</p><p>673 void event_loop(void) // handle an event sent by the GUI</p><p>674 {</p><p>675 SDL_Event event;</p><p>676</p><p>677 for (;;)</p><p>678 {</p><p>679 SDL_WaitEvent(&event);</p><p>680 switch (event.type)</p><p>681 {</p><p>682 case SDL_KEYDOWN:</p><p>683 switch (event.key.keysym.sym)</p><p>684 {</p><p>685 case SDLK_ESCAPE:</p><p>686 case SDLK_q:</p><p>687 do_exit();</p><p>688 break;</p><p>689 default:</p><p>690 break;<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.020.png alt></p><p>691 }</p><p>692 break;</p><p>693 case SDL_QUIT:</p><p>694 case FF_QUIT_EVENT:</p><p>695 do_exit();</p><p>696 break;</p><p>697 default:</p><p>698 break;</p><p>699 }</p><p>700 }</p><p>701 }</p><p>702<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.130.png alt></p><p>入口函数，初始化 SDL 库，注册 SDL 消息事件，启动文件解析线程，进入消息循环。</p><p>703 int main(int argc, char **argv)</p><p>704 {</p><p>705 int flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;</p><p>706</p><p>707 av_register_all();</p><p>708</p><p>709 input_filename = "d:/yuv/clocktxt_320.avi";</p><p>710</p><p>711 if (SDL_Init(flags))</p><p>712 exit(1);</p><p>713</p><p>714 SDL_EventState(SDL_ACTIVEEVENT, SDL_IGNORE);</p><p>715 SDL_EventState(SDL_MOUSEMOTION, SDL_IGNORE);</p><p>716 SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);</p><p>717 SDL_EventState(SDL_USEREVENT, SDL_IGNORE);</p><p>718</p><p>719 cur_stream = stream_open(input_filename, file_iformat);</p><p>720</p><p>721 event_loop();</p><p>722</p><p>723 return 0;</p><p>724 }</p><p>725</p><h1 id=第七章-应用开发><strong>第七章 应用开发</strong></h1><h2 id=71-ffmpeg库的使用编码><strong>7.1 ffmpeg库的使用：编码</strong></h2><p><strong>YUV编码为视频</strong>：</p><p>搞视频处理的朋友肯定比较熟悉YUV视频序列，很多测试库提供的视频数据都是YUV视频序列，我们这里就用用YUV视频序列来做视频。关于YUV视频序列，我就不多讲了，可以看书学习，通常的视频序列都是YUV420格式的。</p><p>步骤也就那几步，添加视频流，打开编码器，开辟相应的内存空间，然后就可以打开YUV序列逐帧写入数据了，so easy！记得最后要做好文件的关闭和内存的释放，因为FFmpeg是c风格的（不知道新版本是否是c++风格的），这些工作都需要自己做好啊。过多的说明是没用的，直接上代码：</p><p>这里我补充一下，大多数的视频格式好像只支持YUV格式的视频帧AVFrame，我试图直接把RGB的视频序列直接编码到视频这条路好像走不通，都需要把RGB的视频帧再转成YUV视频帧才行，不知道高手有没有其他高见。</p><p>#include &lt;stdio.h></p><p>#include &lt;string.h></p><p>extern "C"</p><p>{</p><p>#include &lt;libavcodec\avcodec.h></p><p>#include &lt;libavformat\avformat.h></p><p>#include &lt;libswscale\swscale.h></p><p>};</p><p>void main(int argc, char ** argv)</p><p>{</p><p><code></code>AVFormatContext* oc;</p><p><code></code>AVOutputFormat* fmt;</p><p><code></code>AVStream* video_st;</p><p><code></code>double video_pts;</p><p><code></code>uint8_t* video_outbuf;</p><p><code></code>uint8_t* picture_buf;</p><p><code></code>AVFrame* picture;</p><p>// AVFrame* pictureRGB;</p><p><code></code>int size;</p><p><code></code>int ret;</p><p><code></code>int video_outbuf_size;</p><p><code></code>FILE *fin = fopen("akiyo_qcif.yuv", "rb"); //视频源文件</p><p><code></code>const char* filename = "test.mpg";</p><p>// const char* filename;</p><p>// filename = argv[1];</p><p><code></code>av_register_all();</p><p>// avcodec_init(); // 初始化codec库</p><p>// avcodec_register_all(); // 注册编码器</p><p><code></code>fmt = guess_format(NULL, filename, NULL);</p><p><code></code>oc = av_alloc_format_context();</p><p><code></code>oc->oformat = fmt;</p><p><code></code>snprintf(oc->filename, sizeof(oc->filename), "%s", filename);</p><p><code></code>video_st = NULL;</p><p><code></code>if (fmt->video_codec != CODEC_ID_NONE)</p><p><code></code>{</p><p><code></code>AVCodecContext* c;</p><p><code></code>video_st = av_new_stream(oc, 0);</p><p><code></code>c = video_st->codec;</p><p><code></code>c->codec_id = fmt->video_codec;</p><p><code></code>c->codec_type = CODEC_TYPE_VIDEO;</p><p><code></code>c->bit_rate = 400000;</p><p><code></code>c->width = 176;</p><p><code></code>c->height = 144;</p><p><code></code>c->time_base.num = 1;</p><p><code></code>c->time_base.den = 25;</p><p><code></code>c->gop_size = 12;</p><p><code></code>c->pix_fmt = PIX_FMT_YUV420P;</p><p><code></code>if (c->codec_id == CODEC_ID_MPEG2VIDEO)</p><p><code></code>{</p><p><code></code>c->max_b_frames = 2;</p><p><code></code>}</p><p><code></code>if (c->codec_id == CODEC_ID_MPEG1VIDEO)</p><p><code></code>{</p><p><code></code>c->mb_decision = 2;</p><p><code></code>}</p><p><code></code>if (!strcmp(oc->oformat->name, "mp4") || !strcmp(oc->oformat->name, "mov") || !strcmp(oc->oformat->name, "3gp"))</p><p><code></code>{</p><p><code></code>c->flags |= CODEC_FLAG_GLOBAL_HEADER;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (av_set_parameters(oc, NULL)&lt;0)</p><p><code></code>{</p><p><code></code>return;</p><p><code></code>}</p><p><code></code>dump_format(oc, 0, filename, 1);</p><p><code></code>if (video_st)</p><p><code></code>{</p><p><code></code>AVCodecContext* c;</p><p><code></code>AVCodec* codec;</p><p><code></code>c = video_st->codec;</p><p><code></code>codec = avcodec_find_encoder(c->codec_id);</p><p><code></code>if (!codec)</p><p><code></code>{</p><p><code></code>return;</p><p><code></code>}</p><p><code></code>if (avcodec_open(c, codec) &lt; 0)</p><p><code></code>{</p><p><code></code>return;</p><p><code></code>}</p><p><code></code>if (!(oc->oformat->flags & AVFMT_RAWPICTURE))</p><p><code></code>{</p><p><code></code>video_outbuf_size = 200000;</p><p><code></code>video_outbuf = (uint8_t*)av_malloc(video_outbuf_size);</p><p><code></code>}</p><p><code></code>picture = avcodec_alloc_frame();</p><p><code></code>size = avpicture_get_size(c->pix_fmt, c->width, c->height);</p><p><code></code>picture_buf = (uint8_t*)av_malloc(size);</p><p><code></code>if (!picture_buf)</p><p><code></code>{</p><p><code></code>av_free(picture);</p><p><code></code>}</p><p><code></code>avpicture_fill((AVPicture*)picture, picture_buf, c->pix_fmt, c->width, c->height);</p><p><code></code>}</p><p><code></code>if (!(fmt->flags & AVFMT_NOFILE))</p><p><code></code>{</p><p><code></code>if (url_fopen(&oc->pb, filename, URL_WRONLY) &lt; 0)</p><p><code></code>{</p><p><code></code>return;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>av_write_header(oc);</p><p><code></code>for (int i=0; i&lt;300; i++)</p><p><code></code>{</p><p><code></code>if (video_st)</p><p><code></code>{</p><p><code></code>video_pts = (double)(video_st->pts.val * video_st->time_base.num / video_st->time_base.den);</p><p><code></code>}</p><p><code></code>else</p><p><code></code>{</p><p><code></code>video_pts = 0.0;</p><p><code></code>}</p><p><code></code>if (!video_st/* || video_pts >= 5.0*/)</p><p><code></code>{</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>AVCodecContext* c;</p><p><code></code>c = video_st->codec;</p><p><code></code>size = c->width * c->height;</p><p><code></code>if (fread(picture_buf, 1, size*3/2, fin) &lt; 0)</p><p><code></code>{</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>picture->data[0] = picture_buf; // 亮度</p><p><code></code>picture->data[1] = picture_buf+ size; // 色度</p><p><code></code>picture->data[2] = picture_buf+ size*5/4; // 色度</p><p><code></code>// 如果是rgb序列，可能需要如下代码</p><p>// SwsContext* img_convert_ctx;</p><p>// img_convert_ctx = sws_getContext(c->width, c->height, PIX_FMT_RGB24, c->width, c->height, c->pix_fmt, SWS_BICUBIC, NULL, NULL, NULL);</p><p>// sws_scale(img_convert_ctx, pictureRGB->data, pictureRGB->linesize, 0, c->height, picture->data, picture->linesize);</p><p><code></code>if (oc->oformat->flags & AVFMT_RAWPICTURE)</p><p><code></code>{</p><p><code></code>AVPacket pkt;</p><p><code></code>av_init_packet(&pkt);</p><p><code></code>pkt.flags |= PKT_FLAG_KEY;</p><p><code></code>pkt.stream_index = video_st->index;</p><p><code></code>pkt.data = (uint8_t*)picture;</p><p><code></code>pkt.size = sizeof(AVPicture);</p><p><code></code>ret = av_write_frame(oc, &pkt);</p><p><code></code>}</p><p><code></code>else</p><p><code></code>{</p><p><code></code>int out_size = avcodec_encode_video(c, video_outbuf, video_outbuf_size, picture);</p><p><code></code>if (out_size > 0)</p><p><code></code>{</p><p><code></code>AVPacket pkt;</p><p><code></code>av_init_packet(&pkt);</p><p><code></code>pkt.pts = av_rescale_q(c->coded_frame->pts, c->time_base, video_st->time_base);</p><p><code></code>if (c->coded_frame->key_frame)</p><p><code></code>{</p><p><code></code>pkt.flags |= PKT_FLAG_KEY;</p><p><code></code>}</p><p><code></code>pkt.stream_index = video_st->index;</p><p><code></code>pkt.data = video_outbuf;</p><p><code></code>pkt.size = out_size;</p><p><code></code>ret = av_write_frame(oc, &pkt);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (video_st)</p><p><code></code>{</p><p><code></code>avcodec_close(video_st->codec);</p><p>// av_free(picture->data[0]);</p><p><code></code>av_free(picture);</p><p><code></code>av_free(video_outbuf);</p><p>// av_free(picture_buf);</p><p><code></code>}</p><p><code></code>av_write_trailer(oc);</p><p><code></code>for (int i=0; i<oc->nb_streams; i++)</p><p><code></code>{</p><p><code></code>av_freep(&oc->streams[i]->codec);</p><p><code></code>av_freep(&oc->streams[i]);</p><p><code></code>}</p><p><code></code>if (!(fmt->flags & AVFMT_NOFILE))</p><p><code></code>{</p><p><code></code>url_fclose(oc->pb);</p><p><code></code>}</p><p>av_free(oc);</p><p>}
8. # <strong>关键函数介绍</strong>
此章有必要，因为调取的函数都是最新版的（有些函数第五章已经提及，读者可以对比）。</p><h2 id=81-avformat_open_input><strong>8.1 avformat_open_input</strong></h2><p>FFMPEG打开媒体的的过程开始于avformat_open_input，因此该函数的重要性不可忽视。</p><p>在该函数中，FFMPEG完成了：</p><p>输入输出结构体AVIOContext的初始化；</p><p>输入数据的协议（例如RTMP，或者file）的识别（通过一套评分机制）:1判断文件名的后缀 2读取文件头的数据进行比对；</p><p>使用获得最高分的文件协议对应的URLProtocol，通过函数指针的方式，与FFMPEG连接（非专业用词）；</p><p>剩下的就是调用该URLProtocol的函数进行open,read等操作了</p><p>以下是通过eclipse+MinGW调试FFMPEG源代码获得的函数调用关系图</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.142.jpeg alt></p><p>可见最终都调用了URLProtocol结构体中的函数指针。</p><p>URLProtocol结构是一大堆函数指针的集合（avio.h文件）参见第四章数据结构</p><p>URLProtocol功能就是完成各种输入协议的读写等操作</p><p>但输入协议种类繁多，它是怎样做到“大一统”的呢？</p><p>原来，每个具体的输入协议都有自己对应的URLProtocol。</p><p>比如file协议（FFMPEG把文件也当做一种特殊的协议）（*file.c文件）</p><p>URLProtocol ff_pipe_protocol = {</p><p><code></code>.name = "pipe",</p><p><code></code>.url_open = pipe_open,</p><p><code></code>.url_read = file_read,</p><p><code></code>.url_write = file_write,</p><p><code></code>.url_get_file_handle = file_get_handle,</p><p><code></code>.url_check = file_check,</p><p>};</p><p>或者rtmp协议（此处使用了librtmp）（librtmp.c文件）</p><p>URLProtocol ff_rtmp_protocol = {</p><p><code></code>.name = "rtmp",</p><p><code></code>.url_open = rtmp_open,</p><p><code></code>.url_read = rtmp_read,</p><p><code></code>.url_write = rtmp_write,</p><p><code></code>.url_close = rtmp_close,</p><p><code></code>.url_read_pause = rtmp_read_pause,</p><p><code></code>.url_read_seek = rtmp_read_seek,</p><p><code></code>.url_get_file_handle = rtmp_get_file_handle,</p><p><code></code>.priv_data_size = sizeof(RTMP),</p><p><code></code>.flags = URL_PROTOCOL_FLAG_NETWORK,</p><p>};</p><p>可见它们把各自的函数指针都赋值给了URLProtocol结构体的函数指针</p><p>因此avformat_open_input只需调用url_open,url_read这些函数就可以完成各种具体输入协议的open,read等操作了</p><h2 id=82-avcodec_register_all><strong>8.2 avcodec_register_all()</strong></h2><p>ffmpeg注册复用器，编码器等的函数av_register_all()。该函数在所有基于ffmpeg的应用程序中几乎都是第一个被调用的。只有调用了该函数，才能使用复用器，编码器等。</p><p>可见解复用器注册都是用</p><p>REGISTER_DEMUXER (X,x)</p><p>例如：</p><p>REGISTER_DEMUXER (AAC, aac)</p><p>可见复用器注册都是用</p><p>REGISTER_MUXER (X,x))</p><p>例如：</p><p>REGISTER_MUXER (ADTS, adts)</p><p>既有解复用器又有复用器的话，可以用</p><p>REGISTER_MUXDEMUX (X,x));</p><p>例如：</p><p>REGISTER_MUXDEMUX (AC3, ac3);</p><p>我们来看一下宏的定义，这里以解复用器为例：</p><p>py</p><p>#define REGISTER_DEMUXER(X,x) { \</p><p><code></code>extern AVInputFormat ff_##x##_demuxer; \</p><p><code></code>if(CONFIG_##X##_DEMUXER) av_register_input_format(&ff_##x##_demuxer); }</p><p>注意：define里面的##可能不太常见，它的含义就是拼接两个字符串，比如</p><p>#define Conn(x,y) x##y</p><p>那么</p><p>int n = Conn(123,456); 结果就是n=123456;</p><p>我们以REGISTER_DEMUXER (AAC, aac)为例，则它等效于</p><p>py</p><p>extern AVInputFormat ff_aac_demuxer;</p><p>if(CONFIG_AAC_DEMUXER) av_register_input_format(&ff_aac_demuxer);</p><p>从上面这段代码我们可以看出，真正注册的函数是av_register_input_format(&ff_aac_demuxer)，那我就看看这个和函数的作用，查看一下av_register_input_format()的代码：</p><p>py</p><p>void av_register_input_format(AVInputFormat *format)</p><p>{</p><p><code></code>AVInputFormat **p;</p><p><code></code>p = &first_iformat;</p><p><code></code>while (*p != NULL) p = &(*p)->next;</p><p><code></code>*p = format;</p><p><code></code>format->next = NULL;</p><p>}</p><p>这段代码是比较容易理解的，首先先提一点，first_iformat是个什么东东呢？其实它是Input Format链表的头部地址，是一个全局静态变量，定义如下：</p><p>py</p><p>/** head of registered input format linked list */</p><p>static AVInputFormat *first_iformat = NULL;</p><p>由此我们可以分析出av_register_input_format()的含义，一句话概括就是：遍历链表并把当前的Input Format加到链表的尾部。</p><p>至此REGISTER_DEMUXER (X, x)分析完毕。</p><p>同理，复用器道理是一样的，只是注册函数改为av_register_output_format()；</p><p>既有解复用器又有复用器的话，有一个宏定义：</p><p>py</p><p>#define REGISTER_MUXDEMUX(X,x) REGISTER_MUXER(X,x); REGISTER_DEMUXER(X,x)</p><p>可见是分别注册了复用器和解复用器。</p><p>此外还有网络协议的注册，注册函数为ffurl_register_protocol()，在此不再详述。</p><p>整个代码没太多可说的，首先确定是不是已经初始化过了（initialized），如果没有，就调用avcodec_register_all()注册编解码器（这个先不分析），然后就是注册，注册，注册...直到完成所有注册。</p><h2 id=83-av_read_frame><strong>8.3 av_read_frame()</strong></h2><p>ffmpeg中的av_read_frame()的作用是读取码流中的音频若干帧或者视频一帧。例如，解码视频的时候，每解码一个视频帧，需要先调用 av_read_frame()获得一帧视频的压缩数据，然后才能对该数据进行解码（例如H.264中一帧压缩数据通常对应一个NAL）。</p><p>通过av_read_packet(***)，读取一个包，需要说明的是此函数必须是包含整数帧的，不存在半帧的情况，以ts流为例，是读取一个完整的PES包（一个完整pes包包含若干视频或音频es包），读取完毕后，通过av_parser_parse2(***)分析出视频一帧（或音频若干帧），返回，下次进入循环的时候，如果上次的数据没有完全取完，则st = s->cur_st;不会是NULL，即再此进入av_parser_parse2(***)流程，而不是下面的av_read_packet（**）流程，这样就保证了，如果读取一次包含了N帧视频数据（以视频为例），则调用av_read_frame（***）N次都不会去读数据，而是返回第一次读取的数据，直到全部解析完毕。</p><h2 id=84-avcodec_decode_video2><strong>8.4 avcodec_decode_video2()</strong></h2><p>ffmpeg中的avcodec_decode_video2()的作用是解码一帧视频数据。输入一个压缩编码的结构体AVPacket，输出一个解码后的结构体AVFrame。</p><h2 id=85-transcode_init><strong>8.5 transcode_init()</strong></h2><p>transcode_init()函数是在转换前做准备工作的.此处看一下它的真面目,不废话,看注释吧:</p><p>//为转换过程做准备</p><p>static int transcode_init(OutputFile *output_files,</p><p><code></code>int nb_output_files,</p><p><code></code>InputFile *input_files,</p><p><code></code>int nb_input_files)</p><p>{</p><p><code></code>int ret = 0, i, j, k;</p><p><code></code>AVFormatContext *oc;</p><p><code></code>AVCodecContext *codec, *icodec;</p><p><code></code>OutputStream *ost;</p><p><code></code>InputStream *ist;</p><p><code></code>char error[1024];</p><p><code></code>int want_sdp = 1;</p><p><code></code>/* init framerate emulation */</p><p><code></code>//初始化帧率仿真(转换时是不按帧率来的,但如果要求帧率仿真,就可以做到)</p><p><code></code>for (i = 0; i &lt; nb_input_files; i++)</p><p><code></code>{</p><p><code></code>InputFile *ifile = &input_files[i];</p><p><code></code>//如果一个输入文件被要求帧率仿真(指的是即使是转换也像播放那样按照帧率来进行),</p><p><code></code>//则为这个文件中所有流记录下开始时间</p><p><code></code>if (ifile->rate_emu)</p><p><code></code>for (j = 0; j &lt; ifile->nb_streams; j++)</p><p><code></code>input_streams[j + ifile->ist_index].start = av_gettime();</p><p><code></code>}</p><p><code></code>/* output stream init */</p><p><code></code>for (i = 0; i &lt; nb_output_files; i++)</p><p><code></code>{</p><p><code></code>//什么也没做,只是做了个判断而已</p><p><code></code>oc = output_files[i].ctx;</p><p><code></code>if (!oc->nb_streams && !(oc->oformat->flags & AVFMT_NOSTREAMS))</p><p><code></code>{</p><p><code></code>av_dump_format(oc, i, oc->filename, 1);</p><p><code></code>av_log(NULL, AV_LOG_ERROR,</p><p><code></code>"Output file #%d does not contain any stream\n", i);</p><p><code></code>return AVERROR(EINVAL);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//轮循所有的输出流,跟据对应的输入流,设置其编解码器的参数</p><p><code></code>for (i = 0; i &lt; nb_output_streams; i++)</p><p><code></code>{</p><p><code></code>//轮循所有的输出流</p><p><code></code>ost = &output_streams[i];</p><p><code></code>//输出流对应的FormatContext</p><p><code></code>oc = output_files[ost->file_index].ctx;</p><p><code></code>//取得输出流对应的输入流</p><p><code></code>ist = &input_streams[ost->source_index];</p><p><code></code>//attachment_filename是不是这样的东西:一个文件,它单独容纳一个输出流?此处不懂</p><p><code></code>if (ost->attachment_filename)</p><p><code></code>continue;</p><p><code></code>codec = ost->st->codec;//输出流的编解码器结构</p><p><code></code>icodec = ist->st->codec;//输入流的编解码器结构</p><p><code></code>//先把能复制的复制一下</p><p><code></code>ost->st->disposition = ist->st->disposition;</p><p><code></code>codec->bits_per_raw_sample = icodec->bits_per_raw_sample;</p><p><code></code>codec->chroma_sample_location = icodec->chroma_sample_location;</p><p><code></code>//如果只是复制一个流(不用解码后再编码),则把输入流的编码参数直接复制给输出流</p><p><code></code>//此时是不需要解码也不需要编码的，所以不需打开解码器和编码器</p><p><code></code>if (ost->stream_copy)</p><p><code></code>{</p><p><code></code>//计算输出流的编解码器的extradata的大小,然后分配容纳extradata的缓冲</p><p><code></code>//然后把输入流的编解码器的extradata复制到输出流的编解码器中</p><p><code></code>uint64_t extra_size = (uint64_t) icodec->extradata_size</p><p><code></code>+ FF_INPUT_BUFFER_PADDING_SIZE;</p><p><code></code>if (extra_size > INT_MAX) {</p><p><code></code>return AVERROR(EINVAL);</p><p><code></code>}</p><p><code></code>/* if stream_copy is selected, no need to decode or encode */</p><p><code></code>codec->codec_id = icodec->codec_id;</p><p><code></code>codec->codec_type = icodec->codec_type;</p><p><code></code>if (!codec->codec_tag){</p><p><code></code>if (!oc->oformat->codec_tag</p><p><code></code>||av_codec_get_id(oc->oformat->codec_tag,icodec->codec_tag) == codec->codec_id</p><p><code></code>||av_codec_get_tag(oc->oformat->codec_tag,icodec->codec_id) &lt;= 0)</p><p><code></code>codec->codec_tag = icodec->codec_tag;</p><p><code></code>}</p><p><code></code>codec->bit_rate = icodec->bit_rate;</p><p><code></code>codec->rc_max_rate = icodec->rc_max_rate;</p><p><code></code>codec->rc_buffer_size = icodec->rc_buffer_size;</p><p><code></code>codec->extradata = av_mallocz(extra_size);</p><p><code></code>if (!codec->extradata){</p><p><code></code>return AVERROR(ENOMEM);</p><p><code></code>}</p><p><code></code>memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);</p><p><code></code>codec->extradata_size = icodec->extradata_size;</p><p><code></code>//重新鼓捣一下time base(这家伙就是帧率)</p><p><code></code>codec->time_base = ist->st->time_base;</p><p><code></code>//如果输出文件是avi,做一点特殊处理</p><p><code></code>if (!strcmp(oc->oformat->name, "avi")) {</p><p><code></code>if (copy_tb &lt; 0</p><p><code></code>&& av_q2d(icodec->time_base) * icodec->ticks_per_frame ></p><p><code></code>2 * av_q2d(ist->st->time_base)</p><p><code></code>&& av_q2d(ist->st->time_base) &lt; 1.0 / 500</p><p><code></code>|| copy_tb == 0)</p><p><code></code>{</p><p><code></code>codec->time_base = icodec->time_base;</p><p><code></code>codec->time_base.num *= icodec->ticks_per_frame;</p><p><code></code>codec->time_base.den *= 2;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>else if (!(oc->oformat->flags & AVFMT_VARIABLE_FPS))</p><p><code></code>{</p><p><code></code>if (copy_tb &lt; 0</p><p><code></code>&& av_q2d(icodec->time_base) * icodec->ticks_per_frame</p><p><code></code>> av_q2d(ist->st->time_base)</p><p><code></code>&& av_q2d(ist->st->time_base) &lt; 1.0 / 500</p><p><code></code>|| copy_tb == 0)</p><p><code></code>{</p><p><code></code>codec->time_base = icodec->time_base;</p><p><code></code>codec->time_base.num *= icodec->ticks_per_frame;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//再修正一下帧率</p><p><code></code>av_reduce(&codec->time_base.num, &codec->time_base.den,</p><p><code></code>codec->time_base.num, codec->time_base.den, INT_MAX);</p><p><code></code>//单独复制各不同媒体自己的编码参数</p><p><code></code>switch (codec->codec_type)</p><p><code></code>{</p><p><code></code>case AVMEDIA_TYPE_AUDIO:</p><p><code></code>//音频的</p><p><code></code>if (audio_volume != 256){</p><p><code></code>av_log( NULL,AV_LOG_FATAL,</p><p><code></code>"-acodec copy and -vol are incompatible (frames are not decoded)\n");</p><p><code></code>exit_program(1);</p><p><code></code>}</p><p><code></code>codec->channel_layout = icodec->channel_layout;</p><p><code></code>codec->sample_rate = icodec->sample_rate;</p><p><code></code>codec->channels = icodec->channels;</p><p><code></code>codec->frame_size = icodec->frame_size;</p><p><code></code>codec->audio_service_type = icodec->audio_service_type;</p><p><code></code>codec->block_align = icodec->block_align;</p><p><code></code>break;</p><p><code></code>case AVMEDIA_TYPE_VIDEO:</p><p><code></code>//视频的</p><p><code></code>codec->pix_fmt = icodec->pix_fmt;</p><p><code></code>codec->width = icodec->width;</p><p><code></code>codec->height = icodec->height;</p><p><code></code>codec->has_b_frames = icodec->has_b_frames;</p><p><code></code>if (!codec->sample_aspect_ratio.num){</p><p><code></code>codec->sample_aspect_ratio = ost->st->sample_aspect_ratio =</p><p><code></code>ist->st->sample_aspect_ratio.num ?ist->st->sample_aspect_ratio :</p><p><code></code>ist->st->codec->sample_aspect_ratio.num ?ist->st->codec->sample_aspect_ratio :(AVRational){0, 1};</p><p><code></code>}</p><p><code></code>ost->st->avg_frame_rate = ist->st->avg_frame_rate;</p><p><code></code>break;</p><p><code></code>case AVMEDIA_TYPE_SUBTITLE:</p><p><code></code>//字幕的</p><p><code></code>codec->width = icodec->width;</p><p><code></code>codec->height = icodec->height;</p><p><code></code>break;</p><p><code></code>case AVMEDIA_TYPE_DATA:</p><p><code></code>case AVMEDIA_TYPE_ATTACHMENT:</p><p><code></code>//??的</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>abort();</p><p><code></code>}</p><p><code></code>}</p><p><code></code>else</p><p><code></code>{</p><p><code></code>//如果不是复制,就麻烦多了</p><p><code></code>//获取编码器</p><p><code></code>if (!ost->enc)</p><p><code></code>ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);</p><p><code></code>//因为需要转换,所以既需解码又需编码</p><p><code></code>ist->decoding_needed = 1;</p><p><code></code>ost->encoding_needed = 1;</p><p><code></code>switch(codec->codec_type)</p><p><code></code>{</p><p><code></code>case AVMEDIA_TYPE_AUDIO:</p><p><code></code>//鼓捣音频编码器的参数,基本上是把一些不合适的参数替换掉</p><p><code></code>ost->fifo = av_fifo_alloc(1024);//音频数据所在的缓冲</p><p><code></code>if (!ost->fifo) {</p><p><code></code>return AVERROR(ENOMEM);</p><p><code></code>}</p><p><code></code>//采样率</p><p><code></code>if (!codec->sample_rate)</p><p><code></code>codec->sample_rate = icodec->sample_rate;</p><p><code></code>choose_sample_rate(ost->st, ost->enc);</p><p><code></code>codec->time_base = (AVRational){1, codec->sample_rate};</p><p><code></code>//样点格式</p><p><code></code>if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)</p><p><code></code>codec->sample_fmt = icodec->sample_fmt;</p><p><code></code>choose_sample_fmt(ost->st, ost->enc);</p><p><code></code>//声道</p><p><code></code>if (ost->audio_channels_mapped) {</p><p><code></code>/* the requested output channel is set to the number of</p><p><code></code>* -map_channel only if no -ac are specified */</p><p><code></code>if (!codec->channels) {</p><p><code></code>codec->channels = ost->audio_channels_mapped;</p><p><code></code>codec->channel_layout = av_get_default_channel_layout(codec->channels);</p><p><code></code>if (!codec->channel_layout) {</p><p><code></code>av_log(NULL, AV_LOG_FATAL, "Unable to find an appropriate channel layout for requested number of channel\n);</p><p><code></code>exit_program(1);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* fill unused channel mapping with -1 (which means a muted</p><p><code></code>* channel in case the number of output channels is bigger</p><p><code></code>* than the number of mapped channel) */</p><p><code></code>for (j = ost->audio_channels_mapped; j &lt; FF_ARRAY_ELEMS(ost->audio_channels_map); j++)</p><p><code></code><span></span>ost->audio_channels_map[j] = -1;</p><p><code></code>}else if (!codec->channels){</p><p><code></code>codec->channels = icodec->channels;</p><p><code></code>codec->channel_layout = icodec->channel_layout;</p><p><code></code>}</p><p><code></code>if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)</p><p><code></code>codec->channel_layout = 0;</p><p><code></code>//是否需要重采样</p><p><code></code>ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;</p><p><code></code>ost->audio_resample |= codec->sample_fmt != icodec->sample_fmt ||</p><p><code></code>codec->channel_layout != icodec->channel_layout;</p><p><code></code>icodec->request_channels = codec->channels;</p><p><code></code>ost->resample_sample_fmt = icodec->sample_fmt;</p><p><code></code>ost->resample_sample_rate = icodec->sample_rate;</p><p><code></code>ost->resample_channels = icodec->channels;</p><p><code></code>break;</p><p><code></code>case AVMEDIA_TYPE_VIDEO:</p><p><code></code>//鼓捣视频编码器的参数,基本上是把一些不合适的参数替换掉</p><p><code></code>if (codec->pix_fmt == PIX_FMT_NONE)</p><p><code></code>codec->pix_fmt = icodec->pix_fmt;</p><p><code></code>choose_pixel_fmt(ost->st, ost->enc);</p><p><code></code>if (ost->st->codec->pix_fmt == PIX_FMT_NONE){</p><p><code></code>av_log(NULL, AV_LOG_FATAL, "Video pixel format is unknown, stream cannot be encoded\n");</p><p><code></code>exit_program(1);</p><p><code></code>}</p><p><code></code>//宽高</p><p><code></code>if (!codec->width || !codec->height){</p><p><code></code>codec->width = icodec->width;</p><p><code></code>codec->height = icodec->height;</p><p><code></code>}</p><p><code></code>//视频是否需要重采样</p><p><code></code>ost->video_resample = codec->width != icodec->width ||</p><p><code></code>codec->height != icodec->height ||</p><p><code></code>codec->pix_fmt != icodec->pix_fmt;</p><p><code></code>if (ost->video_resample){</p><p><code></code>codec->bits_per_raw_sample= frame_bits_per_raw_sample;</p><p><code></code>}</p><p><code></code>ost->resample_height = icodec->height;</p><p><code></code>ost->resample_width = icodec->width;</p><p><code></code>ost->resample_pix_fmt = icodec->pix_fmt;</p><p><code></code>//计算帧率</p><p><code></code>if (!ost->frame_rate.num)</p><p><code></code>ost->frame_rate = ist->st->r_frame_rate.num ?</p><p><code></code>ist->st->r_frame_rate : (AVRational){25,1};</p><p><code></code>if (ost->enc && ost->enc->supported_framerates && !ost->force_fps) {</p><p><code></code>int idx = av_find_nearest_q_idx(ost->frame_rate,ost->enc->supported_framerates);</p><p><code></code>ost->frame_rate = ost->enc->supported_framerates[idx];</p><p><code></code>}</p><p><code></code>codec->time_base = (AVRational) {ost->frame_rate.den, ost->frame_rate.num};</p><p><code></code>if( av_q2d(codec->time_base) &lt; 0.001 &&</p><p><code></code>video_sync_method &&</p><p><code></code>(video_sync_method==1 ||</p><p><code></code>(video_sync_method&lt;0 && !</p><p><code></code>(oc->oformat->flags & AVFMT_VARIABLE_FPS))))</p><p><code></code>{</p><p><code></code>av_log(oc, AV_LOG_WARNING, "Frame rate very high for a muxer not effciciently supporting it.\n"</p><p><code></code>"Please consider specifiying a lower framerate, a different muxer or -vsync 2\n");</p><p><code></code>}</p><p><code></code><span></span>for (j = 0; j &lt; ost->forced_kf_count; j++)</p><p><code></code>ost->forced_kf_pts[j] = av_rescale_q(ost->forced_kf_pts[j],</p><p><code></code>AV_TIME_BASE_Q, codec->time_base);</p><p><code></code>break;</p><p><code></code>case AVMEDIA_TYPE_SUBTITLE:</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>abort();</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>/* two pass mode */</p><p><code></code>if (codec->codec_id != CODEC_ID_H264 &&</p><p><code></code>(codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)))</p><p><code></code>{</p><p><code></code>char logfilename[1024];</p><p><code></code>FILE *f;</p><p><code></code>snprintf(logfilename, sizeof(logfilename), "%s-%d.log",</p><p><code></code>pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,</p><p><code></code>i);</p><p><code></code>if (codec->flags & CODEC_FLAG_PASS2){</p><p><code></code>char *logbuffer;</p><p><code></code>size_t logbuffer_size;</p><p><code></code>if (cmdutils_read_file(logfilename, &logbuffer, &logbuffer_size) &lt; 0){</p><p><code></code>av_log(NULL, AV_LOG_FATAL,</p><p><code></code>"Error reading log file '%s' for pass-2 encoding\n",</p><p><code></code>logfilename);</p><p><code></code>exit_program(1);</p><p><code></code>}</p><p><code></code>codec->stats_in = logbuffer;</p><p><code></code>}</p><p><code></code>if (codec->flags & CODEC_FLAG_PASS1){</p><p><code></code>f = fopen(logfilename, "wb");</p><p><code></code>if (!f) {</p><p><code></code>av_log(NULL, AV_LOG_FATAL, "Cannot write log file '%s' for pass-1 encoding: %s\n",</p><p><code></code>logfilename, strerror(errno));</p><p><code></code>exit_program(1);</p><p><code></code>}</p><p><code></code>ost->logfile = f;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (codec->codec_type == AVMEDIA_TYPE_VIDEO){</p><p><code></code>/* maximum video buffer size is 6-bytes per pixel, plus DPX header size (1664)*/</p><p><code></code>//计算编码输出缓冲的大小,计算一个最大值</p><p><code></code>int size = codec->width * codec->height;</p><p><code></code>bit_buffer_size = FFMAX(bit_buffer_size, 7 * size + 10000);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//分配编码后数据所在的缓冲</p><p><code></code>if (!bit_buffer)</p><p><code></code>bit_buffer = av_malloc(bit_buffer_size);</p><p><code></code>if (!bit_buffer){</p><p><code></code>av_log(NULL, AV_LOG_ERROR,</p><p><code></code>"Cannot allocate %d bytes output buffer\n",</p><p><code></code>bit_buffer_size);</p><p><code></code>return AVERROR(ENOMEM);</p><p><code></code>}</p><p><code></code>//轮循所有输出流,打开每个输出流的编码器</p><p><code></code>for (i = 0; i &lt; nb_output_streams; i++)</p><p><code></code>{</p><p><code></code>ost = &output_streams[i];</p><p><code></code>if (ost->encoding_needed){</p><p><code></code>//当然,只有在需要编码时才打开编码器</p><p><code></code>AVCodec *codec = ost->enc;</p><p><code></code>AVCodecContext *dec = input_streams[ost->source_index].st->codec;</p><p><code></code>if (!codec) {</p><p><code></code>snprintf(error, sizeof(error),</p><p><code></code>"Encoder (codec %s) not found for output stream #%d:%d",</p><p><code></code>avcodec_get_name(ost->st->codec->codec_id),</p><p><code></code>ost->file_index, ost->index);</p><p><code></code>ret = AVERROR(EINVAL);</p><p><code></code>goto dump_format;</p><p><code></code>}</p><p><code></code>if (dec->subtitle_header){</p><p><code></code>ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);</p><p><code></code>if (!ost->st->codec->subtitle_header){</p><p><code></code>ret = AVERROR(ENOMEM);</p><p><code></code>goto dump_format;</p><p><code></code>}</p><p><code></code>memcpy(ost->st->codec->subtitle_header,</p><p><code></code>dec->subtitle_header,dec->subtitle_header_size);</p><p><code></code>ost->st->codec->subtitle_header_size = dec->subtitle_header_size;</p><p><code></code>}</p><p><code></code>//打开啦</p><p><code></code>if (avcodec_open2(ost->st->codec, codec, &ost->opts) &lt; 0) {</p><p><code></code>snprintf(error, sizeof(error),</p><p><code></code>"Error while opening encoder for output stream #%d:%d - maybe incorrect parameters such as bit_rate, rate, width or height",</p><p><code></code>ost->file_index, ost->index);</p><p><code></code>ret = AVERROR(EINVAL);</p><p><code></code>goto dump_format;</p><p><code></code>}</p><p><code></code>assert_codec_experimental(ost->st->codec, 1);</p><p><code></code>assert_avoptions(ost->opts);</p><p><code></code>if (ost->st->codec->bit_rate && ost->st->codec->bit_rate &lt; 1000)</p><p><code></code>av_log(NULL, AV_LOG_WARNING,</p><p><code></code>"The bitrate parameter is set too low."</p><p><code></code>" It takes bits/s as argument, not kbits/s\n");</p><p><code></code>extra_size += ost->st->codec->extradata_size;</p><p><code></code>if (ost->st->codec->me_threshold)</p><p><code></code>input_streams[ost->source_index].st->codec->debug |= FF_DEBUG_MV;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//初始化所有的输入流(主要做的就是在需要时打开解码器)</p><p><code></code>for (i = 0; i &lt; nb_input_streams; i++)</p><p><code></code>if ((ret = init_input_stream(i, output_streams, nb_output_streams,</p><p><code></code>error, sizeof(error))) &lt; 0)</p><p><code></code>goto dump_format;</p><p><code></code>/* discard unused programs */</p><p><code></code>for (i = 0; i &lt; nb_input_files; i++){</p><p><code></code>InputFile *ifile = &input_files[i];</p><p><code></code>for (j = 0; j &lt; ifile->ctx->nb_programs; j++){</p><p><code></code>AVProgram *p = ifile->ctx->programs[j];</p><p><code></code>int discard = AVDISCARD_ALL;</p><p><code></code>for (k = 0; k &lt; p->nb_stream_indexes; k++){</p><p><code></code>if (!input_streams[ifile->ist_index + p->stream_index[k]].discard){</p><p><code></code>discard = AVDISCARD_DEFAULT;</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>p->discard = discard;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//打开所有输出文件，写入媒体文件头</p><p><code></code>for (i = 0; i &lt; nb_output_files; i++){</p><p><code></code>oc = output_files[i].ctx;</p><p><code></code>oc->interrupt_callback = int_cb;</p><p><code></code>if (avformat_write_header(oc, &output_files[i].opts) &lt; 0){</p><p><code></code>snprintf(error, sizeof(error),</p><p><code></code>"Could not write header for output file #%d (incorrect codec parameters ?)",</p><p><code></code>i);</p><p><code></code>ret = AVERROR(EINVAL);</p><p><code></code>goto dump_format;</p><p><code></code>}</p><p>// assert_avoptions(output_files[i].opts);</p><p><code></code>if (strcmp(oc->oformat->name, "rtp")){</p><p><code></code>want_sdp = 0;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>return 0;</p><p>}</p><h2 id=86-transcode><strong>8.6 transcode()</strong></h2><p><strong>[cpp]</strong> <a href=http://blog.csdn.net/niu_gao/article/details/7175421#>view plain</a><a href=http://blog.csdn.net/niu_gao/article/details/7175421#>copy</a></p><p>直接从主函数进行分析</p><p>int main(int argc, char **argv)</p><p>{</p><p><code></code>OptionsContext o = { 0 };</p><p><code></code>int64_t ti;</p><p><code></code>//与命令行分析有关的结构的初始化,下面不再罗嗦</p><p><code></code>reset_options(&o, 0);</p><p><code></code>//设置日志级别</p><p><code></code>av_log_set_flags(AV_LOG_SKIP_REPEATED);</p><p><code></code>parse_loglevel(argc, argv, options);</p><p><code></code>if (argc > 1 && !strcmp(argv[1], "-d")) {</p><p><code></code>run_as_daemon = 1;</p><p><code></code>av_log_set_callback(log_callback_null);</p><p><code></code>argc--;</p><p><code></code>argv++;</p><p><code></code>}</p><p><code></code>//注册组件们</p><p><code></code>avcodec_register_all();</p><p>#if CONFIG_AVDEVICE</p><p><code></code>avdevice_register_all();</p><p>#endif</p><p>#if CONFIG_AVFILTER</p><p><code></code>avfilter_register_all();</p><p>#endif</p><p><code></code>av_register_all();</p><p><code></code>//初始化网络,windows下需要</p><p><code></code>avformat_network_init();</p><p><code></code>show_banner();</p><p><code></code>term_init();</p><p><code></code>//分析命令行输入的参数们</p><p><code></code>parse_options(&o, argc, argv, options, opt_output_file);</p><p><code></code>//文件的转换就在此函数中发生</p><p><code></code>if (transcode(output_files, nb_output_files, input_files, nb_input_files)&lt; 0)</p><p><code></code>exit_program(1);</p><p><code></code>exit_program(0);</p><p><code></code>return 0;</p><p>}</p><p>下面是transcode()函数,转换就发生在它里面.不废话,看注释吧,应很详细了</p><p>static int transcode(</p><p><code></code>OutputFile *output_files,//输出文件数组</p><p><code></code>int nb_output_files,//输出文件的数量</p><p><code></code>InputFile *input_files,//输入文件数组</p><p><code></code>int nb_input_files)//输入文件的数量</p><p>{</p><p><code></code>int ret, i;</p><p><code></code>AVFormatContext *is, *os;</p><p><code></code>OutputStream *ost;</p><p><code></code>InputStream *ist;</p><p><code></code>uint8_t *no_packet;</p><p><code></code>int no_packet_count = 0;</p><p><code></code>int64_t timer_start;</p><p><code></code>int key;</p><p><code></code>if (!(no_packet = av_mallocz(nb_input_files)))</p><p><code></code>exit_program(1);</p><p><code></code>//设置编码参数,打开所有输出流的编码器,打开所有输入流的解码器,写入所有输出文件的文件头,于是准备好了</p><p><code></code>ret = transcode_init(output_files, nb_output_files, input_files,nb_input_files);</p><p><code></code>if (ret &lt; 0)</p><p><code></code>goto fail;</p><p><code></code>if (!using_stdin){</p><p><code></code>av_log(NULL, AV_LOG_INFO, "Press [q] to stop, [?] for help\n");</p><p><code></code>}</p><p><code></code>timer_start = av_gettime();</p><p><code></code>//循环,直到收到系统信号才退出</p><p><code></code>for (; received_sigterm == 0;)</p><p><code></code>{</p><p><code></code>int file_index, ist_index;</p><p><code></code>AVPacket pkt;</p><p><code></code>int64_t ipts_min;</p><p><code></code>double opts_min;</p><p><code></code>int64_t cur_time = av_gettime();</p><p><code></code>ipts_min = INT64_MAX;</p><p><code></code>opts_min = 1e100;</p><p><code></code>/* if 'q' pressed, exits */</p><p><code></code>if (!using_stdin)</p><p><code></code>{</p><p><code></code>//先查看用户按下了什么键,跟据键做出相应的反应</p><p><code></code>static int64_t last_time;</p><p><code></code>if (received_nb_signals)</p><p><code></code>break;</p><p><code></code>/* read_key() returns 0 on EOF */</p><p><code></code>if (cur_time - last_time >= 100000 && !run_as_daemon){</p><p><code></code>key = read_key();</p><p><code></code>last_time = cur_time;</p><p><code></code>}else{</p><p><code></code>}</p><p><code></code>/* select the stream that we must read now by looking at the</p><p><code></code>smallest output pts */</p><p><code></code>//下面这个循环的目的是找一个最小的输出pts(也就是离当前最近的)的输出流</p><p><code></code>file_index = -1;</p><p><code></code>for (i = 0; i &lt; nb_output_streams; i++){</p><p><code></code>OutputFile *of;</p><p><code></code>int64_t ipts;</p><p><code></code>double opts;</p><p><code></code>ost = &output_streams[i];//循环每一个输出流</p><p><code></code>of = &output_files[ost->file_index];//输出流对应的输出文件</p><p><code></code>os = output_files[ost->file_index].ctx;//输出流对应的FormatContext</p><p><code></code>ist = &input_streams[ost->source_index];//输出流对应的输入流</p><p><code></code>if (ost->is_past_recording_time || //是否过了录制时间?(可能用户指定了一个录制时间段)</p><p><code></code>no_packet[ist->file_index]|| //对应的输入流这个时间内没有数据?</p><p><code></code>(os->pb && avio_tell(os->pb) >= of->limit_filesize))//是否超出了录制范围(也是用户指定的)</p><p><code></code>continue;//是的,符合上面某一条,那么再看下一个输出流吧</p><p><code></code>//判断当前输入流所在的文件是否可以使用(我也不很明白)</p><p><code></code>opts = ost->st->pts.val * av_q2d(ost->st->time_base);</p><p><code></code>ipts = ist->pts;</p><p><code></code>if (!input_files[ist->file_index].eof_reached) {</p><p><code></code>if (ipts &lt; ipts_min){</p><p><code></code>//每找到一个pts更小的输入流就记录下来,这样循环完所有的输出流时就找到了</p><p><code></code>//pts最小的输入流,及输入文件的序号</p><p><code></code>ipts_min = ipts;</p><p><code></code>if (input_sync)</p><p><code></code>file_index = ist->file_index;</p><p><code></code>}</p><p><code></code>if (opts &lt; opts_min){</p><p><code></code>opts_min = opts;</p><p><code></code>if (!input_sync)</p><p><code></code>file_index = ist->file_index;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//难道下面这句话的意思是:如果当前的输出流已接收的帧数,超出用户指定的输出最大帧数时,</p><p><code></code>//则当前输出流所属的输出文件对应的所有输出流,都算超过了录像时间?</p><p><code></code>if (ost->frame_number >= ost->max_frames){</p><p><code></code>int j;</p><p><code></code>for (j = 0; j &lt; of->ctx->nb_streams; j++)</p><p><code></code>output_streams[of->ost_index + j].is_past_recording_time = 1;</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* if none, if is finished */</p><p><code></code>if (file_index &lt; 0) {</p><p><code></code>//如果没有找到合适的输入文件</p><p><code></code>if (no_packet_count){</p><p><code></code>//如果是因为有的输入文件暂时得不到数据,则还不算是结束</p><p><code></code>no_packet_count = 0;</p><p><code></code>memset(no_packet, 0, nb_input_files);</p><p><code></code>usleep(10000);</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>//全部转换完成了,跳出大循环</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>//从找到的输入文件中读出一帧(可能是音频也可能是视频),并放到fifo队列中</p><p><code></code>is = input_files[file_index].ctx;</p><p><code></code>ret = av_read_frame(is, &pkt);</p><p><code></code>if (ret == AVERROR(EAGAIN)) {</p><p><code></code>//此时发生了暂时没数据的情况</p><p><code></code>no_packet[file_index] = 1;</p><p><code></code>no_packet_count++;</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>//下文判断是否有输入文件到最后了</p><p><code></code>if (ret &lt; 0){</p><p><code></code>input_files[file_index].eof_reached = 1;</p><p><code></code>if (opt_shortest)</p><p><code></code>break;</p><p><code></code>else</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>no_packet_count = 0;</p><p><code></code>memset(no_packet, 0, nb_input_files);</p><p><code></code>if (do_pkt_dump){</p><p><code></code>av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,</p><p><code></code>is->streams[pkt.stream_index]);</p><p><code></code>}</p><p><code></code>/* the following test is needed in case new streams appear</p><p><code></code>dynamically in stream : we ignore them */</p><p><code></code>//如果在输入文件中遇到一个忽然冒出的流,那么我们不鸟它</p><p><code></code>if (pkt.stream_index >= input_files[file_index].nb_streams)</p><p><code></code>goto discard_packet;</p><p><code></code>//取得当前获得的帧对应的输入流</p><p><code></code>ist_index = input_files[file_index].ist_index + pkt.stream_index;</p><p><code></code>ist = &input_streams[ist_index];</p><p><code></code>if (ist->discard)</p><p><code></code>goto discard_packet;</p><p><code></code>//重新鼓捣一下帧的时间戳</p><p><code></code>if (pkt.dts != AV_NOPTS_VALUE)</p><p><code></code>pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset,</p><p><code></code>AV_TIME_BASE_Q, ist->st->time_base);</p><p><code></code>if (pkt.pts != AV_NOPTS_VALUE)</p><p><code></code>pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset,</p><p><code></code>AV_TIME_BASE_Q, ist->st->time_base);</p><p><code></code>if (pkt.pts != AV_NOPTS_VALUE)</p><p><code></code>pkt.pts *= ist->ts_scale;</p><p><code></code>if (pkt.dts != AV_NOPTS_VALUE)</p><p><code></code>pkt.dts *= ist->ts_scale;</p><p><code></code>if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE</p><p><code></code>&& (is->iformat->flags & AVFMT_TS_DISCONT))</p><p><code></code>{</p><p><code></code>int64_t pkt_dts = av_rescale_q(pkt.dts, ist->st->time_base,</p><p><code></code>AV_TIME_BASE_Q);</p><p><code></code>int64_t delta = pkt_dts - ist->next_pts;</p><p><code></code>if ((delta &lt; -1LL * dts_delta_threshold * AV_TIME_BASE</p><p><code></code>|| (delta > 1LL * dts_delta_threshold * AV_TIME_BASE</p><p><code></code>&& ist->st->codec->codec_type</p><p><code></code>!= AVMEDIA_TYPE_SUBTITLE)</p><p><code></code>|| pkt_dts + 1 &lt; ist->pts) && !copy_ts)</p><p><code></code>{</p><p><code></code>input_files[ist->file_index].ts_offset -= delta;</p><p><code></code>av_log( NULL, AV_LOG_DEBUG,</p><p><code></code>"timestamp discontinuity %"PRId64", new offset= %"PRId64"\n",</p><p><code></code>delta, input_files[ist->file_index].ts_offset);</p><p><code></code>pkt.dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);</p><p><code></code>if (pkt.pts != AV_NOPTS_VALUE)</p><p><code></code>pkt.pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//把这一帧转换并写入到输出文件中</p><p><code></code>if (output_packet(ist, output_streams, nb_output_streams, &pkt) &lt; 0){</p><p><code></code>av_log(NULL, AV_LOG_ERROR,</p><p><code></code>"Error while decoding stream #%d:%d\n",</p><p><code></code>ist->file_index, ist->st->index);</p><p><code></code>if (exit_on_error)</p><p><code></code>exit_program(1);</p><p><code></code>av_free_packet(&pkt);</p><p><code></code>continue;</p><p><code></code>}</p><p>discard_packet:</p><p><code></code>av_free_packet(&pkt);</p><p><code></code>/* dump report by using the output first video and audio streams */</p><p><code></code>print_report(output_files, output_streams, nb_output_streams, 0,</p><p><code></code>timer_start, cur_time);</p><p><code></code>}</p><p><code></code>//文件处理完了,把缓冲中剩余的数据写到输出文件中</p><p><code></code>for (i = 0; i &lt; nb_input_streams; i++){</p><p><code></code>ist = &input_streams[i];</p><p><code></code>if (ist->decoding_needed){</p><p><code></code>output_packet(ist, output_streams, nb_output_streams, NULL);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>flush_encoders(output_streams, nb_output_streams);</p><p><code></code>term_exit();</p><p><code></code>//为输出文件写文件尾(有的不需要).</p><p><code></code>for (i = 0; i &lt; nb_output_files; i++){</p><p><code></code>os = output_files[i].ctx;</p><p><code></code>av_write_trailer(os);</p><p><code></code>}</p><p><code></code>/* dump report by using the first video and audio streams */</p><p><code></code>print_report(output_files, output_streams, nb_output_streams, 1,</p><p><code></code>timer_start, av_gettime());</p><p><code></code>//关闭所有的编码器</p><p><code></code>for (i = 0; i &lt; nb_output_streams; i++){</p><p><code></code>ost = &output_streams[i];</p><p><code></code>if (ost->encoding_needed){</p><p><code></code>av_freep(&ost->st->codec->stats_in);</p><p><code></code>avcodec_close(ost->st->codec);</p><p><code></code>}</p><p>#if CONFIG_AVFILTER</p><p><code></code>avfilter_graph_free(&ost->graph);</p><p>#endif</p><p><code></code>}</p><p><code></code>//关闭所有的解码器</p><p><code></code>for (i = 0; i &lt; nb_input_streams; i++){</p><p><code></code>ist = &input_streams[i];</p><p><code></code>if (ist->decoding_needed){</p><p><code></code>avcodec_close(ist->st->codec);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* finished ! */</p><p><code></code>ret = 0;</p><p><code></code>fail: av_freep(&bit_buffer);</p><p><code></code>av_freep(&no_packet);</p><p><code></code>if (output_streams) {</p><p><code></code>for (i = 0; i &lt; nb_output_streams; i++) {</p><p><code></code>ost = &output_streams[i];</p><p><code></code>if (ost) {</p><p><code></code>if (ost->stream_copy)</p><p><code></code>av_freep(&ost->st->codec->extradata);</p><p><code></code>if (ost->logfile){</p><p><code></code>fclose(ost->logfile);</p><p><code></code>ost->logfile = NULL;</p><p><code></code>}</p><p><code></code>av_fifo_free(ost->fifo); /* works even if fifo is not</p><p><code></code>initialized but set to zero */</p><p><code></code>av_freep(&ost->st->codec->subtitle_header);</p><p><code></code>av_free(ost->resample_frame.data[0]);</p><p><code></code>av_free(ost->forced_kf_pts);</p><p><code></code>if (ost->video_resample)</p><p><code></code>sws_freeContext(ost->img_resample_ctx);</p><p><code></code>swr_free(&ost->swr);</p><p><code></code>av_dict_free(&ost->opts);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>return ret;</p><p>}</p><h1 id=第九章-ffmpeg相关工程><strong>第九章 ffmpeg相关工程</strong></h1><h2 id=91-ffdshow><strong>9.1 ffdshow</strong></h2><p>ffdshow是基于ffmpeg的解码器类库libavcodec的DirectShow Filter。广泛安装在PC上</p><h3 id=ffdshow-源代码分析1--整体结构httpblogcsdnnetleixiaohua1020articledetails12013619><a href=http://blog.csdn.net/leixiaohua1020/article/details/12013619><strong>ffdshow 源代码分析1 ： 整体结构</strong></a></h3><p>ffdshow是一个非常强大的DirectShow解码器，封装了ffmpeg，libmpeg2等解码库。它也提供了丰富的加工处理选项，可以锐化画面，调节画面的亮度等等。不止是视频，FFDShow现在同样可以解码音频，AC3、MP3等音频格式都可支持。并且可以外挂winamp 的DSP插件，来改善听觉效果。一个词形容：强大。</p><p>因为项目的要求，需要对ffdshow进行二次开发，正好有这个机会，分析研究一下ffdshow的源代码。</p><p>ffdshow项目的资源可以从sourceforge下载。包括编译好的程序，以及原代码等，下载地址：<a href=http://sourceforge.net/projects/ffdshow-tryout/>http://sourceforge.net/projects/ffdshow-tryout/</a></p><p>注意：sourceforge上有两个版本的ffdshow：ffdshow以及ffdshow-tryout。其中前一个版本很早之前已经停止开发了，因此我们需要选择后一个（ffdshow-tryout）。</p><p>下载源代码的方法不再赘述，下面直接进入正题。源代码下载后，需要进行编译，推荐使用源代码根目录下的bat脚本一次性完成所有的资源编译。</p><p>编译完成后我们就可以打开源代码根目录里的工程了。我自己的开发环境是VC2010，打开后工程如下图所示（解决方案的名字被我修改了= =）：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.143.jpeg alt></p><p>由图可见，ffdshow由一大堆工程组成，乍一看给人一种杂论无章的感觉，其实大部分工程我们不用去理会，我们重点研究最重要的工程就是那个名字叫“ffdshow”的工程。</p><p>下面我介绍几个最重要的文件夹里包含的代码的功能：</p><p>audiofilters：音频滤镜都在这里面（例如EQ，调节高低频等）</p><p>baseclasses：微软自带directshow的sdk里面就有，主要是微软为了方便DirectShow开发而提供的一些基本的类</p><p>codecs：支持的解码器都在这里（例如libavcodec，libmpeg2等）</p><p>convert：色彩转换的一些功能（没太用过）</p><p>decss：解除版权加密的一些功能（没太用过）</p><p>dialog：音频视频滤镜的配置页面</p><p>doc：文档，不是程序</p><p>ffvfw：VFW相关（目前没太用过）</p><p>Header Files：核心代码的头文件</p><p>imgfilters：视频滤镜都在这里（显示QP/MV，加LOGO，显示视频信息等）</p><p>Resource Files：资源文件</p><p>settings：音频视频滤镜的配置信息</p><p>Source Files：核心代码的源文件</p><p>subtitles：字幕相关的功能</p><p>以上用红色标出的，是我们二次开发中最有可能会涉及到的三个部分。掌握了这三个部分，就可以往ffdhow中添加自己写的滤镜（注意：这里说的是视频滤镜，音频的方法是一样的）</p><p>黄色背景标出的部分，虽然我们可能不需要做出什么改变，但是为了了解ffdshow的架构，我们需要分析其中的代码。</p><h3 id=ffdshow-源代码分析-2-位图覆盖滤镜对话框部分dialoghttpblogcsdnnetleixiaohua1020articledetails12981725><a href=http://blog.csdn.net/leixiaohua1020/article/details/12981725><strong>ffdshow 源代码分析 2： 位图覆盖滤镜（对话框部分Dialog）</strong></a></h3><p>本文我们介绍ffdshow的滤镜功能。ffdshow支持很多种滤镜，可以支持多种视频和音频的后期效果。例如OSD滤镜支持在视频的左上角显示视频相关的信息。而可视化滤镜则支持显示视频每一帧的运动矢量以及量化参数。在这里我们介绍一种位图覆盖（Bitmap）滤镜（Filter）。</p><p>效果</p><p>编译完ffdshow之后，在“项目属性->调试->命令”里面将GraphEdit.exe所在位置设置为调试程序，例如在这里我设置了《终极解码》里面自带GraphEdit.exe，路径为“C:\Program Files\Final Codecs\Codecs\GraphEdit.exe”。这样就可以使用GraphEdit.exe调试ffdshow了。</p><p>向GraphEdit.exe里面拖入一个文件“五月天 咸鱼.mp4”，结果如下图所示：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.144.jpeg alt></p><p>注：有的时候默认的视频解码器可能不是ffdshow，可能是CoreAVC等，可以先删除视频解码器然后添加ffdshow。</p><p>点击绿色三角形按钮就可以开始播放视频。</p><p>右键点击ffdshow组件，打开属性对话框之后，可以看见右边栏中有很多的滤镜。</p><p>勾选“位图覆盖”滤镜，然后选择一张用于覆盖的图片（在这里我选择了一张bmp格式的专辑封面）。</p><p>注：可以调整位图所在的水平位置，垂直位置，不透明度，并且可以修改位图叠加模式（在这里用混合）。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.145.jpeg alt></p><p>添加了该滤镜之后，播放窗口的显示内容为：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.146.jpeg alt></p><p>可见在右上角显示出了叠加的位图。</p><p>源代码分析</p><p>1.对话框部分</p><p>与位图覆盖（Bitmap）滤镜的对话框有关的类位于dialog目录下的Cbitmap.cpp和Cbitmap.h文件中。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.147.jpeg alt></p><p>先来看看Cbitmap.h中类的声明：</p><p>需要注意的是，里面类的名字居然叫TbitmapPage，而没有和头文件名字一致。= =</p><p>#ifndef _CBITMAPPAGE_H_</p><p>#define _CBITMAPPAGE_H_</p><p>#include "TconfPageDecVideo.h"</p><p>//Bitmap配置页面</p><p>class TbitmapPage : public TconfPageDecVideo</p><p>{</p><p>private:</p><p><code></code>void pos2dlg(void), opacity2dlg(void);</p><p><code></code>//设置文件路径</p><p><code></code>void onFlnm(void);</p><p>protected:</p><p><code></code>virtual INT_PTR msgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);</p><p>public:</p><p><code></code>//构造函数</p><p><code></code>TbitmapPage(TffdshowPageDec *Iparent, const TfilterIDFF *idff);</p><p><code></code>//初始化</p><p><code></code>virtual void init(void);</p><p><code></code>//配置数据传入到对话框界面</p><p><code></code>virtual void cfg2dlg(void);</p><p><code></code>virtual void translate(void);</p><p>};</p><p>#endif</p><p>再看看Cbitmap.cpp文件吧。关键的代码都已经加上了注释。</p><p>/*</p><p><code></code>* Copyright (c) 2004-2006 Milan Cutka</p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License</p><p><code></code>* along with this program; if not, write to the Free Software</p><p><code></code>* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</p><p><code></code>*/</p><p>//Bitmap配置页面</p><p>#include "stdafx.h"</p><p>#include "TsubtitlesSettings.h"</p><p>#include "TbitmapSettings.h"</p><p>#include "Cbitmap.h"</p><p>//初始化</p><p>void TbitmapPage::init(void)</p><p>{</p><p><code></code>//设置滑动条范围</p><p><code></code>edLimitText(IDC_ED_BITMAP_FLNM, MAX_PATH);</p><p><code></code>tbrSetRange(IDC_TBR_BITMAP_POSX, 0, 100, 10);</p><p><code></code>tbrSetRange(IDC_TBR_BITMAP_POSY, 0, 100, 10);</p><p><code></code>tbrSetRange(IDC_TBR_BITMAP_OPACITY, 0, 256);</p><p>}</p><p>//配置数据传入到对话框界面</p><p>void TbitmapPage::cfg2dlg(void)</p><p>{</p><p><code></code>//各种设置</p><p><code></code>//EditControl设置</p><p><code></code>setDlgItemText(m_hwnd, IDC_ED_BITMAP_FLNM, cfgGetStr(IDFF_bitmapFlnm));</p><p><code></code>pos2dlg();</p><p><code></code>cbxSetCurSel(IDC_CBX_BITMAP_ALIGN, cfgGet(IDFF_bitmapAlign));</p><p><code></code>cbxSetCurSel(IDC_CBX_BITMAP_MODE, cfgGet(IDFF_bitmapMode));</p><p><code></code>opacity2dlg();</p><p>}</p><p>//Bitmap位置信息</p><p>void TbitmapPage::pos2dlg(void)</p><p>{</p><p><code></code>char_t s[260];</p><p><code></code>int x;</p><p><code></code>//获取</p><p><code></code>x = cfgGet(IDFF_bitmapPosx);</p><p><code></code>TsubtitlesSettings::getPosHoriz(x, s, this, IDC_LBL_BITMAP_POSX, countof(s));</p><p><code></code>setDlgItemText(m_hwnd, IDC_LBL_BITMAP_POSX, s);</p><p><code></code>//设置</p><p><code></code>tbrSet(IDC_TBR_BITMAP_POSX, x);</p><p><code></code>x = cfgGet(IDFF_bitmapPosy);</p><p><code></code>TsubtitlesSettings::getPosVert(x, s, this, IDC_LBL_BITMAP_POSY, countof(s));</p><p><code></code>setDlgItemText(m_hwnd, IDC_LBL_BITMAP_POSY, s);</p><p><code></code>tbrSet(IDC_TBR_BITMAP_POSY, x);</p><p>}</p><p>void TbitmapPage::opacity2dlg(void)</p><p>{</p><p><code></code>int o = cfgGet(IDFF_bitmapStrength);</p><p><code></code>tbrSet(IDC_TBR_BITMAP_OPACITY, o);</p><p><code></code>setText(IDC_LBL_BITMAP_OPACITY, _l("%s %i%%"), _(IDC_LBL_BITMAP_OPACITY), 100 * o / 256);</p><p>}</p><p>INT_PTR TbitmapPage::msgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)</p><p>{</p><p><code></code>switch (uMsg) {</p><p><code></code>case WM_COMMAND:</p><p><code></code>switch (LOWORD(wParam)) {</p><p><code></code>case IDC_ED_BITMAP_FLNM:</p><p><code></code>if (HIWORD(wParam) == EN_CHANGE && !isSetWindowText) {</p><p><code></code>char_t flnm[MAX_PATH];</p><p><code></code>GetDlgItemText(m_hwnd, IDC_ED_BITMAP_FLNM, flnm, MAX_PATH);</p><p><code></code>cfgSet(IDFF_bitmapFlnm, flnm);</p><p><code></code>}</p><p><code></code>return TRUE;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>return TconfPageDecVideo::msgProc(uMsg, wParam, lParam);</p><p>}</p><p>//设置文件路径</p><p>void TbitmapPage::onFlnm(void)</p><p>{</p><p><code></code>char_t flnm[MAX_PATH];</p><p><code></code>cfgGet(IDFF_bitmapFlnm, flnm, MAX_PATH);</p><p><code></code>if (dlgGetFile(false, m_hwnd, _(-IDD_BITMAP, _l("Load image file")), _l("All supported (*.jpg,*.bmp,*.gif,*.png)\0*.bmp;*.jpg;*.jpeg;*.gif;*.png\0Windows Bitmap (*.bmp)\0*.bmp\0JPEG (*.jpg)\0*.jpg\0Compuserve Graphics Interchange (*.gif)\0*.gif\0Portable Network Graphics (*.png)\0*.png"), _l("bmp"), flnm, _l("."), 0)) {</p><p><code></code>setDlgItemText(m_hwnd, IDC_ED_BITMAP_FLNM, flnm);</p><p><code></code>//设置</p><p><code></code>cfgSet(IDFF_bitmapFlnm, flnm);</p><p><code></code>}</p><p>}</p><p>void TbitmapPage::translate(void)</p><p>{</p><p><code></code>TconfPageBase::translate();</p><p><code></code>cbxTranslate(IDC_CBX_BITMAP_ALIGN, TsubtitlesSettings::alignments);</p><p><code></code>cbxTranslate(IDC_CBX_BITMAP_MODE, TbitmapSettings::modes);</p><p>}</p><p>//构造函数</p><p>TbitmapPage::TbitmapPage(TffdshowPageDec *Iparent, const TfilterIDFF *idff): TconfPageDecVideo(Iparent, idff)</p><p>{</p><p><code></code>//各种绑定</p><p><code></code>resInter = IDC_CHB_BITMAP;</p><p><code></code>static const TbindTrackbar<tbitmappage> htbr[] = {</p><p><code></code>IDC_TBR_BITMAP_POSX, IDFF_bitmapPosx, &TbitmapPage::pos2dlg,</p><p><code></code>IDC_TBR_BITMAP_POSY, IDFF_bitmapPosy, &TbitmapPage::pos2dlg,</p><p><code></code>IDC_TBR_BITMAP_OPACITY, IDFF_bitmapStrength, &TbitmapPage::opacity2dlg,</p><p><code></code>0, 0, NULL</p><p><code></code>};</p><p><code></code>bindHtracks(htbr);</p><p><code></code>static const TbindCombobox<tbitmappage> cbx[] = {</p><p><code></code>IDC_CBX_BITMAP_ALIGN, IDFF_bitmapAlign, BINDCBX_SEL, NULL,</p><p><code></code>IDC_CBX_BITMAP_MODE, IDFF_bitmapMode, BINDCBX_SEL, NULL,</p><p><code></code>0</p><p><code></code>};</p><p><code></code>bindComboboxes(cbx);</p><p><code></code>static const TbindButton<tbitmappage> bt[] = {</p><p><code></code>IDC_BT_BITMAP_FLNM, &TbitmapPage::onFlnm,</p><p><code></code>0, NULL</p><p><code></code>};</p><p><code></code>bindButtons(bt);</p><p>}</p><p>看ffdshow源代码的时候，开始会比较费劲。为什么？因为它使用了大量自己写的API函数，以及自己定义的结构体。这些API函数的种类繁多，如果一个一个都看完，估计就精疲力竭了。经过一段时间的学习之后，我发现最方便的方法还是根据函数名字推测其用法。因此我就不深入剖析ffdshow的API函数了。</p><p>以上源代码中包含以下API（大致按出现先后次序，可能没有例举全，在这里只是举例子）：</p><p>edLimitText();//限制输入字符串长度</p><p>tbrSetRange();//设置滑动条范围</p><p>setDlgItemText();//设置组件名称</p><p>cbxSetCurSel();//设置下拉框当前选项</p><p>cfgGet();//从注册表中读取变量的值</p><p>tbrSet();//设置滑动条的值</p><p>bindHtracks();//绑定注册表变量和滑动条</p><p>bindComboboxes();//绑定注册表变量和下拉框</p><p>bindButtons();//绑定函数和按钮</p><p>从以上函数大致可以看出tbr***()基本上都是操作滑动条的，cbx***()基本上都是操作下拉框的，函数基本上可以从名称上理解其的意思。bind***()就是绑定注册表变量和控件的。注意ffdshow里面有注册表变量这么一个概念。这些变量的值存在系统的注册表里面，不会因为程序结束运行而消失。就目前我的观察来看，绝大部分注册表变量存的是一个整数值。这些注册表变量都以IDFF_xxx的名称预编译定义在ffdshow_constants.h头文件中。与MFC控件可以直接与CString，int等变量绑定不同，ffdshow控件只可以和注册表变量绑定。即每次运行的时候都从注册表加载变量的值到界面上。存储的时候把界面上的值存储到注册表中。</p><p>注：注册表变量如下所示（截取了一小段）</p><p>#define IDFF_filterBitmap 1650</p><p>#define IDFF_isBitmap 1651</p><p>#define IDFF_showBitmap 1652</p><p>#define IDFF_orderBitmap 1653</p><p>#define IDFF_fullBitmap 1654</p><p>#define IDFF_bitmapFlnm 1655</p><p>#define IDFF_bitmapPosx 1656</p><p>#define IDFF_bitmapPosy 1657</p><p>#define IDFF_bitmapPosmode 1658</p><p>#define IDFF_bitmapAlign 1659</p><p>#define IDFF_bitmapMode 1660</p><p>#define IDFF_bitmapStrength 1661</p><p>此外需要注意的是，ffdshow尽管包含了图形化的属性界面，却没有使用MFC类库，因而MFC的很多函数都不能使用，对此我还不甚了解为什么要这样，以后有机会要探究探究。</p><h3 id=ffdshow-源代码分析-3-位图覆盖滤镜设置部分settingshttpblogcsdnnetleixiaohua1020articledetails13004051><a href=http://blog.csdn.net/leixiaohua1020/article/details/13004051><strong>ffdshow 源代码分析 3： 位图覆盖滤镜（设置部分Settings）</strong></a></h3><p>在这里再介绍一下设置部分（Settings），此外还有一个滤镜部分（Filter）。这三个部分就可以组成一个ffdshow的滤镜功能了。</p><p>设置部分（Settings）</p><p>在ffdshow中滤镜的设置部分（Settings）主要用于存储滤镜运行过程中需要用到的各种变量。一般情况下通过读取注册表变量并赋值给该类当中的变量从而达到操作相应滤镜的功能。</p><p>与位图覆盖（Bitmap）滤镜的设置有关的类位于settings->filters->video目录下（隐藏的很深啊）的TbitmapSettings.cpp和TbitmapSettings.h文件中。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.148.jpeg alt></p><p>先来看看TbitmapSettings.h</p><p>该类的名字叫TbitmapSettings，从类的定义我们可以看出，</p><p>flnm[]存储了打开的位图的路径</p><p>posx，posy存储了位图在屏幕上显示的位置</p><p>mode存储了显示的方式</p><p>等等，所有跟该滤镜（Filter）相关的数据都存储在该类之中。</p><p>该类包含一个TfilterIDFF类型的结构体idffs，用于存储该滤镜的一些属性信息（名称，ID，属性对话框ID等等）</p><p>此外，有两个函数至关重要。createFilters()用于创建滤镜（Filter）。 createPages()用于创建滤镜的配置对话框（Dialog）。</p><p>#ifndef _TBITMAPSETTINGS_H_</p><p>#define _TBITMAPSETTINGS_H_</p><p>//各个Filter预设值</p><p>#include "TfilterSettings.h"</p><p>#include "Tfont.h"</p><p>//Bitmap的配置信息</p><p>struct TbitmapSettings : TfilterSettingsVideo {</p><p>private:</p><p><code></code>static const TfilterIDFF idffs;</p><p>protected:</p><p><code></code>virtual const int *getResets(unsigned int pageId);</p><p>public:</p><p><code></code>TbitmapSettings(TintStrColl *Icoll = NULL, TfilterIDFFs *filters = NULL);</p><p><code></code>//Bitmap文件路径</p><p><code></code>char_t flnm[MAX_PATH];</p><p><code></code>//x,y坐标，以及坐标的模式</p><p><code></code>int posx, posy, posmode;</p><p><code></code>int align;</p><p><code></code>//叠加方式</p><p><code></code>enum {</p><p><code></code>MODE_BLEND = 0,</p><p><code></code>MODE_DARKEN = 1,</p><p><code></code>MODE_LIGHTEN = 2,</p><p><code></code>MODE_ADD = 3,</p><p><code></code>MODE_SOFTLIGHT = 4,</p><p><code></code>MODE_EXCLUSION = 5</p><p><code></code>};</p><p><code></code>int mode;</p><p><code></code>static const char_t *modes[];</p><p><code></code>int strength;</p><p><code></code>//创建Filter</p><p><code></code>virtual void createFilters(size_t filtersorder, Tfilters *filters, TfilterQueue &queue) const;</p><p><code></code>//创建属性页面</p><p><code></code>virtual void createPages(TffdshowPageDec *parent) const;</p><p><code></code>virtual bool getTip(unsigned int pageId, char_t *buf, size_t buflen);</p><p>};</p><p>#endif</p><p>再来看看TbitmapSettings.cpp</p><p>该类包含了TbitmapSettings类中函数方法的具体实现。首先看一下构造函数TbitmapSettings()。从构造函数中可以看出，绑定了类中的变量和注册表变量，使它们形成一一对应的关系。其他的函数就不再细说了，比较简单，理解起来比较容易。</p><p>#include "stdafx.h"</p><p>#include "TbitmapSettings.h"</p><p>#include "TimgFilterBitmap.h"</p><p>#include "Cbitmap.h"</p><p>#include "TffdshowPageDec.h"</p><p>#include "TsubtitlesSettings.h"</p><p>//几种叠加方式</p><p>const char_t* TbitmapSettings::modes[] = {</p><p><code></code>_l("blend"),</p><p><code></code>_l("darken"),</p><p><code></code>_l("lighten"),</p><p><code></code>_l("add"),</p><p><code></code>_l("softlight"),</p><p><code></code>_l("exclusion"),</p><p><code></code>NULL</p><p>};</p><p>//Filter属性</p><p>const TfilterIDFF TbitmapSettings::idffs = {</p><p><code></code>/*name*/ _l("Bitmap overlay"),</p><p><code></code>/*id*/ IDFF_filterBitmap,</p><p><code></code>/*is*/ IDFF_isBitmap,</p><p><code></code>/*order*/ IDFF_orderBitmap,</p><p><code></code>/*show*/ IDFF_showBitmap,</p><p><code></code>/*full*/ IDFF_fullBitmap,</p><p><code></code>/*half*/ 0,</p><p><code></code>/*dlgId*/ IDD_BITMAP,</p><p>};</p><p>//构造函数</p><p>TbitmapSettings::TbitmapSettings(TintStrColl *Icoll, TfilterIDFFs *filters): TfilterSettingsVideo(sizeof(*this), Icoll, filters, &idffs)</p><p>{</p><p><code></code>half = 0;</p><p><code></code>memset(flnm, 0, sizeof(flnm));</p><p><code></code>//绑定变量</p><p><code></code>static const TintOptionT<tbitmapsettings> iopts[] = {</p><p><code></code>IDFF_isBitmap , &TbitmapSettings::is , 0, 0, _l(""), 1,</p><p><code></code>_l("isBitmap"), 0,</p><p><code></code>IDFF_showBitmap , &TbitmapSettings::show , 0, 0, _l(""), 1,</p><p><code></code>_l("showBitmap"), 1,</p><p><code></code>IDFF_orderBitmap , &TbitmapSettings::order , 1, 1, _l(""), 1,</p><p><code></code>_l("orderBitmap"), 0,</p><p><code></code>IDFF_fullBitmap , &TbitmapSettings::full , 0, 0, _l(""), 1,</p><p><code></code>_l("fullBitmap"), 0,</p><p><code></code>IDFF_bitmapPosx , &TbitmapSettings::posx , -4096, 4096, _l(""), 1,</p><p><code></code>_l("bitmapPosX"), 50,</p><p><code></code>IDFF_bitmapPosy , &TbitmapSettings::posy , -4096, 4096, _l(""), 1,</p><p><code></code>_l("bitmapPosY"), 50,</p><p><code></code>IDFF_bitmapPosmode , &TbitmapSettings::posmode , 0, 1, _l(""), 1,</p><p><code></code>_l("bitmapPosMode"), 0,</p><p><code></code>IDFF_bitmapAlign , &TbitmapSettings::align , 0, 3, _l(""), 1,</p><p><code></code>_l("bitmapAlign"), ALIGN_CENTER,</p><p><code></code>IDFF_bitmapMode , &TbitmapSettings::mode , 0, 5, _l(""), 1,</p><p><code></code>_l("bitmapMode"), 0,</p><p><code></code>IDFF_bitmapStrength , &TbitmapSettings::strength , 0, 256, _l(""), 1,</p><p><code></code>_l("bitmapStrength"), 128,</p><p><code></code>0</p><p><code></code>};</p><p><code></code>addOptions(iopts);</p><p><code></code>static const TstrOption sopts[] = {</p><p><code></code>IDFF_bitmapFlnm , (TstrVal)&TbitmapSettings::flnm , MAX_PATH, 0, _l(""), 1,</p><p><code></code>_l("bitmapFlnm"), _l(""),</p><p><code></code>0</p><p><code></code>};</p><p><code></code>addOptions(sopts);</p><p><code></code>static const TcreateParamList1 listMode(modes);</p><p><code></code>setParamList(IDFF_bitmapMode, &listMode);</p><p><code></code>static const TcreateParamList1 listAlign(TsubtitlesSettings::alignments);</p><p><code></code>setParamList(IDFF_bitmapAlign, &listAlign);</p><p>}</p><p>//创建Filter</p><p>void TbitmapSettings::createFilters(size_t filtersorder, Tfilters *filters, TfilterQueue &queue) const</p><p>{</p><p><code></code>idffOnChange(idffs, filters, queue.temporary);</p><p><code></code>if (is && show) {</p><p><code></code>queueFilter<timgfilterbitmap>(filtersorder, filters, queue);</p><p><code></code>}</p><p>}</p><p>//创建属性页面</p><p>void TbitmapSettings::createPages(TffdshowPageDec *parent) const</p><p>{</p><p><code></code>parent->addFilterPage<tbitmappage>(&idffs);</p><p>}</p><p>const int* TbitmapSettings::getResets(unsigned int pageId)</p><p>{</p><p><code></code>static const int idResets[] = {</p><p><code></code>IDFF_bitmapPosx, IDFF_bitmapPosy, IDFF_bitmapPosmode, IDFF_bitmapAlign, IDFF_bitmapMode, IDFF_bitmapStrength,</p><p><code></code>0</p><p><code></code>};</p><p><code></code>return idResets;</p><p>}</p><p>bool TbitmapSettings::getTip(unsigned int pageId, char_t *tipS, size_t len)</p><p>{</p><p><code></code>if (flnm[0]) {</p><p><code></code>tsnprintf_s(tipS, len, _TRUNCATE, _l("%s %s"), modes[mode], flnm);</p><p><code></code>tipS[len - 1] = '\0';</p><p><code></code>} else {</p><p><code></code>tipS[0] = '\0';</p><p><code></code>}</p><p><code></code>return true;</p><p>}</p><h3 id=ffdshow-源代码分析-4-位图覆盖滤镜滤镜部分filterhttpblogcsdnnetleixiaohua1020articledetails13006213><a href=http://blog.csdn.net/leixiaohua1020/article/details/13006213><strong>ffdshow 源代码分析 4： 位图覆盖滤镜（滤镜部分Filter）</strong></a></h3><p>滤镜部分（Filter）</p><p>ffdshow的滤镜的滤镜部分（怎么感觉名字有点重复 = =，算了先这么叫吧）的功能主要用于完成具体的图像处理功能。具体到位图覆盖滤镜的话，就是用于把图片覆盖到视频上面，他是ffdshow滤镜的核心。</p><p>与位图覆盖（Bitmap）滤镜的滤镜处理有关的类位于imgFilters目录下的TimgFilterBitmap.h和TimgFilterBitmap.cpp文件中。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.149.jpeg alt></p><p>先来看看TimgFilterBitmap.h</p><p>这里要注意一下，该类的名字叫TimgFilterBitmap。它的声明方式确实比较奇怪：DECLARE_FILTER(TimgFilterBitmap, public, TimgFilter)</p><p>可以看出DECLARE_FILTER是一个宏，具体这个宏的内部代码就先不查看了，否则会感觉很混乱，暂且留下一个小小的谜团。在这里只要知道这是声明了一个滤镜类就可以了。</p><p>其实TimgFilterBitmap的核心函数不多，就一个，那就是process()，具体的处理功能都是在这个函数里面实现的。</p><p>#ifndef _TIMGFILTERBITMAP_H_</p><p>#define _TIMGFILTERBITMAP_H_</p><p>//叠加一张位图</p><p>#include "TimgFilter.h"</p><p>#include "Tfont.h"</p><p>struct TffPict;</p><p>struct TbitmapSettings;</p><p>//特别的声明方式 = =</p><p>DECLARE_FILTER(TimgFilterBitmap, public, TimgFilter)</p><p>private:</p><p>//图像</p><p>TffPict *bitmap;</p><p>//内存</p><p>Tbuffer bitmapbuf;</p><p>char_t oldflnm[MAX_PATH];</p><p>typedef void (*Tblendplane)(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>//注意 这个类有一个实例，名字叫w</p><p>class TrenderedSubtitleLineBitmap : public TrenderedSubtitleWordBase</p><p>{</p><p>public:</p><p><code></code>TrenderedSubtitleLineBitmap(void): TrenderedSubtitleWordBase(false) {}</p><p><code></code>TffPict *pict;</p><p><code></code>const TbitmapSettings *cfg;</p><p><code></code>//叠加</p><p><code></code>Tblendplane blend;</p><p><code></code>//打印</p><p><code></code>virtual void print(int startx, int starty /* not used */, unsigned int dx[3], int dy1[3], unsigned char *dstLn[3], const stride_t stride[3], const unsigned char *bmp[3], const unsigned char *msk[3], REFERENCE_TIME rtStart = REFTIME_INVALID) const;</p><p>} w;</p><p>TrenderedSubtitleLine l;</p><p>//是TrenderedSubtitleLine的一个vector</p><p>TrenderedSubtitleLines ls;</p><p>int oldmode;</p><p>//几种叠加方式</p><p>template&lt;class _mm> static void blend(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>template&lt;class _mm> static void add(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>template&lt;class _mm> static void darken(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>template&lt;class _mm> static void lighten(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>template&lt;class _mm> static void softlight(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>template&lt;class _mm> static void exclusion(const TcspInfo &cspInfo, const unsigned int dx[3], const unsigned int dy[3], unsigned char *dst[3], const stride_t dststride[3], const unsigned char *src[3], const stride_t srcstride[3], int strength, int invstrength);</p><p>//获取叠加方式</p><p>template&lt;class _mm> static Tblendplane getBlend(int mode);</p><p>protected:</p><p>virtual bool is(const TffPictBase &pict, const TfilterSettingsVideo *cfg);</p><p>virtual uint64_t getSupportedInputColorspaces(const TfilterSettingsVideo *cfg) const</p><p>{</p><p><code></code>return FF_CSPS_MASK_YUV_PLANAR;</p><p>}</p><p>public:</p><p>TimgFilterBitmap(IffdshowBase *Ideci, Tfilters *Iparent);</p><p>virtual ~TimgFilterBitmap();</p><p>//核心函数（Filter配置信息队列，图像，配置信息）</p><p>virtual HRESULT process(TfilterQueue::iterator it, TffPict &pict, const TfilterSettingsVideo *cfg0);</p><p>};</p><p>#endif</p><p>再来看看TimgFilterBitmap.cpp</p><p>这个文件本身代码量是比较大的，只是其他部分我都还没有仔细分析，确实没那没多时间。。。在这里仅简要分析一下最核心的函数process()。正是这个函数真正实现了滤镜的功能。在这个位图叠加滤镜中，process()实现了位图在视频上面的叠加功能。</p><p>//核心函数（Filter配置信息队列，图像，配置信息）</p><p>HRESULT TimgFilterBitmap::process(TfilterQueue::iterator it, TffPict &pict, const TfilterSettingsVideo *cfg0)</p><p>{</p><p><code></code>//都有这一句= =</p><p><code></code>if (is(pict, cfg0)) {</p><p><code></code>//Bitmap的配置信息</p><p><code></code>const TbitmapSettings *cfg = (const TbitmapSettings*)cfg0;</p><p><code></code>init(pict, cfg->full, cfg->half);</p><p><code></code>unsigned char *dst[4];</p><p><code></code>bool cspChanged = getCurNext(FF_CSPS_MASK_YUV_PLANAR, pict, cfg->full, COPYMODE_DEF, dst);</p><p><code></code>//处理</p><p><code></code>if (!bitmap || cspChanged || stricmp(oldflnm, cfg->flnm) != 0) {</p><p><code></code>ff_strncpy(oldflnm, cfg->flnm, countof(oldflnm));</p><p><code></code>if (bitmap) {</p><p><code></code>delete bitmap;</p><p><code></code>}</p><p><code></code>//新建一张图</p><p><code></code>//通过cfg->flnm路径</p><p><code></code>//载入bitmapbuf</p><p><code></code>bitmap = new TffPict(csp2, cfg->flnm, bitmapbuf, deci);</p><p><code></code>//3个颜色分量？</p><p><code></code>for (int i = 0; i &lt; 3; i++) {</p><p><code></code>w.dx[i] = bitmap->rectFull.dx >> bitmap->cspInfo.shiftX[i];</p><p><code></code>w.dy[i] = bitmap->rectFull.dy >> bitmap->cspInfo.shiftY[i];</p><p><code></code>w.bmp[i] = bitmap->data[i];</p><p><code></code>w.bmpmskstride[i] = bitmap->stride[i];</p><p><code></code>}</p><p><code></code>w.dxChar = w.dx[0];</p><p><code></code>w.dyChar = w.dy[0];</p><p><code></code>}</p><p><code></code>if (bitmap->rectFull.dx != 0) {</p><p><code></code>if (oldmode != cfg->mode)</p><p><code></code>if (Tconfig::cpu_flags & FF_CPU_SSE2) {</p><p><code></code>//获取叠加方式（SSE2）</p><p><code></code>//在cfg的mode里</p><p><code></code>w.blend = getBlend<tsse2>(oldmode = cfg->mode);</p><p><code></code>} else {</p><p><code></code>//获取叠加方式（MMX）</p><p><code></code>w.blend = getBlend<tmmx>(oldmode = cfg->mode);</p><p><code></code>}</p><p><code></code>//输出到屏幕上的设置</p><p><code></code>TprintPrefs prefs(deci, NULL);</p><p><code></code>//各种参数</p><p><code></code>prefs.dx = dx2[0];</p><p><code></code>prefs.dy = dy2[0];</p><p><code></code>prefs.xpos = cfg->posx;</p><p><code></code>prefs.ypos = cfg->posy;</p><p><code></code>//模式不同的话</p><p><code></code>if (cfg->posmode == 1) {</p><p><code></code>prefs.xpos *= -1;</p><p><code></code>prefs.ypos *= -1;</p><p><code></code>}</p><p><code></code>prefs.align = cfg->align;</p><p><code></code>prefs.linespacing = 100;</p><p><code></code>prefs.csp = pict.csp;</p><p><code></code>w.pict = &amp;pict;</p><p><code></code>w.cfg = cfg;</p><p><code></code>//打印，需要用到TprintPrefs</p><p><code></code>ls.print(prefs, dst, stride2);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//最后都是这一句？</p><p><code></code>return parent->processSample(++it, pict);</p><p>}</p><h3 id=ffdshow-源代码分析-5-位图覆盖滤镜总结httpblogcsdnnetleixiaohua1020articledetails13660583><a href=http://blog.csdn.net/leixiaohua1020/article/details/13660583><strong>ffdshow 源代码分析 5： 位图覆盖滤镜（总结）</strong></a></h3><p>用一张图总结他们之间的关系：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.150.jpeg alt></p><p>如图中所示，设置（Settings）部分是直接和系统上层关联的，它包含两个接口函数：createPages()和createFilters()。分别用于创建对话框（Dialog）和滤镜（Filter）。其中在TbitmapPage中对话框直接和注册表变量关联。而在TbitmapSettings中注册表变量和系统中的变量关联。TimgFilterBitmap最终读取TbitmapSettings中的变量完成相应的操作。</p><p>目前来开TimgFilterBitmap是不会直接读取TbitmapPage类中的值的。</p><h3 id=ffdshow-源代码分析-6-对解码器的dll的封装libavcodechttpblogcsdnnetleixiaohua1020articledetails15493329><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493329><strong>ffdshow 源代码分析 6： 对解码器的dll的封装（libavcodec）</strong></a></h3><p>ffdshow封装了多个视音频解码器，比如libmpeg2，libavcodec，xvid等等。其中最重要的是libavcodec，这个是ffmpeg提供的解码器，在ffdshow中起到了“挑大梁”的作用。本文分析ffdshow对解码器的封装方式，就以libavcodec为例。</p><p>在ffdshow中，libavcodec的被封装在ffmpeg.dll文件中，通过加载该dll中的函数，就可以使用libavcodec的各种方法。</p><p>Ffmpeg对libavcodec的封装类的定义位于codecs->libavcodec->Tlibavcodec.h。实现则位于codecs->libavcodec->Tlibavcodec.cpp。</p><p>先来看一看Tlibavcodec.h：</p><p>#ifndef _TLIBAVCODEC_H_</p><p>#define _TLIBAVCODEC_H_</p><p>//将FFmpeg的Dll中的方法封装到一个类中，以供使用</p><p>#include "../codecs/ffcodecs.h"</p><p>#include &lt;dxva.h></p><p>#include "TpostprocSettings.h"</p><p>#include "ffImgfmt.h"</p><p>#include "libavfilter/vf_yadif.h"</p><p>#include "libavfilter/gradfun.h"</p><p>#include "libswscale/swscale.h"</p><p>struct AVCodecContext;</p><p>struct AVCodec;</p><p>struct AVFrame;</p><p>struct AVPacket;</p><p>struct AVCodecParserContext;</p><p>struct SwsContext;</p><p>struct SwsParams;</p><p>struct PPMode;</p><p>struct AVDictionary;</p><p>struct Tconfig;</p><p>class Tdll;</p><p>struct DSPContext;</p><p>struct TlibavcodecExt;</p><p>//封装FFMPEG</p><p>//里面的函数基本上是FFMPEG的API</p><p>struct Tlibavcodec {</p><p>private:</p><p><code></code>int (*libswscale_sws_scale)(struct SwsContext *context, const uint8_t* const srcSlice[], const int srcStride[],</p><p><code></code>int srcSliceY, int srcSliceH, uint8_t* const dst[], const int dstStride[]);</p><p><code></code>//加载DLL的类</p><p><code></code>Tdll *dll;</p><p><code></code>int refcount;</p><p><code></code>static int get_buffer(AVCodecContext *c, AVFrame *pic);</p><p><code></code>CCritSec csOpenClose;</p><p>public:</p><p><code></code>Tlibavcodec(const Tconfig *config);</p><p><code></code>~Tlibavcodec();</p><p><code></code>static void avlog(AVCodecContext*, int, const char*, va_list);</p><p><code></code>static void avlogMsgBox(AVCodecContext*, int, const char*, va_list);</p><p><code></code>void AddRef(void) {</p><p><code></code>refcount++;</p><p><code></code>}</p><p><code></code>void Release(void) {</p><p><code></code>if (--refcount &lt; 0) {</p><p><code></code>delete this;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>static bool getVersion(const Tconfig *config, ffstring &vers, ffstring &license);</p><p><code></code>static bool check(const Tconfig *config);</p><p><code></code>static int ppCpuCaps(uint64_t csp);</p><p><code></code>static void pp_mode_defaults(PPMode &ppMode);</p><p><code></code>static int getPPmode(const TpostprocSettings *cfg, int currentq);</p><p><code></code>static void swsInitParams(SwsParams *params, int resizeMethod);</p><p><code></code>static void swsInitParams(SwsParams *params, int resizeMethod, int flags);</p><p><code></code>bool ok;</p><p><code></code>AVCodecContext* avcodec_alloc_context(AVCodec *codec, TlibavcodecExt *ext = NULL);</p><p><code></code>void (*avcodec_register_all)(void);</p><p><code></code>AVCodecContext* (*avcodec_alloc_context0)(AVCodec *codec);</p><p><code></code>AVCodec* (*avcodec_find_decoder)(AVCodecID codecId);</p><p><code></code>AVCodec* (*avcodec_find_encoder)(AVCodecID id);</p><p><code></code>int (*avcodec_open0)(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options);</p><p><code></code>int avcodec_open(AVCodecContext *avctx, AVCodec *codec);</p><p><code></code>AVFrame* (*avcodec_alloc_frame)(void);</p><p><code></code>int (*avcodec_decode_video2)(AVCodecContext *avctx, AVFrame *picture,</p><p><code></code>int *got_picture_ptr,</p><p><code></code>AVPacket *avpkt);</p><p><code></code>int (*avcodec_decode_audio3)(AVCodecContext *avctx, int16_t *samples,</p><p><code></code>int *frame_size_ptr,</p><p><code></code>AVPacket *avpkt);</p><p><code></code>int (*avcodec_encode_video)(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVFrame *pict);</p><p><code></code>int (*avcodec_encode_audio)(AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples);</p><p><code></code>void (*avcodec_flush_buffers)(AVCodecContext *avctx);</p><p><code></code>int (*avcodec_close0)(AVCodecContext *avctx);</p><p><code></code>int avcodec_close(AVCodecContext *avctx);</p><p><code></code>void (*av_log_set_callback)(void (*)(AVCodecContext*, int, const char*, va_list));</p><p><code></code>void* (*av_log_get_callback)(void);</p><p><code></code>int (*av_log_get_level)(void);</p><p><code></code>void (*av_log_set_level)(int);</p><p><code></code>void (*av_set_cpu_flags_mask)(int mask);</p><p><code></code>int (*avcodec_default_get_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>void (*avcodec_default_release_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>int (*avcodec_default_reget_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>const char* (*avcodec_get_current_idct)(AVCodecContext *avctx);</p><p><code></code>void (*avcodec_get_encoder_info)(AVCodecContext *avctx, int *xvid_build, int *divx_version, int *divx_build, int *lavc_build);</p><p><code></code>void* (*av_mallocz)(size_t size);</p><p><code></code>void (*av_free)(void *ptr);</p><p><code></code>AVCodecParserContext* (*av_parser_init)(int codec_id);</p><p><code></code>int (*av_parser_parse2)(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos);</p><p><code></code>void (*av_parser_close)(AVCodecParserContext *s);</p><p><code></code>void (*av_init_packet)(AVPacket *pkt);</p><p><code></code>uint8_t* (*av_packet_new_side_data)(AVPacket *pkt, enum AVPacketSideDataType type, int size);</p><p><code></code>int (*avcodec_h264_search_recovery_point)(AVCodecContext *avctx,</p><p><code></code>const uint8_t *buf, int buf_size, int *recovery_frame_cnt);</p><p><code></code>static const char_t *idctNames[], *errorRecognitions[], *errorConcealments[];</p><p><code></code>struct Tdia_size {</p><p><code></code>int size;</p><p><code></code>const char_t *descr;</p><p><code></code>};</p><p><code></code>static const Tdia_size dia_sizes[];</p><p><code></code>//libswscale imports</p><p><code></code>SwsContext* (*sws_getCachedContext)(struct SwsContext *context, int srcW, int srcH, enum PixelFormat srcFormat,</p><p><code></code>int dstW, int dstH, enum PixelFormat dstFormat, int flags,</p><p><code></code>SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param, SwsParams *ffdshow_params);</p><p><code></code>void (*sws_freeContext)(SwsContext *c);</p><p><code></code>SwsFilter* (*sws_getDefaultFilter)(float lumaGBlur, float chromaGBlur,</p><p><code></code>float lumaSharpen, float chromaSharpen,</p><p><code></code>float chromaHShift, float chromaVShift,</p><p><code></code>int verbose);</p><p><code></code>void (*sws_freeFilter)(SwsFilter *filter);</p><p><code></code>int sws_scale(struct SwsContext *context, const uint8_t* const srcSlice[], const stride_t srcStride[],</p><p><code></code>int srcSliceY, int srcSliceH, uint8_t* const dst[], const stride_t dstStride[]);</p><p><code></code>SwsVector *(*sws_getConstVec)(double c, int length);</p><p><code></code>SwsVector *(*sws_getGaussianVec)(double variance, double quality);</p><p><code></code>void (*sws_normalizeVec)(SwsVector *a, double height);</p><p><code></code>void (*sws_freeVec)(SwsVector *a);</p><p><code></code>int (*sws_setColorspaceDetails)(struct SwsContext *c, const int inv_table[4],</p><p><code></code>int srcRange, const int table[4], int dstRange,</p><p><code></code>int brightness, int contrast, int saturation);</p><p><code></code>const int* (*sws_getCoefficients)(int colorspace);</p><p><code></code>int (*GetCPUCount)(void);</p><p><code></code>//libpostproc imports</p><p><code></code>void (*pp_postprocess)(const uint8_t * src[3], const stride_t srcStride[3],</p><p><code></code>uint8_t * dst[3], const stride_t dstStride[3],</p><p><code></code>int horizontalSize, int verticalSize,</p><p><code></code>const /*QP_STORE_T*/int8_t *QP_store, int QP_stride,</p><p><code></code>/*pp_mode*/void *mode, /*pp_context*/void *ppContext, int pict_type);</p><p><code></code>/*pp_context*/</p><p><code></code>void *(*pp_get_context)(int width, int height, int flags);</p><p><code></code>void (*pp_free_context)(/*pp_context*/void *ppContext);</p><p><code></code>void (*ff_simple_idct_mmx)(int16_t *block);</p><p><code></code>// DXVA imports</p><p><code></code>int (*av_h264_decode_frame)(struct AVCodecContext* avctx, uint8_t *buf, int buf_size);</p><p><code></code>int (*av_vc1_decode_frame)(struct AVCodecContext* avctx, uint8_t *buf, int buf_size);</p><p><code></code>// === H264 functions</p><p><code></code>int (*FFH264CheckCompatibility)(int nWidth, int nHeight, struct AVCodecContext* pAVCtx, BYTE* pBuffer, UINT nSize, int nPCIVendor, int nPCIDevice, LARGE_INTEGER VideoDriverVersion);</p><p><code></code>int (*FFH264DecodeBuffer)(struct AVCodecContext* pAVCtx, BYTE* pBuffer, UINT nSize, int* pFramePOC, int* pOutPOC, REFERENCE_TIME* pOutrtStart);</p><p><code></code>HRESULT(*FFH264BuildPicParams)(DXVA_PicParams_H264* pDXVAPicParams, DXVA_Qmatrix_H264* pDXVAScalingMatrix, int* nFieldType, int* nSliceType, struct AVCodecContext* pAVCtx, int nPCIVendor);</p><p><code></code>void (*FFH264SetCurrentPicture)(int nIndex, DXVA_PicParams_H264* pDXVAPicParams, struct AVCodecContext* pAVCtx);</p><p><code></code>void (*FFH264UpdateRefFramesList)(DXVA_PicParams_H264* pDXVAPicParams, struct AVCodecContext* pAVCtx);</p><p><code></code>BOOL (*FFH264IsRefFrameInUse)(int nFrameNum, struct AVCodecContext* pAVCtx);</p><p><code></code>void (*FF264UpdateRefFrameSliceLong)(DXVA_PicParams_H264* pDXVAPicParams, DXVA_Slice_H264_Long* pSlice, struct AVCodecContext* pAVCtx);</p><p><code></code>void (*FFH264SetDxvaSliceLong)(struct AVCodecContext* pAVCtx, void* pSliceLong);</p><p><code></code>// === VC1 functions</p><p><code></code>HRESULT(*FFVC1UpdatePictureParam)(DXVA_PictureParameters* pPicParams, struct AVCodecContext* pAVCtx, int* nFieldType, int* nSliceType, BYTE* pBuffer, UINT nSize, UINT* nFrameSize, BOOL b_SecondField, BOOL* b_repeat_pict);</p><p><code></code>int (*FFIsSkipped)(struct AVCodecContext* pAVCtx);</p><p><code></code>// === Common functions</p><p><code></code>char* (*GetFFMpegPictureType)(int nType);</p><p><code></code>unsigned long(*FFGetMBNumber)(struct AVCodecContext* pAVCtx);</p><p><code></code>// yadif</p><p><code></code>void (*yadif_init)(YADIFContext *yadctx);</p><p><code></code>void (*yadif_uninit)(YADIFContext *yadctx);</p><p><code></code>void (*yadif_filter)(YADIFContext *yadctx, uint8_t *dst[3], stride_t dst_stride[3], int width, int height, int parity, int tff);</p><p><code></code>// gradfun</p><p><code></code>int (*gradfunInit)(GradFunContext *ctx, const char *args, void *opaque);</p><p><code></code>void (*gradfunFilter)(GradFunContext *ctx, uint8_t *dst, uint8_t *src, int width, int height, int dst_linesize, int src_linesize, int r);</p><p>};</p><p>#endif</p><p>从Tlibavcodec定义可以看出，里面包含了大量的ffmpeg中的API，占据了很大的篇幅。通过调用这些API，就可以使用livavcodec的各种功能。</p><p>在Tlibavcodec的定义中，有一个变量：Tdll *dll，通过该变量，就可以加载ffmpeg.dll中的方法。</p><p>先来看一下Tdll的定义：</p><p><code></code>#ifndef _TDLL_H_</p><p>#define _TDLL_H_</p><p>#include "Tconfig.h"</p><p>//操作Dll的类</p><p>class Tdll</p><p>{</p><p>public:</p><p><code></code>bool ok;</p><p><code></code>Tdll(const char_t *dllName1, const Tconfig *config, bool explicitFullPath = false) {</p><p><code></code>char_t name[MAX_PATH], ext[MAX_PATH];</p><p><code></code>_splitpath_s(dllName1, NULL, 0, NULL, 0, name, countof(name), ext, countof(ext));</p><p><code></code>if (config && !explicitFullPath) {</p><p><code></code>char_t dllName2[MAX_PATH]; //installdir+filename+ext</p><p><code></code>_makepath_s(dllName2, countof(dllName2), NULL, config->pth, name, ext);</p><p><code></code>hdll = LoadLibrary(dllName2);</p><p><code></code>} else {</p><p><code></code>hdll = NULL;</p><p><code></code>}</p><p><code></code>if (!hdll) {</p><p><code></code>hdll = LoadLibrary(dllName1);</p><p><code></code>if (!hdll && !explicitFullPath) {</p><p><code></code>if (config) {</p><p><code></code>char_t dllName3[MAX_PATH]; //ffdshow.ax_path+filename+ext</p><p><code></code>_makepath_s(dllName3, countof(dllName3), NULL, config->epth, name, ext);</p><p><code></code>hdll = LoadLibrary(dllName3);</p><p><code></code>}</p><p><code></code>if (!hdll) {</p><p><code></code>char_t dllName0[MAX_PATH]; //only filename+ext - let Windows find it</p><p><code></code>_makepath_s(dllName0, countof(dllName0), NULL, NULL, name, ext);</p><p><code></code>hdll = LoadLibrary(dllName0);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>ok = (hdll != NULL);</p><p><code></code>}</p><p><code></code>~Tdll() {</p><p><code></code>if (hdll) {</p><p><code></code>FreeLibrary(hdll);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>HMODULE hdll;</p><p><code></code>//封装一下直接加载Dll的GetProcAddress</p><p><code></code>template<class t> __forceinline void loadFunction(T &fnc, const char *name) {</p><p><code></code>fnc = hdll ? (T)GetProcAddress(hdll, name) : NULL;</p><p><code></code>ok &= (fnc != NULL);</p><p><code></code>}</p><p><code></code>template<class t> __forceinline void loadFunctionByIndex(T &fnc, uint16_t id) {</p><p><code></code>uint32_t id32 = uint32_t(id);</p><p><code></code>fnc = hdll ?</p><p><code></code>(T) GetProcAddress(hdll, (LPCSTR)id32) :</p><p><code></code>NULL;</p><p><code></code>ok &= (fnc != NULL);</p><p><code></code>}</p><p><code></code>//检查Dll的状态是否正常</p><p><code></code>static bool check(const char_t *dllName1, const Tconfig *config) {</p><p><code></code>char_t name[MAX_PATH], ext[MAX_PATH];</p><p><code></code>_splitpath_s(dllName1, NULL, 0, NULL, 0, name, countof(name), ext, countof(ext));</p><p><code></code>if (config) {</p><p><code></code>char_t dllName2[MAX_PATH]; //installdir+filename+ext</p><p><code></code>_makepath_s(dllName2, countof(dllName2), NULL, config->pth, name, ext);</p><p><code></code>if (fileexists(dllName2)) {</p><p><code></code>return true;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (fileexists(dllName1)) {</p><p><code></code>return true;</p><p><code></code>}</p><p><code></code>if (config) {</p><p><code></code>char_t dllName3[MAX_PATH]; //ffdshow.ax_path+filename+ext</p><p><code></code>_makepath_s(dllName3, MAX_PATH, NULL, config->epth, name, ext);</p><p><code></code>if (fileexists(dllName3)) {</p><p><code></code>return true;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>char_t dllName0[MAX_PATH]; //only filename+ext - let Windows find it</p><p><code></code>_makepath_s(dllName0, countof(dllName0), NULL, NULL, name, ext);</p><p><code></code>char_t dir0[MAX_PATH], *dir0flnm;</p><p><code></code>if (SearchPath(NULL, dllName0, NULL, MAX_PATH, dir0, &dir0flnm)) {</p><p><code></code>return true;</p><p><code></code>}</p><p><code></code>return false;</p><p><code></code>}</p><p>};</p><p>#endif</p><p>从Tdll的定义可以看出，该类的loadFunction()函数封装了系统使用Dll功能的函数GetProcAddress()。</p><p>该类的构造函数Tdll()封装了系统加载Dll的函数LoadLibrary()。</p><p>此外该类还提供了check()用于检查Dll。</p><p>对于Tdll的分析先告一段落，现在我们回到Tlibavcodec，来看看它是如何加载libavcodec的函数的。查看一下Tlibavcodec的类的实现，位于codecs->libavcodec->Tlibavcodec.cpp。</p><p>该类的实现代码比较长，因此只能选择重要的函数查看一下。首先来看一下构造函数：</p><p>//===================================== Tlibavcodec ====================================</p><p>//FFMPEG封装类的构造函数</p><p>Tlibavcodec::Tlibavcodec(const Tconfig *config): refcount(0)</p><p>{</p><p><code></code>//加载FFMPEG的Dll</p><p><code></code>dll = new Tdll(_l("ffmpeg.dll"), config);</p><p><code></code>//加载各个函数</p><p><code></code>dll->loadFunction(avcodec_register_all, "avcodec_register_all");</p><p><code></code>dll->loadFunction(avcodec_find_decoder, "avcodec_find_decoder");</p><p><code></code>dll->loadFunction(avcodec_open0, "avcodec_open2");</p><p><code></code>dll->loadFunction(avcodec_alloc_context0, "avcodec_alloc_context3");</p><p><code></code>dll->loadFunction(avcodec_alloc_frame, "avcodec_alloc_frame");</p><p><code></code>dll->loadFunction(avcodec_decode_video2, "avcodec_decode_video2");</p><p><code></code>dll->loadFunction(avcodec_flush_buffers, "avcodec_flush_buffers");</p><p><code></code>dll->loadFunction(avcodec_close0, "avcodec_close");</p><p><code></code>dll->loadFunction(av_log_set_callback, "av_log_set_callback");</p><p><code></code>dll->loadFunction(av_log_get_callback, "av_log_get_callback");</p><p><code></code>dll->loadFunction(av_log_get_level, "av_log_get_level");</p><p><code></code>dll->loadFunction(av_log_set_level, "av_log_set_level");</p><p><code></code>dll->loadFunction(av_set_cpu_flags_mask, "av_set_cpu_flags_mask");</p><p><code></code>dll->loadFunction(av_mallocz, "av_mallocz");</p><p><code></code>dll->loadFunction(av_free, "av_free");</p><p><code></code>dll->loadFunction(avcodec_default_get_buffer, "avcodec_default_get_buffer");</p><p><code></code>dll->loadFunction(avcodec_default_release_buffer, "avcodec_default_release_buffer");</p><p><code></code>dll->loadFunction(avcodec_default_reget_buffer, "avcodec_default_reget_buffer");</p><p><code></code>dll->loadFunction(avcodec_get_current_idct, "avcodec_get_current_idct");</p><p><code></code>dll->loadFunction(avcodec_get_encoder_info, "avcodec_get_encoder_info");</p><p><code></code>dll->loadFunction(av_init_packet, "av_init_packet");</p><p><code></code>dll->loadFunction(av_packet_new_side_data, "av_packet_new_side_data");</p><p><code></code>dll->loadFunction(avcodec_h264_search_recovery_point, "avcodec_h264_search_recovery_point");</p><p><code></code>dll->loadFunction(avcodec_decode_audio3, "avcodec_decode_audio3");</p><p><code></code>dll->loadFunction(avcodec_find_encoder, "avcodec_find_encoder");</p><p><code></code>dll->loadFunction(avcodec_encode_video, "avcodec_encode_video");</p><p><code></code>dll->loadFunction(avcodec_encode_audio, "avcodec_encode_audio");</p><p><code></code>dll->loadFunction(av_parser_init, "av_parser_init");</p><p><code></code>dll->loadFunction(av_parser_parse2, "av_parser_parse2");</p><p><code></code>dll->loadFunction(av_parser_close, "av_parser_close");</p><p><code></code>//libswscale methods</p><p><code></code>dll->loadFunction(sws_getCachedContext, "sws_getCachedContext");</p><p><code></code>dll->loadFunction(sws_freeContext, "sws_freeContext");</p><p><code></code>dll->loadFunction(sws_getDefaultFilter, "sws_getDefaultFilter");</p><p><code></code>dll->loadFunction(sws_freeFilter, "sws_freeFilter");</p><p><code></code>dll->loadFunction(libswscale_sws_scale, "sws_scale");</p><p><code></code>dll->loadFunction(GetCPUCount, "GetCPUCount");</p><p><code></code>dll->loadFunction(sws_getConstVec, "sws_getConstVec");</p><p><code></code>dll->loadFunction(sws_getGaussianVec, "sws_getGaussianVec");</p><p><code></code>dll->loadFunction(sws_normalizeVec, "sws_normalizeVec");</p><p><code></code>dll->loadFunction(sws_freeVec, "sws_freeVec");</p><p><code></code>dll->loadFunction(sws_setColorspaceDetails, "sws_setColorspaceDetails");</p><p><code></code>dll->loadFunction(sws_getCoefficients, "sws_getCoefficients");</p><p><code></code>//libpostproc methods</p><p><code></code>dll->loadFunction(pp_postprocess, "pp_postprocess");</p><p><code></code>dll->loadFunction(pp_get_context, "pp_get_context");</p><p><code></code>dll->loadFunction(pp_free_context, "pp_free_context");</p><p><code></code>dll->loadFunction(ff_simple_idct_mmx, "ff_simple_idct_mmx");</p><p><code></code>//DXVA methods</p><p><code></code>dll->loadFunction(av_h264_decode_frame, "av_h264_decode_frame");</p><p><code></code>dll->loadFunction(av_vc1_decode_frame, "av_vc1_decode_frame");</p><p><code></code>dll->loadFunction(FFH264CheckCompatibility, "FFH264CheckCompatibility");</p><p><code></code>dll->loadFunction(FFH264DecodeBuffer, "FFH264DecodeBuffer");</p><p><code></code>dll->loadFunction(FFH264BuildPicParams, "FFH264BuildPicParams");</p><p><code></code>dll->loadFunction(FFH264SetCurrentPicture, "FFH264SetCurrentPicture");</p><p><code></code>dll->loadFunction(FFH264UpdateRefFramesList, "FFH264UpdateRefFramesList");</p><p><code></code>dll->loadFunction(FFH264IsRefFrameInUse, "FFH264IsRefFrameInUse");</p><p><code></code>dll->loadFunction(FF264UpdateRefFrameSliceLong, "FF264UpdateRefFrameSliceLong");</p><p><code></code>dll->loadFunction(FFH264SetDxvaSliceLong, "FFH264SetDxvaSliceLong");</p><p><code></code>dll->loadFunction(FFVC1UpdatePictureParam, "FFVC1UpdatePictureParam");</p><p><code></code>dll->loadFunction(FFIsSkipped, "FFIsSkipped");</p><p><code></code>dll->loadFunction(GetFFMpegPictureType, "GetFFMpegPictureType");</p><p><code></code>dll->loadFunction(FFGetMBNumber, "FFGetMBNumber");</p><p><code></code>//yadif methods</p><p><code></code>dll->loadFunction(yadif_init, "yadif_init");</p><p><code></code>dll->loadFunction(yadif_uninit, "yadif_uninit");</p><p><code></code>dll->loadFunction(yadif_filter, "yadif_filter");</p><p><code></code>//gradfun</p><p><code></code>dll->loadFunction(gradfunInit, "gradfunInit");</p><p><code></code>dll->loadFunction(gradfunFilter, "gradfunFilter");</p><p><code></code>ok = dll->ok;</p><p><code></code>//加载完毕后，进行注册</p><p><code></code>if (ok) {</p><p><code></code>avcodec_register_all();</p><p><code></code>av_log_set_callback(avlog);</p><p><code></code>}</p><p>}</p><p>该构造函数尽管篇幅比较长，但是还是比较好理解的，主要完成了3步：</p><p>\1. 创建一个Tdll类的对象，加载“ffmpeg.dll”。</p><p>\2. 使用loadFunction()加载各种函数。</p><p>\3. 最后调用avcodec_register_all()注册各种解码器。</p><p>Tlibavcodec的析构函数则比较简单：</p><p>Tlibavcodec::~Tlibavcodec()</p><p>{</p><p><code></code>delete dll;</p><p>}</p><p>检查Dll的函数也比较简单：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493329#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493329#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>bool Tlibavcodec::check(const Tconfig *config)</p><p>{</p><p><code></code>return Tdll::check(_l("ffmpeg.dll"), config);</p><p>}</p><p>此外，可能是出于某些功能的考虑，ffdshow还自己写了几个函数，但是限于篇幅不能一一介绍，在这里只介绍一个：</p><p>获取libavcodec版本：</p><p>bool Tlibavcodec::getVersion(const Tconfig *config, ffstring &vers, ffstring &license)</p><p>{</p><p><code></code>Tdll *dl = new Tdll(_l("ffmpeg.dll"), config);</p><p><code></code>void (*av_getVersion)(char **version, char **build, char **datetime, const char* *license);</p><p><code></code>dl->loadFunction(av_getVersion, "getVersion");</p><p><code></code>bool res;</p><p><code></code>if (av_getVersion) {</p><p><code></code>res = true;</p><p><code></code>char *version, *build, *datetime;</p><p><code></code>const char *lic;</p><p><code></code>av_getVersion(&version, &build, &datetime, &lic);</p><p><code></code>vers = (const char_t*)text&lt;char_t>(version) + ffstring(_l(" (")) + (const char_t*)text&lt;char_t>(datetime) + _l(")");</p><p><code></code>license = text&lt;char_t>(lic);</p><p><code></code>} else {</p><p><code></code>res = false;</p><p><code></code>vers.clear();</p><p><code></code>license.clear();</p><p><code></code>}</p><p><code></code>delete dl;</p><p><code></code>return res;</p><p>}</p><p><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493521>ffdshow 源代码分析 7： libavcodec视频解码器类（TvideoCodecLibavcodec）</a></p><p>在这里我们进一步介绍一下其libavcodec解码器类。注意前一篇文章介绍的类Tlibavcodec仅仅是对libavcodec所在的“ffmpeg.dll”的函数进行封装的类。但Tlibavcodec并不是一个解码器类，其没有继承任何类，还不能为ffdshow所用。本文介绍的TvideoCodecLibavcodec才是libavcodec解码器类，其继承了TvideoCodecDec。</p><p>先来看一看TvideoCodecLibavcodec的定义吧，位于codecs-> TvideoCodecLibavcodec.h中。</p><p>#ifndef _TVIDEOCODECLIBAVCODEC_H_</p><p>#define _TVIDEOCODECLIBAVCODEC_H_</p><p>#include "TvideoCodec.h"</p><p>#include "ffmpeg/Tlibavcodec.h"</p><p>#include "ffmpeg/libavcodec/avcodec.h"</p><p>#define MAX_THREADS 8 // FIXME: This is defined in mpegvideo.h.</p><p>struct Textradata;</p><p>class TccDecoder;</p><p>//libavcodec解码器（视频）</p><p>struct TlibavcodecExt {</p><p>private:</p><p><code></code>static int get_buffer(AVCodecContext *s, AVFrame *pic);</p><p><code></code>int (*default_get_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>static void release_buffer(AVCodecContext *s, AVFrame *pic);</p><p><code></code>void (*default_release_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>static int reget_buffer(AVCodecContext *s, AVFrame *pic);</p><p><code></code>int (*default_reget_buffer)(AVCodecContext *s, AVFrame *pic);</p><p><code></code>static void handle_user_data0(AVCodecContext *c, const uint8_t *buf, int buf_len);</p><p>public:</p><p><code></code>virtual ~TlibavcodecExt() {}</p><p><code></code>void connectTo(AVCodecContext *ctx, Tlibavcodec *libavcodec);</p><p><code></code>virtual void onGetBuffer(AVFrame *pic) {}</p><p><code></code>virtual void onRegetBuffer(AVFrame *pic) {}</p><p><code></code>virtual void onReleaseBuffer(AVFrame *pic) {}</p><p><code></code>virtual void handle_user_data(const uint8_t *buf, int buf_len) {}</p><p>};</p><p>//libavcodec解码，不算是Filter？</p><p>class TvideoCodecLibavcodec : public TvideoCodecDec, public TvideoCodecEnc, public TlibavcodecExt</p><p>{</p><p><code></code>friend class TDXVADecoderVC1;</p><p><code></code>friend class TDXVADecoderH264;</p><p>protected:</p><p><code></code>//各种信息（源自AVCodecContext中）</p><p><code></code>Tlibavcodec *libavcodec;</p><p><code></code>void create(void);</p><p><code></code>AVCodec *avcodec;</p><p><code></code>mutable char_t codecName[100];</p><p><code></code>AVCodecContext *avctx;</p><p><code></code>uint32_t palette[AVPALETTE_COUNT];</p><p><code></code>int palette_size;</p><p><code></code>AVFrame *frame;</p><p><code></code>FOURCC fcc;</p><p><code></code>FILE *statsfile;</p><p><code></code>int cfgcomode;</p><p><code></code>int psnr;</p><p><code></code>bool isAdaptive;</p><p><code></code>int threadcount;</p><p><code></code>bool dont_use_rtStop_from_upper_stream; // and reordering of timpestams is justified.</p><p><code></code>bool theorart;</p><p><code></code>bool codecinited, ownmatrices;</p><p><code></code>REFERENCE_TIME rtStart, rtStop, avgTimePerFrame, segmentTimeStart;</p><p><code></code>REFERENCE_TIME prior_in_rtStart, prior_in_rtStop;</p><p><code></code>REFERENCE_TIME prior_out_rtStart, prior_out_rtStop;</p><p><code></code>struct {</p><p><code></code>REFERENCE_TIME rtStart, rtStop;</p><p><code></code>unsigned int srcSize;</p><p><code></code>} b[MAX_THREADS + 1];</p><p><code></code>int inPosB;</p><p><code></code>Textradata *extradata;</p><p><code></code>bool sendextradata;</p><p><code></code>unsigned int mb_width, mb_height, mb_count;</p><p><code></code>static void line(unsigned char *dst, unsigned int _x0, unsigned int _y0, unsigned int _x1, unsigned int _y1, stride_t strideY);</p><p><code></code>static void draw_arrow(uint8_t *buf, int sx, int sy, int ex, int ey, stride_t stride, int mulx, int muly, int dstdx, int dstdy);</p><p><code></code>unsigned char *ffbuf;</p><p><code></code>unsigned int ffbuflen;</p><p><code></code>bool wasKey;</p><p><code></code>virtual void handle_user_data(const uint8_t *buf, int buf_len);</p><p><code></code>TccDecoder *ccDecoder;</p><p><code></code>bool autoSkipingLoopFilter;</p><p><code></code>enum AVDiscard initialSkipLoopFilter;</p><p><code></code>int got_picture;</p><p><code></code>bool firstSeek; // firstSeek means start of palyback.</p><p><code></code>bool mpeg2_in_doubt;</p><p><code></code>bool mpeg2_new_sequence;</p><p><code></code>bool bReorderBFrame;</p><p><code></code>//时长（AVCodecContext中）</p><p><code></code>REFERENCE_TIME getDuration();</p><p><code></code>int isReallyMPEG2(const unsigned char *src, size_t srcLen);</p><p>protected:</p><p><code></code>virtual LRESULT beginCompress(int cfgcomode, uint64_t csp, const Trect &r);</p><p><code></code>virtual bool beginDecompress(TffPictBase &pict, FOURCC infcc, const CMediaType &mt, int sourceFlags);</p><p><code></code>virtual HRESULT flushDec(void);</p><p><code></code>AVCodecParserContext *parser;</p><p>public:</p><p><code></code>TvideoCodecLibavcodec(IffdshowBase *Ideci, IdecVideoSink *IsinkD);</p><p><code></code>TvideoCodecLibavcodec(IffdshowBase *Ideci, IencVideoSink *IsinkE);</p><p><code></code>virtual ~TvideoCodecLibavcodec();</p><p><code></code>virtual int getType(void) const {</p><p><code></code>return IDFF_MOVIE_LAVC;</p><p><code></code>}</p><p><code></code>virtual const char_t* getName(void) const;</p><p><code></code>virtual int caps(void) const {</p><p><code></code>return CAPS::VIS_MV | CAPS::VIS_QUANTS;</p><p><code></code>}</p><p><code></code>virtual void end(void);</p><p><code></code>virtual void getCompressColorspaces(Tcsps &csps, unsigned int outDx, unsigned int outDy);</p><p><code></code>virtual bool supExtradata(void);</p><p><code></code>//获得ExtraData（AVCodecContext中）</p><p><code></code>virtual bool getExtradata(const void* *ptr, size_t *len);</p><p><code></code>virtual HRESULT compress(const TffPict &pict, TencFrameParams ¶ms);</p><p><code></code>virtual HRESULT flushEnc(const TffPict &pict, TencFrameParams ¶ms) {</p><p><code></code>return compress(pict, params);</p><p><code></code>}</p><p><code></code>virtual HRESULT decompress(const unsigned char *src, size_t srcLen, IMediaSample *pIn);</p><p><code></code>virtual void onGetBuffer(AVFrame *pic);</p><p><code></code>virtual bool onSeek(REFERENCE_TIME segmentStart);</p><p><code></code>virtual bool onDiscontinuity(void);</p><p><code></code>//画出运动矢量（AVCodecContext中）</p><p><code></code>virtual bool drawMV(unsigned char *dst, unsigned int dx, stride_t stride, unsigned int dy) const;</p><p><code></code>//编码器信息（AVCodecContext中）</p><p><code></code>virtual void getEncoderInfo(char_t *buf, size_t buflen) const;</p><p><code></code>virtual const char* get_current_idct(void);</p><p><code></code>virtual HRESULT BeginFlush();</p><p><code></code>bool isReorderBFrame() {</p><p><code></code>return bReorderBFrame;</p><p><code></code>};</p><p><code></code>virtual void reorderBFrames(REFERENCE_TIME& rtStart, REFERENCE_TIME& rtStop);</p><p><code></code>class Th264RandomAccess</p><p><code></code>{</p><p><code></code>friend class TvideoCodecLibavcodec;</p><p><code></code>private:</p><p><code></code>TvideoCodecLibavcodec* parent;</p><p><code></code>int recovery_mode; // 0:OK, 1:searching 2: found, 3:waiting for frame_num decoded, 4:waiting for POC outputed</p><p><code></code>int recovery_frame_cnt;</p><p><code></code>int recovery_poc;</p><p><code></code>int thread_delay;</p><p><code></code>public:</p><p><code></code>Th264RandomAccess(TvideoCodecLibavcodec* Iparent);</p><p><code></code>int search(uint8_t* buf, int buf_size);</p><p><code></code>void onSeek(void);</p><p><code></code>void judgeUsability(int *got_picture_ptr);</p><p><code></code>} h264RandomAccess;</p><p>};</p><p>#endif</p><p>这里有一个类TlibavcodecExt，我觉得应该是扩展了Tlibavcodec的一些功能，在这里我们先不管它，直接看看TvideoCodecLibavcodec都包含了什么变量：</p><p>Tlibavcodec *libavcodec：该类封装了libavcodec的各种函数，在前一篇文章中已经做过介绍，在此不再重复叙述了。可以认为该变量是TvideoCodecLibavcodec类的灵魂，所有libavcodec中的函数都是通过该类调用的。</p><p>AVCodec *avcodec：FFMPEG中的结构体，解码器</p><p>AVCodecContext *avctx：FFMPEG中的结构体，解码器上下文</p><p>AVFrame *frame FFMPEG中的结构体，视频帧</p><p>mutable char_t codecName[100]：解码器名称</p><p>FOURCC fcc：FourCC</p><p>Textradata *extradata：附加数据</p><p>…</p><p>再来看一下TvideoCodecLibavcodec都包含什么方法：</p><p>create()：创建解码器的时候调用</p><p>getDuration()：获得时长</p><p>getExtradata()：获得附加数据</p><p>drawMV()：画运动矢量</p><p>getEncoderInfo()：获得编码器信息</p><p>此外还包括一些有关解码的方法【这个是最关键的】：</p><p>beginDecompress()：解码初始化</p><p>decompress()：解码</p><p>下面我们来详细看看这些函数的实现吧：</p><p>先来看一下TvideoCodecLibavcodec的构造函数：</p><p>//libavcodec解码器（视频）</p><p>//内容大部分都很熟悉，因为是FFmpeg的API</p><p>TvideoCodecLibavcodec::TvideoCodecLibavcodec(IffdshowBase *Ideci, IdecVideoSink *IsinkD):</p><p><code></code>Tcodec(Ideci), TcodecDec(Ideci, IsinkD),</p><p><code></code>TvideoCodec(Ideci),</p><p><code></code>TvideoCodecDec(Ideci, IsinkD),</p><p><code></code>TvideoCodecEnc(Ideci, NULL),</p><p><code></code>h264RandomAccess(this),</p><p><code></code>bReorderBFrame(true)</p><p>{</p><p><code></code>create();</p><p>}</p><p>可见构造函数调用了Create()，我们再来看看Create()：</p><p>void TvideoCodecLibavcodec::create(void)</p><p>{</p><p><code></code>ownmatrices = false;</p><p><code></code>deci->getLibavcodec(&libavcodec);</p><p><code></code>ok = libavcodec ? libavcodec->ok : false;</p><p><code></code>avctx = NULL;</p><p><code></code>avcodec = NULL;</p><p><code></code>frame = NULL;</p><p><code></code>quantBytes = 1;</p><p><code></code>statsfile = NULL;</p><p><code></code>threadcount = 0;</p><p><code></code>codecinited = false;</p><p><code></code>extradata = NULL;</p><p><code></code>theorart = false;</p><p><code></code>ffbuf = NULL;</p><p><code></code>ffbuflen = 0;</p><p><code></code>codecName[0] = '\0';</p><p><code></code>ccDecoder = NULL;</p><p><code></code>autoSkipingLoopFilter = false;</p><p><code></code>inPosB = 1;</p><p><code></code>firstSeek = true;</p><p><code></code>mpeg2_new_sequence = true;</p><p><code></code>parser = NULL;</p><p>}</p><p>从Create()函数我们可以看出，其完成了各种变量的初始化工作。其中有一行代码：</p><p>deci->getLibavcodec(&libavcodec);</p><p>完成了Tlibavcodec*libavcodec的初始化工作。</p><p>再来看几个函数。</p><p>getDuration()，用于从AVCodecContext中获取时长：</p><p>REFERENCE_TIME TvideoCodecLibavcodec::getDuration()</p><p>{</p><p><code></code>REFERENCE_TIME duration = REF_SECOND_MULT / 100;</p><p><code></code>if (avctx && avctx->time_base.num && avctx->time_base.den) {</p><p><code></code>duration = REF_SECOND_MULT * avctx->time_base.num / avctx->time_base.den;</p><p><code></code>if (codecId == AV_CODEC_ID_H264) {</p><p><code></code>duration *= 2;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (duration == 0) {</p><p><code></code>return REF_SECOND_MULT / 100;</p><p><code></code>}</p><p><code></code>return duration;</p><p>}</p><p>getExtradata()用于从AVCodecContext中获取附加信息：</p><p>bool TvideoCodecLibavcodec::getExtradata(const void* *ptr, size_t *len)</p><p>{</p><p><code></code>if (!avctx || !len) {</p><p><code></code>return false;</p><p><code></code>}</p><p><code></code>*len = avctx->extradata_size;</p><p><code></code>if (ptr) {</p><p><code></code>*ptr = avctx->extradata;</p><p><code></code>}</p><p><code></code>return true;</p><p>}</p><p>drawMV()用于从AVFrame中获取运动矢量信息，并画出来（这个函数用于一个名为“可视化”的滤镜里面，用于显示视频的运动矢量信息）。</p><p>//画出运动矢量</p><p>bool TvideoCodecLibavcodec::drawMV(unsigned char *dst, unsigned int dstdx, stride_t stride, unsigned int dstdy) const</p><p>{</p><p><code></code>if (!frame->motion_val || !frame->mb_type || !frame->motion_val[0]) {</p><p><code></code>return false;</p><p><code></code>}</p><p>#define IS_8X8(a) ((a)&MB_TYPE_8x8)</p><p>#define IS_16X8(a) ((a)&MB_TYPE_16x8)</p><p>#define IS_8X16(a) ((a)&MB_TYPE_8x16)</p><p>#define IS_INTERLACED(a) ((a)&MB_TYPE_INTERLACED)</p><p>#define USES_LIST(a, list) ((a) & ((MB_TYPE_P0L0|MB_TYPE_P1L0)&lt;&lt;(2*(list))))</p><p><code></code>const int shift = 1 + ((frame->play_flags & CODEC_FLAG_QPEL) ? 1 : 0);</p><p><code></code>const int mv_sample_log2 = 4 - frame->motion_subsample_log2;</p><p><code></code>const int mv_stride = (frame->mb_width &lt;&lt; mv_sample_log2) + (avctx->codec_id == AV_CODEC_ID_H264 ? 0 : 1);</p><p><code></code>int direction = 0;</p><p><code></code>int mulx = (dstdx &lt;&lt; 12) / avctx->width;</p><p><code></code>int muly = (dstdy &lt;&lt; 12) / avctx->height;</p><p><code></code>//提取两个方向上的运动矢量信息（根据不同的宏块划分，可以分成几种情况）</p><p><code></code>//在AVCodecContext的motion_val中</p><p><code></code>for (int mb_y = 0; mb_y &lt; frame->mb_height; mb_y++)</p><p><code></code>for (int mb_x = 0; mb_x &lt; frame->mb_width; mb_x++) {</p><p><code></code>const int mb_index = mb_x + mb_y * frame->mb_stride;</p><p><code></code>if (!USES_LIST(frame->mb_type[mb_index], direction)) {</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>…此处代码太长，略</p><p><code></code>}</p><p>#undef IS_8X8</p><p>#undef IS_16X8</p><p>#undef IS_8X16</p><p>#undef IS_INTERLACED</p><p>#undef USES_LIST</p><p><code></code>return true;</p><p>}</p><p>下面来看几个很重要的函数，这几个函数继承自TvideoCodecDec类。</p><p>beginDecompress()用于解码器的初始化。注：这个函数的代码太长了，因此只选择一点关键的代码。</p><p>//----------------------------- decompression -----------------------------</p><p>bool TvideoCodecLibavcodec::beginDecompress(TffPictBase &pict, FOURCC fcc, const CMediaType &mt, int sourceFlags)</p><p>{</p><p><code></code>palette_size = 0;</p><p><code></code>prior_out_rtStart = REFTIME_INVALID;</p><p><code></code>prior_out_rtStop = 0;</p><p><code></code>rtStart = rtStop = REFTIME_INVALID;</p><p><code></code>prior_in_rtStart = prior_in_rtStop = REFTIME_INVALID;</p><p><code></code>mpeg2_in_doubt = codecId == AV_CODEC_ID_MPEG2VIDEO;</p><p><code></code>int using_dxva = 0;</p><p><code></code>int numthreads = deci->getParam2(IDFF_numLAVCdecThreads);</p><p><code></code>int thread_type = 0;</p><p><code></code>if (numthreads > 1 && sup_threads_dec_frame(codecId)) {</p><p><code></code>thread_type = FF_THREAD_FRAME;</p><p><code></code>} else if (numthreads > 1 && sup_threads_dec_slice(codecId)) {</p><p><code></code>thread_type = FF_THREAD_SLICE;</p><p><code></code>}</p><p><code></code>if (numthreads > 1 && thread_type != 0) {</p><p><code></code>threadcount = numthreads;</p><p><code></code>} else {</p><p><code></code>threadcount = 1;</p><p><code></code>}</p><p><code></code>if (codecId == CODEC_ID_H264_DXVA) {</p><p><code></code>codecId = AV_CODEC_ID_H264;</p><p><code></code>using_dxva = 1;</p><p><code></code>} else if (codecId == CODEC_ID_VC1_DXVA) {</p><p><code></code>codecId = AV_CODEC_ID_VC1;</p><p><code></code>using_dxva = 1;</p><p><code></code>}</p><p><code></code>avcodec = libavcodec->avcodec_find_decoder(codecId);</p><p><code></code>if (!avcodec) {</p><p><code></code>return false;</p><p><code></code>}</p><p><code></code>avctx = libavcodec->avcodec_alloc_context(avcodec, this);</p><p><code></code>avctx->thread_type = thread_type;</p><p><code></code>avctx->thread_count = threadcount;</p><p><code></code>avctx->h264_using_dxva = using_dxva;</p><p><code></code>if (codecId == AV_CODEC_ID_H264) {</p><p><code></code>// If we do not set this, first B-frames before the IDR pictures are dropped.</p><p><code></code>avctx->has_b_frames = 1;</p><p><code></code>}</p><p><code></code>frame = libavcodec->avcodec_alloc_frame();</p><p><code></code>avctx->width = pict.rectFull.dx;</p><p><code></code>avctx->height = pict.rectFull.dy;</p><p><code></code>intra_matrix = avctx->intra_matrix = (uint16_t*)calloc(sizeof(uint16_t), 64);</p><p><code></code>inter_matrix = avctx->inter_matrix = (uint16_t*)calloc(sizeof(uint16_t), 64);</p><p><code></code>ownmatrices = true;</p><p><code></code>// Fix for new Haali custom media type and fourcc. ffmpeg does not understand it, we have to change it to FOURCC_AVC1</p><p><code></code>if (fcc == FOURCC_CCV1) {</p><p><code></code>fcc = FOURCC_AVC1;</p><p><code></code>}</p><p><code></code>avctx->codec_tag = fcc;</p><p><code></code>avctx->workaround_bugs = deci->getParam2(IDFF_workaroundBugs);</p><p>#if 0</p><p><code></code>avctx->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;</p><p><code></code>avctx->err_recognition = AV_EF_CRCCHECK | AV_EF_BITSTREAM | AV_EF_BUFFER | AV_EF_COMPLIANT | AV_EF_AGGRESSIVE;</p><p>#endif</p><p><code></code>if (codecId == AV_CODEC_ID_MJPEG) {</p><p><code></code>avctx->flags |= CODEC_FLAG_TRUNCATED;</p><p><code></code>}</p><p><code></code>if (mpeg12_codec(codecId) && deci->getParam2(IDFF_fastMpeg2)) {</p><p><code></code>avctx->flags2 = CODEC_FLAG2_FAST;</p><p><code></code>}</p><p><code></code>if (codecId == AV_CODEC_ID_H264)</p><p><code></code>if (int skip = deci->getParam2(IDFF_fastH264)) {</p><p><code></code>avctx->skip_loop_filter = skip & 2 ? AVDISCARD_ALL : AVDISCARD_NONREF;</p><p><code></code>}</p><p><code></code>initialSkipLoopFilter = avctx->skip_loop_filter;</p><p><code></code>avctx->debug_mv = !using_dxva; //(deci->getParam2(IDFF_isVis) & deci->getParam2(IDFF_visMV));</p><p><code></code>avctx->idct_algo = limit(deci->getParam2(IDFF_idct), 0, 6);</p><p><code></code>if (extradata) {</p><p><code></code>delete extradata;</p><p><code></code>}</p><p>extradata = new Textradata(mt, FF_INPUT_BUFFER_PADDING_SIZE);</p><p>此处代码太长，略…</p><p>}</p><p>从代码中可以看出这个函数的流程是：</p><p>1.avcodec_find_decoder();</p><p>2.avcodec_alloc_context();</p><p>3.avcodec_alloc_frame();</p><p>4.avcodec_open();</p><p>主要做了libavcodec初始化工作。</p><p>begin decompress()用于解码器的初始化。 注：这个函数的代码太长了，因此只选择一点关键的代码。</p><p>HRESULT TvideoCodecLibavcodec::decompress(const unsigned char *src, size_t srcLen0, IMediaSample *pIn)</p><p>{</p><p><code></code>代码太长，略…</p><p><code></code>AVPacket avpkt;</p><p><code></code>libavcodec->av_init_packet(&avpkt);</p><p><code></code>if (palette_size) {</p><p><code></code>uint32_t *pal = (uint32_t *)libavcodec->av_packet_new_side_data(&avpkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);</p><p><code></code>for (int i = 0; i &lt; palette_size / 4; i++) {</p><p><code></code>pal[i] = 0xFF &lt;&lt; 24 | AV_RL32(palette + i);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>while (!src || size > 0) {</p><p><code></code>int used_bytes;</p><p><code></code>avctx->reordered_opaque = rtStart;</p><p><code></code>avctx->reordered_opaque2 = rtStop;</p><p><code></code>avctx->reordered_opaque3 = size;</p><p><code></code>if (sendextradata && extradata->data && extradata->size > 0) {</p><p><code></code>avpkt.data = (uint8_t *)extradata->data;</p><p><code></code>avpkt.size = (int)extradata->size;</p><p><code></code>used_bytes = libavcodec->avcodec_decode_video2(avctx, frame, &got_picture, &avpkt);</p><p><code></code>sendextradata = false;</p><p><code></code>if (used_bytes > 0) {</p><p><code></code>used_bytes = 0;</p><p><code></code>}</p><p><code></code>if (mpeg12_codec(codecId)) {</p><p><code></code>avctx->extradata = NULL;</p><p><code></code>avctx->extradata_size = 0;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>unsigned int neededsize = size + FF_INPUT_BUFFER_PADDING_SIZE;</p><p><code></code>if (ffbuflen &lt; neededsize) {</p><p><code></code>ffbuf = (unsigned char*)realloc(ffbuf, ffbuflen = neededsize);</p><p><code></code>}</p><p><code></code>if (src) {</p><p><code></code>memcpy(ffbuf, src, size);</p><p><code></code>memset(ffbuf + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>}</p><p><code></code>if (parser) {</p><p><code></code>uint8_t *outBuf = NULL;</p><p><code></code>int out_size = 0;</p><p><code></code>used_bytes = libavcodec->av_parser_parse2(parser, avctx, &outBuf, &out_size, src ? ffbuf : NULL, size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);</p><p><code></code>if (prior_in_rtStart == REFTIME_INVALID) {</p><p><code></code>prior_in_rtStart = rtStart;</p><p><code></code>prior_in_rtStop = rtStop;</p><p><code></code>}</p><p><code></code>if (out_size > 0 || !src) {</p><p><code></code>mpeg2_in_doubt = false;</p><p><code></code>avpkt.data = out_size > 0 ? outBuf : NULL;</p><p><code></code>avpkt.size = out_size;</p><p><code></code>if (out_size > used_bytes) {</p><p><code></code>avctx->reordered_opaque = prior_in_rtStart;</p><p><code></code>avctx->reordered_opaque2 = prior_in_rtStop;</p><p><code></code>} else {</p><p><code></code>avctx->reordered_opaque = rtStart;</p><p><code></code>avctx->reordered_opaque2 = rtStop;</p><p><code></code>}</p><p><code></code>prior_in_rtStart = rtStart;</p><p><code></code>prior_in_rtStop = rtStop;</p><p><code></code>avctx->reordered_opaque3 = out_size;</p><p><code></code>if (h264RandomAccess.search(avpkt.data, avpkt.size)) {</p><p><code></code>libavcodec->avcodec_decode_video2(avctx, frame, &got_picture, &avpkt);</p><p><code></code>h264RandomAccess.judgeUsability(&got_picture);</p><p><code></code>} else {</p><p><code></code>got_picture = 0;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>got_picture = 0;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>avpkt.data = src ? ffbuf : NULL;</p><p><code></code>avpkt.size = size;</p><p><code></code>if (codecId == AV_CODEC_ID_H264) {</p><p><code></code>if (h264RandomAccess.search(avpkt.data, avpkt.size)) {</p><p><code></code>used_bytes = libavcodec->avcodec_decode_video2(avctx, frame, &got_picture, &avpkt);</p><p><code></code>if (used_bytes &lt; 0) {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>h264RandomAccess.judgeUsability(&got_picture);</p><p><code></code>} else {</p><p><code></code>got_picture = 0;</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>used_bytes = libavcodec->avcodec_decode_video2(avctx, frame, &got_picture, &avpkt);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>代码太长，略…</p><p>}</p><p>从代码中可以看出这个函数的流程是：</p><p>1.AVPacket avpkt;</p><p>2.av_init_packet();</p><p>3.avcodec_decode_video2();</p><p>和ffmpeg的解码流程相差不大。</p><h3 id=ffdshow-源代码分析-8-视频解码器类tvideocodecdechttpblogcsdnnetleixiaohua1020articledetails15493743><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493743><strong>ffdshow 源代码分析 8： 视频解码器类（TvideoCodecDec）</strong></a></h3><p>其中libavcodec的解码器类TvideoCodecLibavcodec通过调用Tlibavcodec中的方法实现了libavcodec的dll中方法的调用；而它继承了TvideoCodecDec，本文正是要分析它继承的这个类。</p><p>TvideoCodecDec是所有视频解码器共有的父类。可以看一下它的继承关系：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.151.jpeg alt></p><p>可见，除了TvideoCodecLibavcodec继承了TvideoCodecDec之外，还有好几个类继承了TvideoCodecDec，比如说：TvideoCodecLibmpeg2，TvideoCodecXviD4等等…。突然来了兴趣，我们可以看一下其他的解码器类的定义是什么样的。</p><p>TvideoCodecLibmpeg2定义如下：</p><p>#ifndef _TVIDEOCODECLIBMPEG2_H_</p><p>#define _TVIDEOCODECLIBMPEG2_H_</p><p>#include "TvideoCodec.h"</p><p>#include "libmpeg2/include/mpeg2.h"</p><p>class Tdll;</p><p>struct Textradata;</p><p>class TccDecoder;</p><p>//libmpeg2解码器</p><p>class TvideoCodecLibmpeg2 : public TvideoCodecDec</p><p>{</p><p>private:</p><p><code></code>Tdll *dll;</p><p><code></code>uint32_t (*mpeg2_set_accel)(uint32_t accel);</p><p><code></code>mpeg2dec_t* (*mpeg2_init)(void);</p><p><code></code>const mpeg2_info_t* (*mpeg2_info)(mpeg2dec_t *mpeg2dec);</p><p><code></code>mpeg2_state_t (*mpeg2_parse)(mpeg2dec_t *mpeg2dec);</p><p><code></code>void (*mpeg2_buffer)(mpeg2dec_t *mpeg2dec, const uint8_t *start, const uint8_t *end);</p><p><code></code>void (*mpeg2_close)(mpeg2dec_t *mpeg2dec);</p><p><code></code>void (*mpeg2_reset)(mpeg2dec_t *mpeg2dec, int full_reset);</p><p><code></code>void (*mpeg2_set_rtStart)(mpeg2dec_t *mpeg2dec, int64_t rtStart);</p><p><code></code>int (*mpeg2_guess_aspect)(const mpeg2_sequence_t * sequence, unsigned int * pixel_width, unsigned int * pixel_height);</p><p><code></code>mpeg2dec_t *mpeg2dec;</p><p><code></code>const mpeg2_info_t *info;</p><p><code></code>bool wait4Iframe;</p><p><code></code>int sequenceFlag;</p><p><code></code>REFERENCE_TIME avgTimePerFrame;</p><p><code></code>TffPict oldpict;</p><p><code></code>Textradata *extradata;</p><p><code></code>TccDecoder *ccDecoder;</p><p><code></code>Tbuffer *buffer;</p><p><code></code>uint32_t oldflags;</p><p><code></code>bool m_fFilm;</p><p><code></code>int SetDeinterlaceMethod(void);</p><p><code></code>void init(void);</p><p><code></code>HRESULT decompressI(const unsigned char *src, size_t srcLen, IMediaSample *pIn);</p><p>protected:</p><p><code></code>virtual bool beginDecompress(TffPictBase &pict, FOURCC infcc, const CMediaType &mt, int sourceFlags);</p><p>public:</p><p><code></code>TvideoCodecLibmpeg2(IffdshowBase *Ideci, IdecVideoSink *Isink);</p><p><code></code>virtual ~TvideoCodecLibmpeg2();</p><p><code></code>static const char_t *dllname;</p><p><code></code>virtual int getType(void) const {</p><p><code></code>return IDFF_MOVIE_LIBMPEG2;</p><p><code></code>}</p><p><code></code>virtual int caps(void) const {</p><p><code></code>return CAPS::VIS_QUANTS;</p><p><code></code>}</p><p><code></code>virtual void end(void);</p><p><code></code>virtual HRESULT decompress(const unsigned char *src, size_t srcLen, IMediaSample *pIn);</p><p><code></code>virtual bool onSeek(REFERENCE_TIME segmentStart);</p><p><code></code>virtual HRESULT BeginFlush();</p><p>};</p><p>#endif</p><p>TvideoCodecXviD4定义如下：</p><p>#ifndef _TVIDEOCODECXVID4_H_</p><p>#define _TVIDEOCODECXVID4_H_</p><p>#include "TvideoCodec.h"</p><p>class Tdll;</p><p>struct Textradata;</p><p>//xvid解码器</p><p>class TvideoCodecXviD4 : public TvideoCodecDec</p><p>{</p><p>private:</p><p><code></code>void create(void);</p><p><code></code>Tdll *dll;</p><p>public:</p><p><code></code>TvideoCodecXviD4(IffdshowBase *Ideci, IdecVideoSink *IsinkD);</p><p><code></code>virtual ~TvideoCodecXviD4();</p><p><code></code>int (*xvid_global)(void *handle, int opt, void *param1, void *param2);</p><p><code></code>int (*xvid_decore)(void *handle, int opt, void *param1, void *param2);</p><p><code></code>int (*xvid_plugin_single)(void *handle, int opt, void *param1, void *param2);</p><p><code></code>int (*xvid_plugin_lumimasking)(void *handle, int opt, void *param1, void *param2);</p><p><code></code>static const char_t *dllname;</p><p>private:</p><p><code></code>void *enchandle, *dechandle;</p><p><code></code>int psnr;</p><p><code></code>TffPict pict;</p><p><code></code>Tbuffer pictbuf;</p><p><code></code>static int me_hq(int rd3), me_(int me3);</p><p><code></code>Textradata *extradata;</p><p><code></code>REFERENCE_TIME rtStart, rtStop;</p><p>protected:</p><p><code></code>virtual bool beginDecompress(TffPictBase &pict, FOURCC infcc, const CMediaType &mt, int sourceFlags);</p><p><code></code>virtual HRESULT flushDec(void);</p><p>public:</p><p><code></code>virtual int getType(void) const {</p><p><code></code>return IDFF_MOVIE_XVID4;</p><p><code></code>}</p><p><code></code>virtual int caps(void) const {</p><p><code></code>return CAPS::VIS_QUANTS;</p><p><code></code>}</p><p><code></code>virtual HRESULT decompress(const unsigned char *src, size_t srcLen, IMediaSample *pIn);</p><p>};</p><p>#endif</p><p>从以上这2种解码器类的定义，我们可以看出一些规律，比如说：</p><p>\1. 都有Tdll *dll这个变量，用于加载视频解码器的dll</p><p>\2. 都有beginDecompress()函数，用于初始化解码器</p><p>\3. 都有decompress()函数，用于解码</p><p>好了，闲话不说，回归正题，来看一下这些解码器共有的父类：TvideoCodecDec</p><p>//具体 视频 解码器的父类，存一些公共信息</p><p>class TvideoCodecDec : virtual public TvideoCodec, virtual public TcodecDec</p><p>{</p><p>protected:</p><p><code></code>bool isdvdproc;</p><p><code></code>comptrQ<iffdshowdecvideo> deciV;</p><p><code></code>IdecVideoSink *sinkD;</p><p><code></code>TvideoCodecDec(IffdshowBase *Ideci, IdecVideoSink *Isink);</p><p><code></code>Rational guessMPEG2sar(const Trect &r, const Rational &sar2, const Rational &containerSar);</p><p><code></code>class TtelecineManager</p><p><code></code>{</p><p><code></code>private:</p><p><code></code>TvideoCodecDec* parent;</p><p><code></code>int segment_count;</p><p><code></code>int pos_in_group;</p><p><code></code>struct {</p><p><code></code>int fieldtype;</p><p><code></code>int repeat_pict;</p><p><code></code>REFERENCE_TIME rtStart;</p><p><code></code>} group[2]; // store information about 2 recent frames.</p><p><code></code>REFERENCE_TIME group_rtStart;</p><p><code></code>bool film;</p><p><code></code>int cfg_softTelecine;</p><p><code></code>public:</p><p><code></code>TtelecineManager(TvideoCodecDec* Iparent);</p><p><code></code>void get_timestamps(TffPict &pict);</p><p><code></code>void get_fieldtype(TffPict &pict);</p><p><code></code>void new_frame(int top_field_first, int repeat_pict, const REFERENCE_TIME &rtStart, const REFERENCE_TIME &rtStop);</p><p><code></code>void onSeek(void);</p><p><code></code>} telecineManager;</p><p>public:</p><p><code></code>static TvideoCodecDec* initDec(IffdshowBase *deci, IdecVideoSink *Isink, AVCodecID codecId, FOURCC fcc, const CMediaType &mt);</p><p><code></code>virtual ~TvideoCodecDec();</p><p><code></code>virtual int caps(void) const {</p><p><code></code>return CAPS::NONE;</p><p><code></code>}</p><p><code></code>virtual bool testMediaType(FOURCC fcc, const CMediaType &mt) {</p><p><code></code>return true;</p><p><code></code>}</p><p><code></code>virtual void forceOutputColorspace(const BITMAPINFOHEADER *hdr, int *ilace, TcspInfos &forcedCsps) {</p><p><code></code>*ilace = 0; //cspInfos of forced output colorspace, empty when entering function</p><p><code></code>}</p><p><code></code>enum {SOURCE_REORDER = 1};</p><p><code></code>virtual bool beginDecompress(TffPictBase &pict, FOURCC infcc, const CMediaType &mt, int sourceFlags) = 0;</p><p><code></code>virtual HRESULT decompress(const unsigned char *src, size_t srcLen, IMediaSample *pIn) = 0;</p><p><code></code>virtual bool onDiscontinuity(void) {</p><p><code></code>return false;</p><p><code></code>}</p><p><code></code>virtual HRESULT onEndOfStream(void) {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>unsigned int quantsDx, quantsStride, quantsDy, quantBytes, quantType;</p><p><code></code>//QP表</p><p><code></code>void *quants;</p><p><code></code>uint16_t *intra_matrix, *inter_matrix;</p><p><code></code>//计算平均QP</p><p><code></code>float calcMeanQuant(void);</p><p><code></code>//画运动矢量</p><p><code></code>virtual bool drawMV(unsigned char *dst, unsigned int dx, stride_t stride, unsigned int dy) const {</p><p><code></code>return false;</p><p><code></code>}</p><p><code></code>virtual const char* get_current_idct(void) {</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>virtual int useDXVA(void) {</p><p><code></code>return 0;</p><p><code></code>};</p><p><code></code>virtual void setOutputPin(IPin * /*pPin*/) {}</p><p>};</p><p>TvideoCodecDec这个类中，还定义了一个类TtelecineManager。这种在类里面再定义一个类的方式还是不太多见的。TtelecineManager这个类的作用还没有研究，先不管它。</p><p>可以看出，TvideoCodecDec类的定义并不复杂，最主要的变量有如下几个，这几个变量都是子类中会用到的：</p><p>comptrQ<iffdshowdecvideo>deciV：重要性不言而喻，回头介绍</p><p>IdecVideoSink *sinkD：重要性不言而喻，回头介绍</p><p>void *quants：QP表（为什么要存在这里还没搞清）</p><p>TvideoCodecDec类定义了几个函数：</p><p>initDec()：初始化解码器（重要）</p><p>calcMeanQuant()：计算平均QP（为什么要在这里计算还没搞清）</p><p>TvideoCodecDec类还定义了一些纯虚函数，作为接口，这些函数的实现都在TvideoCodecDec的子类中完成【这几个函数是最重要的】：</p><p>beginDecompress();</p><p>decompress();</p><p>TvideoCodecDec类中最重要的函数只有一个，就是initDec()，作用主要是初始化解码器。其他的很多函数大多只是定义了一个名称，并没有实现，因为都是打算在具体各种解码器类中再进行实现的。</p><p>看一下initDec()的代码：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493743#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493743#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>TvideoCodecDec* TvideoCodecDec::initDec(IffdshowBase *deci, IdecVideoSink *sink, AVCodecID codecId, FOURCC fcc, const CMediaType &mt)</p><p>{</p><p><code></code>// DXVA mode is a preset setting</p><p><code></code>switch (codecId) {</p><p><code></code>case AV_CODEC_ID_H264:</p><p><code></code>if (deci->getParam2(IDFF_filterMode) & IDFF_FILTERMODE_VIDEODXVA) {</p><p><code></code>if (deci->getParam2(IDFF_dec_DXVA_H264)) {</p><p><code></code>codecId = CODEC_ID_H264_DXVA;</p><p><code></code>} else {</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case AV_CODEC_ID_VC1:</p><p><code></code>case CODEC_ID_WMV9_LIB:</p><p><code></code>if (deci->getParam2(IDFF_filterMode) & IDFF_FILTERMODE_VIDEODXVA) {</p><p><code></code>if (deci->getParam2(IDFF_dec_DXVA_VC1)) {</p><p><code></code>codecId = CODEC_ID_VC1_DXVA;</p><p><code></code>} else {</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>TvideoCodecDec *movie = NULL;</p><p><code></code>if (is_quicksync_codec(codecId)) {</p><p><code></code>movie = new TvideoCodecQuickSync(deci, sink, codecId);</p><p><code></code>} else if (lavc_codec(codecId)) {</p><p><code></code>movie = new TvideoCodecLibavcodec(deci, sink);</p><p><code></code>} else if (raw_codec(codecId)) {</p><p><code></code>movie = new TvideoCodecUncompressed(deci, sink);</p><p><code></code>} else if (wmv9_codec(codecId)) {</p><p><code></code>movie = new TvideoCodecWmv9(deci, sink);</p><p><code></code>} else if (codecId == CODEC_ID_XVID4) {</p><p><code></code>movie = new TvideoCodecXviD4(deci, sink);</p><p><code></code>} else if (codecId == CODEC_ID_LIBMPEG2) {</p><p><code></code>movie = new TvideoCodecLibmpeg2(deci, sink);</p><p><code></code>} else if (codecId == CODEC_ID_AVISYNTH) {</p><p><code></code>movie = new TvideoCodecAvisynth(deci, sink);</p><p><code></code>} else if (codecId == CODEC_ID_H264_DXVA || codecId == CODEC_ID_VC1_DXVA) {</p><p><code></code>movie = new TvideoCodecLibavcodecDxva(deci, sink, codecId);</p><p><code></code>} else {</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>if (!movie) {</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>if (movie->ok && movie->testMediaType(fcc, mt)) {</p><p><code></code>movie->codecId = codecId;</p><p><code></code>return movie;</p><p><code></code>} else if (is_quicksync_codec(codecId)) {</p><p><code></code>// QuickSync decoder init failed, revert to internal decoder.</p><p><code></code>switch (codecId) {</p><p><code></code>case CODEC_ID_H264_QUICK_SYNC:</p><p><code></code>codecId = AV_CODEC_ID_H264;</p><p><code></code>break;</p><p><code></code>case CODEC_ID_MPEG2_QUICK_SYNC:</p><p><code></code>codecId = CODEC_ID_LIBMPEG2;</p><p><code></code>break;</p><p><code></code>case CODEC_ID_VC1_QUICK_SYNC:</p><p><code></code>codecId = CODEC_ID_WMV9_LIB;</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>ASSERT(FALSE); // this shouldn't happen!</p><p><code></code>}</p><p><code></code>delete movie;</p><p><code></code>// Call this function again with the new codecId.</p><p><code></code>return initDec(deci, sink, codecId, fcc, mt);</p><p><code></code>} else {</p><p><code></code>delete movie;</p><p><code></code>return NULL;</p><p><code></code>}</p><p>}</p><p>这个函数的功能还是比较好理解的，根据CodecID的不同，创建不同的解码器（从TvideoCodecLibavcodec，TvideoCodecXviD4，TvideoCodecLibmpeg2这些里面选择）。</p><p>虽然不知道用途是什么，但是我们可以顺便看一下计算平均QP的函数，就是把quants1指向的QP表里面的数据求了一个平均值：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493743#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493743#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>//计算平均QP</p><p>float TvideoCodecDec::calcMeanQuant(void)</p><p>{</p><p><code></code>if (!quants || !quantsDx || !quantsDy) {</p><p><code></code>return 0;</p><p><code></code>}</p><p><code></code>unsigned int sum = 0, num = quantsDx * quantsDy;</p><p><code></code>unsigned char *quants1 = (unsigned char*)quants;</p><p><code></code>for (unsigned int y = 0; y &lt; quantsDy; y++)</p><p><code></code>for (unsigned int x = 0; x &lt; quantsDx; x++) {</p><p><code></code>sum += quants1[(y * quantsStride + x) * quantBytes];</p><p><code></code>}</p><p><code></code>return float(sum) / num;</p><p>}</p><h3 id=ffdshow-源代码分析-9-编解码器有关类的总结httpblogcsdnnetleixiaohua1020articledetails15493961><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961><strong>ffdshow 源代码分析 9： 编解码器有关类的总结</strong></a></h3><p>本文再做最后一点的分析。在ffdshow中有如下继承关系：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.152.jpeg alt></p><p>前文已经分析过TvideoCodecLibavcodec，TvideoCodecDec，在这里我们看一下他们的父类：TvideoCodec，TcodecDec，以及前两个类的父类Tcodec。</p><p>其实本文介绍的这3个类充当了接口的作用，TvideoCodecDec继承TvideoCodec，TcodecDec，以及这两个类继承Tcodec，都使用了virtual的方式。</p><p>先来看看TvideoCodec。注意这个类强调的是【视频】：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>//编解码器的父类</p><p>class TvideoCodec : virtual public Tcodec</p><p>{</p><p>public:</p><p><code></code>TvideoCodec(IffdshowBase *Ideci);</p><p><code></code>virtual ~TvideoCodec();</p><p><code></code>bool ok;</p><p><code></code>int connectedSplitter;</p><p><code></code>bool isInterlacedRawVideo;</p><p><code></code>Rational containerSar;</p><p><code></code>struct CAPS {</p><p><code></code>enum {</p><p><code></code>NONE = 0,</p><p><code></code>VIS_MV = 1,</p><p><code></code>VIS_QUANTS = 2</p><p><code></code>};</p><p><code></code>};</p><p><code></code>virtual void end(void) {}</p><p>};</p><p>可以看出TvideoCodec定义非常的简单，只包含了视频编解码器会用到的一些变量。注意，是编解码器，不仅仅是解码器。</p><p>再来看看TcodecDec。注意这个类强调的是【解码】：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>//实现了解码器的祖父类</p><p>class TcodecDec : virtual public Tcodec</p><p>{</p><p>private:</p><p><code></code>IdecSink *sink;</p><p>protected:</p><p><code></code>comptrQ<iffdshowdec> deciD;</p><p><code></code>TcodecDec(IffdshowBase *Ideci, IdecSink *Isink);</p><p><code></code>virtual ~TcodecDec();</p><p><code></code>virtual HRESULT flushDec(void) {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p>public:</p><p><code></code>virtual HRESULT flush(void);</p><p>};</p><p>可以看出TcodecDec定义非常简单，只包含了解码器需要的一些变量，注意不限于视频解码器，还包含音频解码器。有两个变量比较重要：</p><p>IdecSink *sink;</p><p>comptrQ<iffdshowdec> deciD;</p><p>最后来看一下Tcodec。这个类不再继承任何类：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/15493961#>copy</a><img src=https://code.csdn.net/assets/CODE_ico.png alt><img src=https://code.csdn.net/assets/ico_fork.svg alt></p><p>//编解码器的祖父类，都是虚函数</p><p>class Tcodec</p><p>{</p><p>protected:</p><p><code></code>const Tconfig *config;</p><p><code></code>comptr<iffdshowbase> deci;</p><p><code></code>Tcodec(IffdshowBase *Ideci);</p><p><code></code>virtual ~Tcodec();</p><p>public:</p><p><code></code>AVCodecID codecId;</p><p><code></code>virtual int getType(void) const = 0;</p><p><code></code>virtual const char_t* getName(void) const {</p><p><code></code>return getMovieSourceName(getType());</p><p><code></code>}</p><p><code></code>virtual void getEncoderInfo(char_t *buf, size_t buflen) const {</p><p><code></code>ff_strncpy(buf, _l("unknown"), buflen);</p><p><code></code>buf[buflen - 1] = '\0';</p><p><code></code>}</p><p><code></code>static const char_t* getMovieSourceName(int source);</p><p><code></code>virtual HRESULT flush() {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>virtual HRESULT BeginFlush() {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>virtual HRESULT EndFlush() {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>virtual bool onSeek(REFERENCE_TIME segmentStart) {</p><p><code></code>return false;</p><p><code></code>}</p><p>};</p><p>可以看出，该类定义了一些编解码器会用到的公共函数。有几个变量还是比较重要的：</p><p>const Tconfig *config;</p><p>comptr<iffdshowbase> deci;</p><p>Tcodec(IffdshowBase *Ideci);</p><p>AVCodecID codecId</p><p>自此，我们可以总结出ffdshow编解码器这部分继承关系如下（图太大了，截成两张）：</p><p>从TcodecDec继承下来的如下图所示。包含视频解码器以及音频解码器。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.153.jpeg alt></p><p>从TvideoCodec继承下来的如下图所示。包含了解码器类和编码器类。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.154.jpeg alt></p><p>总算大体上完成了，关于ffdshow解码器封装的内容就先告一段落吧。</p><h2 id=92-lav-filters><strong>9.2 LAV filters</strong></h2><p>LAV Filter是基于ffmpeg的解码器类库libavcodec，以及解封装器类库libavformat的DirectShow Filter。广泛安装在PC上。</p><h3 id=lav-filter-源代码分析-1-总体结构httpblogcsdnnetleixiaohua1020articledetails12711379><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711379><strong>LAV Filter 源代码分析 1： 总体结构</strong></a></h3><p>LAV Filter 是一款视频分离和解码软件，他的分离器封装了FFMPEG中的libavformat，解码器则封装了FFMPEG中的libavcodec。它支持十分广泛的视音频格式。</p><p>源代码位于GitHub或Google Code：</p><p><a href=https://github.com/Nevcairiel/LAVFilters>https://github.com/Nevcairiel/LAVFilters</a></p><p><a href=http://code.google.com/p/lavfilters/>http://code.google.com/p/lavfilters/</a></p><p>本文分析了LAV Filter源代码的总体架构。</p><p>使用git获取LAV filter源代码之后，使用VC 2010 打开源代码，发现代码目录结构如图所示：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.155.jpeg alt></p><p>整个解决方案由8个工程组成，介绍一下我目前所知的几个工程：</p><p>baseclasses：DirectShow基类，在DirectShow的SDK中也有，是微软为了简化DirectShow开发而提供的。</p><p>Demuxers：解封装的基类，LAVSplitter需要调用其中的方法完成解封装操作。</p><p>LAVAudio：音频解码Filter。封装了libavcodec。</p><p>LAVSplitter：解封装Filter。封装了libavformat。</p><p>LAVVideo：视频解码Filter。封装了libavcodec。</p><p>libbluray：蓝光的支持。</p><p>以上标为咖啡色字体的是要重点分析的，也是最重要的工程。</p><h3 id=lav-filter-源代码分析-2-lav-splitterhttpblogcsdnnetleixiaohua1020articledetails12711723><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723><strong>LAV Filter 源代码分析 2： LAV Splitter</strong></a></h3><p>LAV Filter 中最著名的就是 LAV Splitter，支持Matroska /WebM，MPEG-TS/PS，MP4/MOV，FLV，OGM / OGG，AVI等其他格式，广泛存在于各种视频播放器（暴风影音这类的）之中。</p><p>本文分析一下它的源代码。在分析之前，先看看它是什么样的。</p><p>使用GraphEdit随便打开一个视频文件，就可以看见LAV Filter：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.156.jpeg alt></p><p>可以右键点击这个Filter看一下它的属性页面，如图所示：</p><p>属性设置页面：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.157.jpeg alt></p><p>支持输入格式：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.158.jpeg alt></p><p>下面我们在 VC 2010 中看一下它的源代码：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.159.jpeg alt></p><p>从何看起呢？就先从directshow的注册函数看起吧，位于dllmain.cpp之中。部分代码的含义已经用注释标注上了。从代码可以看出，和普通的DirectShow Filter没什么区别。</p><p>dllmain.cpp</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>/*</p><p><code></code>* Copyright (C) 2010-2013 Hendrik Leppkes</p><p><code></code>* <a href=http://www.1f0.de>http://www.1f0.de</a></p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License along</p><p><code></code>* with this program; if not, write to the Free Software Foundation, Inc.,</p><p><code></code>* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p><p><code></code>*/</p><p>// Based on the SampleParser Template by GDCL</p><p>// --------------------------------------------------------------------------------</p><p>// Copyright (c) GDCL 2004. All Rights Reserved.</p><p>// You are free to re-use this as the basis for your own filter development,</p><p>// provided you retain this copyright notice in the source.</p><p>// <a href=http://www.gdcl.co.uk>http://www.gdcl.co.uk</a></p><p>// --------------------------------------------------------------------------------</p><p>//各种定义。。。</p><p>#include "stdafx.h"</p><p>// Initialize the GUIDs</p><p>#include &lt;InitGuid.h></p><p>#include &lt;qnetwork.h></p><p>#include "LAVSplitter.h"</p><p>#include "moreuuids.h"</p><p>#include "registry.h"</p><p>#include "IGraphRebuildDelegate.h"</p><p>// The GUID we use to register the splitter media types</p><p>DEFINE_GUID(MEDIATYPE_LAVSplitter,</p><p><code></code>0x9c53931c, 0x7d5a, 0x4a75, 0xb2, 0x6f, 0x4e, 0x51, 0x65, 0x4d, 0xb2, 0xc0);</p><p>// --- COM factory table and registration code --------------</p><p>//注册时候的信息</p><p>const AMOVIESETUP_MEDIATYPE</p><p><code></code>sudMediaTypes[] = {</p><p><code></code>{ &MEDIATYPE_Stream, &MEDIASUBTYPE_NULL },</p><p>};</p><p>//注册时候的信息（PIN）</p><p>const AMOVIESETUP_PIN sudOutputPins[] =</p><p>{</p><p><code></code>{</p><p><code></code>L"Output", // pin name</p><p><code></code>FALSE, // is rendered?</p><p><code></code>TRUE, // is output?</p><p><code></code>FALSE, // zero instances allowed?</p><p><code></code>TRUE, // many instances allowed?</p><p><code></code>&CLSID_NULL, // connects to filter (for bridge pins)</p><p><code></code>NULL, // connects to pin (for bridge pins)</p><p><code></code>0, // count of registered media types</p><p><code></code>NULL // list of registered media types</p><p><code></code>},</p><p><code></code>{</p><p><code></code>L"Input", // pin name</p><p><code></code>FALSE, // is rendered?</p><p><code></code>FALSE, // is output?</p><p><code></code>FALSE, // zero instances allowed?</p><p><code></code>FALSE, // many instances allowed?</p><p><code></code>&CLSID_NULL, // connects to filter (for bridge pins)</p><p><code></code>NULL, // connects to pin (for bridge pins)</p><p><code></code>1, // count of registered media types</p><p><code></code>&sudMediaTypes[0] // list of registered media types</p><p><code></code>}</p><p>};</p><p>//注册时候的信息（名称等）</p><p>//CLAVSplitter</p><p>const AMOVIESETUP_FILTER sudFilterReg =</p><p>{</p><p><code></code>&__uuidof(CLAVSplitter), // filter clsid</p><p><code></code>L"LAV Splitter", // filter name</p><p><code></code>MERIT_PREFERRED + 4, // merit</p><p><code></code>2, // count of registered pins</p><p><code></code>sudOutputPins, // list of pins to register</p><p><code></code>CLSID_LegacyAmFilterCategory</p><p>};</p><p>//注册时候的信息（名称等）</p><p>//CLAVSplitterSource</p><p>const AMOVIESETUP_FILTER sudFilterRegSource =</p><p>{</p><p><code></code>&__uuidof(CLAVSplitterSource), // filter clsid</p><p><code></code>L"LAV Splitter Source", // filter name</p><p><code></code>MERIT_PREFERRED + 4, // merit</p><p><code></code>1, // count of registered pins</p><p><code></code>sudOutputPins, // list of pins to register</p><p><code></code>CLSID_LegacyAmFilterCategory</p><p>};</p><p>// --- COM factory table and registration code --------------</p><p>// DirectShow base class COM factory requires this table,</p><p>// declaring all the COM objects in this DLL</p><p>// 注意g_Templates名称是固定的</p><p>CFactoryTemplate g_Templates[] = {</p><p><code></code>// one entry for each CoCreate-able object</p><p><code></code>{</p><p><code></code>sudFilterReg.strName,</p><p><code></code>sudFilterReg.clsID,</p><p><code></code>CreateInstance<clavsplitter>,</p><p><code></code>CLAVSplitter::StaticInit,</p><p><code></code>&sudFilterReg</p><p><code></code>},</p><p><code></code>{</p><p><code></code>sudFilterRegSource.strName,</p><p><code></code>sudFilterRegSource.clsID,</p><p><code></code>CreateInstance<clavsplittersource>,</p><p><code></code>NULL,</p><p><code></code>&sudFilterRegSource</p><p><code></code>},</p><p><code></code>// This entry is for the property page.</p><p><code></code>// 属性页</p><p><code></code>{</p><p><code></code>L"LAV Splitter Properties",</p><p><code></code>&CLSID_LAVSplitterSettingsProp,</p><p><code></code>CreateInstance<clavsplittersettingsprop>,</p><p><code></code>NULL, NULL</p><p><code></code>},</p><p><code></code>{</p><p><code></code>L"LAV Splitter Input Formats",</p><p><code></code>&CLSID_LAVSplitterFormatsProp,</p><p><code></code>CreateInstance<clavsplitterformatsprop>,</p><p><code></code>NULL, NULL</p><p><code></code>}</p><p>};</p><p>int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);</p><p>// self-registration entrypoint</p><p>STDAPI DllRegisterServer()</p><p>{</p><p><code></code>std::list<lpcwstr> chkbytes;</p><p><code></code>// BluRay</p><p><code></code>chkbytes.clear();</p><p><code></code>chkbytes.push_back(L"0,4,,494E4458"); // INDX (index.bdmv)</p><p><code></code>chkbytes.push_back(L"0,4,,4D4F424A"); // MOBJ (MovieObject.bdmv)</p><p><code></code>chkbytes.push_back(L"0,4,,4D504C53"); // MPLS</p><p><code></code>RegisterSourceFilter(__uuidof(CLAVSplitterSource),</p><p><code></code>MEDIASUBTYPE_LAVBluRay, chkbytes, NULL);</p><p><code></code>// base classes will handle registration using the factory template table</p><p><code></code>return AMovieDllRegisterServer2(true);</p><p>}</p><p>STDAPI DllUnregisterServer()</p><p>{</p><p><code></code>UnRegisterSourceFilter(MEDIASUBTYPE_LAVBluRay);</p><p><code></code>// base classes will handle de-registration using the factory template table</p><p><code></code>return AMovieDllRegisterServer2(false);</p><p>}</p><p>// if we declare the correct C runtime entrypoint and then forward it to the DShow base</p><p>// classes we will be sure that both the C/C++ runtimes and the base classes are initialized</p><p>// correctly</p><p>extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);</p><p>BOOL WINAPI DllMain(HANDLE hDllHandle, DWORD dwReason, LPVOID lpReserved)</p><p>{</p><p><code></code>return DllEntryPoint(reinterpret_cast<hinstance>(hDllHandle), dwReason, lpReserved);</p><p>}</p><p>void CALLBACK OpenConfiguration(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)</p><p>{</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>CUnknown *pInstance = CreateInstance<clavsplitter>(NULL, &hr);</p><p><code></code>IBaseFilter *pFilter = NULL;</p><p><code></code>pInstance->NonDelegatingQueryInterface(IID_IBaseFilter, (void **)&pFilter);</p><p><code></code>if (pFilter) {</p><p><code></code>pFilter->AddRef();</p><p><code></code>CBaseDSPropPage::ShowPropPageDialog(pFilter);</p><p><code></code>}</p><p><code></code>delete pInstance;</p><p>}</p><p>接下来就要进入正题了，看一看核心的分离器（解封装器）的类CLAVSplitter的定义文件LAVSplitter.h。乍一看这个类确实了得，居然继承了那么多的父类，实在是碉堡了。先不管那么多，看看里面都有什么函数吧。主要的函数上面都加了注释。注意还有一个类CLAVSplitterSource继承了CLAVSplitter。</p><p>LAVSplitter.h</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>/*</p><p><code></code>* Copyright (C) 2010-2013 Hendrik Leppkes</p><p><code></code>* <a href=http://www.1f0.de>http://www.1f0.de</a></p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License along</p><p><code></code>* with this program; if not, write to the Free Software Foundation, Inc.,</p><p><code></code>* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p><p><code></code>*</p><p><code></code>* Initial design and concept by Gabest and the MPC-HC Team, copyright under GPLv2</p><p><code></code>* Contributions by Ti-BEN from the XBMC DSPlayer Project, also under GPLv2</p><p><code></code>*/</p><p>#pragma once</p><p>#include <string></p><p>#include <list></p><p>#include <set></p><p>#include <vector></p><p>#include <map></p><p>#include "PacketQueue.h"</p><p>#include "BaseDemuxer.h"</p><p>#include "LAVSplitterSettingsInternal.h"</p><p>#include "SettingsProp.h"</p><p>#include "IBufferInfo.h"</p><p>#include "ISpecifyPropertyPages2.h"</p><p>#include "LAVSplitterTrayIcon.h"</p><p>#define LAVF_REGISTRY_KEY L"Software\LAV\Splitter"</p><p>#define LAVF_REGISTRY_KEY_FORMATS LAVF_REGISTRY_KEY L"\Formats"</p><p>#define LAVF_LOG_FILE L"LAVSplitter.txt"</p><p>#define MAX_PTS_SHIFT 50000000i64</p><p>class CLAVOutputPin;</p><p>class CLAVInputPin;</p><p>#ifdef _MSC_VER</p><p>#pragma warning(disable: 4355)</p><p>#endif</p><p>//核心解复用（分离器）</p><p>//暴漏的接口在ILAVFSettings中</p><p>[uuid("171252A0-8820-4AFE-9DF8-5C92B2D66B04")]</p><p>class CLAVSplitter</p><p><code></code>: public CBaseFilter</p><p><code></code>, public CCritSec</p><p><code></code>, protected CAMThread</p><p><code></code>, public IFileSourceFilter</p><p><code></code>, public IMediaSeeking</p><p><code></code>, public IAMStreamSelect</p><p><code></code>, public IAMOpenProgress</p><p><code></code>, public ILAVFSettingsInternal</p><p><code></code>, public ISpecifyPropertyPages2</p><p><code></code>, public IObjectWithSite</p><p><code></code>, public IBufferInfo</p><p>{</p><p>public:</p><p><code></code>CLAVSplitter(LPUNKNOWN pUnk, HRESULT* phr);</p><p><code></code>virtual ~CLAVSplitter();</p><p><code></code>static void CALLBACK StaticInit(BOOL bLoading, const CLSID *clsid);</p><p><code></code>// IUnknown</p><p><code></code>//</p><p><code></code>DECLARE_IUNKNOWN;</p><p><code></code>//暴露接口，使外部程序可以QueryInterface，关键！</p><p><code></code>//翻译（“没有代表的方式查询接口”）</p><p><code></code>STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);</p><p><code></code>// CBaseFilter methods</p><p><code></code>//输入是一个，输出就不一定了！</p><p><code></code>int GetPinCount();</p><p><code></code>CBasePin *GetPin(int n);</p><p><code></code>STDMETHODIMP GetClassID(CLSID* pClsID);</p><p><code></code>STDMETHODIMP Stop();</p><p><code></code>STDMETHODIMP Pause();</p><p><code></code>STDMETHODIMP Run(REFERENCE_TIME tStart);</p><p><code></code>STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);</p><p><code></code>// IFileSourceFilter</p><p><code></code>// 源Filter的接口方法</p><p><code></code>STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE * pmt);</p><p><code></code>STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName, AM_MEDIA_TYPE *pmt);</p><p><code></code>// IMediaSeeking</p><p><code></code>STDMETHODIMP GetCapabilities(DWORD* pCapabilities);</p><p><code></code>STDMETHODIMP CheckCapabilities(DWORD* pCapabilities);</p><p><code></code>STDMETHODIMP IsFormatSupported(const GUID* pFormat);</p><p><code></code>STDMETHODIMP QueryPreferredFormat(GUID* pFormat);</p><p><code></code>STDMETHODIMP GetTimeFormat(GUID* pFormat);</p><p><code></code>STDMETHODIMP IsUsingTimeFormat(const GUID* pFormat);</p><p><code></code>STDMETHODIMP SetTimeFormat(const GUID* pFormat);</p><p><code></code>STDMETHODIMP GetDuration(LONGLONG* pDuration);</p><p><code></code>STDMETHODIMP GetStopPosition(LONGLONG* pStop);</p><p><code></code>STDMETHODIMP GetCurrentPosition(LONGLONG* pCurrent);</p><p><code></code>STDMETHODIMP ConvertTimeFormat(LONGLONG* pTarget, const GUID* pTargetFormat, LONGLONG Source, const GUID* pSourceFormat);</p><p><code></code>STDMETHODIMP SetPositions(LONGLONG* pCurrent, DWORD dwCurrentFlags, LONGLONG* pStop, DWORD dwStopFlags);</p><p><code></code>STDMETHODIMP GetPositions(LONGLONG* pCurrent, LONGLONG* pStop);</p><p><code></code>STDMETHODIMP GetAvailable(LONGLONG* pEarliest, LONGLONG* pLatest);</p><p><code></code>STDMETHODIMP SetRate(double dRate);</p><p><code></code>STDMETHODIMP GetRate(double* pdRate);</p><p><code></code>STDMETHODIMP GetPreroll(LONGLONG* pllPreroll);</p><p><code></code>// IAMStreamSelect</p><p><code></code>STDMETHODIMP Count(DWORD *pcStreams);</p><p><code></code>STDMETHODIMP Enable(long lIndex, DWORD dwFlags);</p><p><code></code>STDMETHODIMP Info(long lIndex, AM_MEDIA_TYPE **ppmt, DWORD *pdwFlags, LCID *plcid, DWORD *pdwGroup, WCHAR **ppszName, IUnknown **ppObject, IUnknown **ppUnk);</p><p><code></code>// IAMOpenProgress</p><p><code></code>STDMETHODIMP QueryProgress(LONGLONG *pllTotal, LONGLONG *pllCurrent);</p><p><code></code>STDMETHODIMP AbortOperation();</p><p><code></code>// ISpecifyPropertyPages2</p><p><code></code>STDMETHODIMP GetPages(CAUUID *pPages);</p><p><code></code>STDMETHODIMP CreatePage(const GUID& guid, IPropertyPage** ppPage);</p><p><code></code>// IObjectWithSite</p><p><code></code>STDMETHODIMP SetSite(IUnknown *pUnkSite);</p><p><code></code>STDMETHODIMP GetSite(REFIID riid, void **ppvSite);</p><p><code></code>// IBufferInfo</p><p><code></code>STDMETHODIMP_(int) GetCount();</p><p><code></code>STDMETHODIMP GetStatus(int i, int& samples, int& size);</p><p><code></code>STDMETHODIMP_(DWORD) GetPriority();</p><p><code></code>// ILAVFSettings</p><p><code></code>STDMETHODIMP SetRuntimeConfig(BOOL bRuntimeConfig);</p><p><code></code>STDMETHODIMP GetPreferredLanguages(LPWSTR *ppLanguages);</p><p><code></code>STDMETHODIMP SetPreferredLanguages(LPCWSTR pLanguages);</p><p><code></code>STDMETHODIMP GetPreferredSubtitleLanguages(LPWSTR *ppLanguages);</p><p><code></code>STDMETHODIMP SetPreferredSubtitleLanguages(LPCWSTR pLanguages);</p><p><code></code>STDMETHODIMP_(LAVSubtitleMode) GetSubtitleMode();</p><p><code></code>STDMETHODIMP SetSubtitleMode(LAVSubtitleMode mode);</p><p><code></code>STDMETHODIMP_(BOOL) GetSubtitleMatchingLanguage();</p><p><code></code>STDMETHODIMP SetSubtitleMatchingLanguage(BOOL dwMode);</p><p><code></code>STDMETHODIMP_(BOOL) GetPGSForcedStream();</p><p><code></code>STDMETHODIMP SetPGSForcedStream(BOOL bFlag);</p><p><code></code>STDMETHODIMP_(BOOL) GetPGSOnlyForced();</p><p><code></code>STDMETHODIMP SetPGSOnlyForced(BOOL bForced);</p><p><code></code>STDMETHODIMP_(int) GetVC1TimestampMode();</p><p><code></code>STDMETHODIMP SetVC1TimestampMode(int iMode);</p><p><code></code>STDMETHODIMP SetSubstreamsEnabled(BOOL bSubStreams);</p><p><code></code>STDMETHODIMP_(BOOL) GetSubstreamsEnabled();</p><p><code></code>STDMETHODIMP SetVideoParsingEnabled(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetVideoParsingEnabled();</p><p><code></code>STDMETHODIMP SetFixBrokenHDPVR(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetFixBrokenHDPVR();</p><p><code></code>STDMETHODIMP_(HRESULT) SetFormatEnabled(LPCSTR strFormat, BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) IsFormatEnabled(LPCSTR strFormat);</p><p><code></code>STDMETHODIMP SetStreamSwitchRemoveAudio(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetStreamSwitchRemoveAudio();</p><p><code></code>STDMETHODIMP GetAdvancedSubtitleConfig(LPWSTR *ppAdvancedConfig);</p><p><code></code>STDMETHODIMP SetAdvancedSubtitleConfig(LPCWSTR pAdvancedConfig);</p><p><code></code>STDMETHODIMP SetUseAudioForHearingVisuallyImpaired(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetUseAudioForHearingVisuallyImpaired();</p><p><code></code>STDMETHODIMP SetMaxQueueMemSize(DWORD dwMaxSize);</p><p><code></code>STDMETHODIMP_(DWORD) GetMaxQueueMemSize();</p><p><code></code>STDMETHODIMP SetTrayIcon(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetTrayIcon();</p><p><code></code>STDMETHODIMP SetPreferHighQualityAudioStreams(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetPreferHighQualityAudioStreams();</p><p><code></code>STDMETHODIMP SetLoadMatroskaExternalSegments(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetLoadMatroskaExternalSegments();</p><p><code></code>STDMETHODIMP GetFormats(LPSTR** formats, UINT* nFormats);</p><p><code></code>STDMETHODIMP SetNetworkStreamAnalysisDuration(DWORD dwDuration);</p><p><code></code>STDMETHODIMP_(DWORD) GetNetworkStreamAnalysisDuration();</p><p><code></code>// ILAVSplitterSettingsInternal</p><p><code></code>STDMETHODIMP_(LPCSTR) GetInputFormat() { if (m_pDemuxer) return m_pDemuxer->GetContainerFormat(); return NULL; }</p><p><code></code>STDMETHODIMP_(std::set<formatinfo>&) GetInputFormats();</p><p><code></code>STDMETHODIMP_(BOOL) IsVC1CorrectionRequired();</p><p><code></code>STDMETHODIMP_(CMediaType *) GetOutputMediatype(int stream);</p><p><code></code>STDMETHODIMP_(IFilterGraph *) GetFilterGraph() { if (m_pGraph) { m_pGraph->AddRef(); return m_pGraph; } return NULL; }</p><p><code></code>STDMETHODIMP_(DWORD) GetStreamFlags(DWORD dwStream) { if (m_pDemuxer) return m_pDemuxer->GetStreamFlags(dwStream); return 0; }</p><p><code></code>STDMETHODIMP_(int) GetPixelFormat(DWORD dwStream) { if (m_pDemuxer) return m_pDemuxer->GetPixelFormat(dwStream); return AV_PIX_FMT_NONE; }</p><p><code></code>STDMETHODIMP_(int) GetHasBFrames(DWORD dwStream){ if (m_pDemuxer) return m_pDemuxer->GetHasBFrames(dwStream); return -1; }</p><p><code></code>// Settings helper</p><p><code></code>std::list<a href=std::string>std::string</a> GetPreferredAudioLanguageList();</p><p><code></code>std::list<csubtitleselector> GetSubtitleSelectors();</p><p><code></code>bool IsAnyPinDrying();</p><p><code></code>void SetFakeASFReader(BOOL bFlag) { m_bFakeASFReader = bFlag; }</p><p>protected:</p><p><code></code>// CAMThread</p><p><code></code>enum {CMD_EXIT, CMD_SEEK};</p><p><code></code>DWORD ThreadProc();</p><p><code></code>HRESULT DemuxSeek(REFERENCE_TIME rtStart);</p><p><code></code>HRESULT DemuxNextPacket();</p><p><code></code>HRESULT DeliverPacket(Packet *pPacket);</p><p><code></code>void DeliverBeginFlush();</p><p><code></code>void DeliverEndFlush();</p><p><code></code>STDMETHODIMP Close();</p><p><code></code>STDMETHODIMP DeleteOutputs();</p><p><code></code>//初始化解复用器</p><p><code></code>STDMETHODIMP InitDemuxer();</p><p><code></code>friend class CLAVOutputPin;</p><p><code></code>STDMETHODIMP SetPositionsInternal(void *caller, LONGLONG* pCurrent, DWORD dwCurrentFlags, LONGLONG* pStop, DWORD dwStopFlags);</p><p>public:</p><p><code></code>CLAVOutputPin *GetOutputPin(DWORD streamId, BOOL bActiveOnly = FALSE);</p><p><code></code>STDMETHODIMP RenameOutputPin(DWORD TrackNumSrc, DWORD TrackNumDst, std::vector<cmediatype> pmts);</p><p><code></code>STDMETHODIMP UpdateForcedSubtitleMediaType();</p><p><code></code>STDMETHODIMP CompleteInputConnection();</p><p><code></code>STDMETHODIMP BreakInputConnection();</p><p>protected:</p><p><code></code>//相关的参数设置</p><p><code></code>STDMETHODIMP LoadDefaults();</p><p><code></code>STDMETHODIMP ReadSettings(HKEY rootKey);</p><p><code></code>STDMETHODIMP LoadSettings();</p><p><code></code>STDMETHODIMP SaveSettings();</p><p><code></code>//创建图标</p><p><code></code>STDMETHODIMP CreateTrayIcon();</p><p>protected:</p><p><code></code>CLAVInputPin *m_pInput;</p><p>private:</p><p><code></code>CCritSec m_csPins;</p><p><code></code>//用vector存储输出PIN（解复用的时候是不确定的）</p><p><code></code>std::vector&lt;CLAVOutputPin *> m_pPins;</p><p><code></code>//活动的</p><p><code></code>std::vector&lt;CLAVOutputPin *> m_pActivePins;</p><p><code></code>//不用的</p><p><code></code>std::vector&lt;CLAVOutputPin *> m_pRetiredPins;</p><p><code></code>std::set<dword> m_bDiscontinuitySent;</p><p><code></code>std::wstring m_fileName;</p><p><code></code>std::wstring m_processName;</p><p><code></code>//有很多纯虚函数的基本解复用类</p><p><code></code>//注意：绝大部分信息都是从这获得的</p><p><code></code>//这里的信息是由其派生类从FFMPEG中获取到的</p><p><code></code>CBaseDemuxer *m_pDemuxer;</p><p><code></code>BOOL m_bPlaybackStarted;</p><p><code></code>BOOL m_bFakeASFReader;</p><p><code></code>// Times</p><p><code></code>REFERENCE_TIME m_rtStart, m_rtStop, m_rtCurrent, m_rtNewStart, m_rtNewStop;</p><p><code></code>REFERENCE_TIME m_rtOffset;</p><p><code></code>double m_dRate;</p><p><code></code>BOOL m_bStopValid;</p><p><code></code>// Seeking</p><p><code></code>REFERENCE_TIME m_rtLastStart, m_rtLastStop;</p><p><code></code>std::set&lt;void *> m_LastSeekers;</p><p><code></code>// flushing</p><p><code></code>bool m_fFlushing;</p><p><code></code>CAMEvent m_eEndFlush;</p><p><code></code>std::set<formatinfo> m_InputFormats;</p><p><code></code>// Settings</p><p><code></code>//设置</p><p><code></code>struct Settings {</p><p><code></code>BOOL TrayIcon;</p><p><code></code>std::wstring prefAudioLangs;</p><p><code></code>std::wstring prefSubLangs;</p><p><code></code>std::wstring subtitleAdvanced;</p><p><code></code>LAVSubtitleMode subtitleMode;</p><p><code></code>BOOL PGSForcedStream;</p><p><code></code>BOOL PGSOnlyForced;</p><p><code></code>int vc1Mode;</p><p><code></code>BOOL substreams;</p><p><code></code>BOOL MatroskaExternalSegments;</p><p><code></code>BOOL StreamSwitchRemoveAudio;</p><p><code></code>BOOL ImpairedAudio;</p><p><code></code>BOOL PreferHighQualityAudio;</p><p><code></code>DWORD QueueMaxSize;</p><p><code></code>DWORD NetworkAnalysisDuration;</p><p><code></code>std::map&lt;std::string, BOOL> formats;</p><p><code></code>} m_settings;</p><p><code></code>BOOL m_bRuntimeConfig;</p><p><code></code>IUnknown *m_pSite;</p><p><code></code>CBaseTrayIcon *m_pTrayIcon;</p><p>};</p><p>[uuid("B98D13E7-55DB-4385-A33D-09FD1BA26338")]</p><p>class CLAVSplitterSource : public CLAVSplitter</p><p>{</p><p>public:</p><p><code></code>// construct only via class factory</p><p><code></code>CLAVSplitterSource(LPUNKNOWN pUnk, HRESULT* phr);</p><p><code></code>virtual ~CLAVSplitterSource();</p><p><code></code>// IUnknown</p><p><code></code>DECLARE_IUNKNOWN;</p><p><code></code>//暴露接口，使外部程序可以QueryInterface，关键！</p><p><code></code>//翻译（“没有代表的方式查询接口”）</p><p><code></code>STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);</p><p>};</p><p>先来看一下查询接口的函数NonDelegatingQueryInterface()吧</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>//暴露接口，使外部程序可以QueryInterface，关键！</p><p>STDMETHODIMP CLAVSplitter::NonDelegatingQueryInterface(REFIID riid, void** ppv)</p><p>{</p><p><code></code>CheckPointer(ppv, E_POINTER);</p><p><code></code>*ppv = NULL;</p><p><code></code>if (m_pDemuxer && (riid == __uuidof(IKeyFrameInfo) || riid == __uuidof(ITrackInfo) || riid == IID_IAMExtendedSeeking || riid == IID_IAMMediaContent)) {</p><p><code></code>return m_pDemuxer->QueryInterface(riid, ppv);</p><p><code></code>}</p><p><code></code>//写法好特别啊，意思是一样的</p><p><code></code>return</p><p><code></code>QI(IMediaSeeking)</p><p><code></code>QI(IAMStreamSelect)</p><p><code></code>QI(ISpecifyPropertyPages)</p><p><code></code>QI(ISpecifyPropertyPages2)</p><p><code></code>QI2(ILAVFSettings)</p><p><code></code>QI2(ILAVFSettingsInternal)</p><p><code></code>QI(IObjectWithSite)</p><p><code></code>QI(IBufferInfo)</p><p><code></code>__super::NonDelegatingQueryInterface(riid, ppv);</p><p>}</p><p>这个NonDelegatingQueryInterface()的写法确实够特别的，不过其作用还是一样的：根据不同的REFIID，获得不同的接口指针。在这里就不多说了。</p><p>再看一下Load()函数</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>// IFileSourceFilter</p><p>// 打开</p><p>STDMETHODIMP CLAVSplitter::Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE * pmt)</p><p>{</p><p><code></code>CheckPointer(pszFileName, E_POINTER);</p><p><code></code>m_bPlaybackStarted = FALSE;</p><p><code></code>m_fileName = std::wstring(pszFileName);</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>SAFE_DELETE(m_pDemuxer);</p><p><code></code>LPWSTR extension = PathFindExtensionW(pszFileName);</p><p><code></code>DbgLog((LOG_TRACE, 10, L"::Load(): Opening file '%s' (extension: %s)", pszFileName, extension));</p><p><code></code>// BDMV uses the BD demuxer, everything else LAVF</p><p><code></code>if (_wcsicmp(extension, L".bdmv") == 0 || _wcsicmp(extension, L".mpls") == 0) {</p><p><code></code>m_pDemuxer = new CBDDemuxer(this, this);</p><p><code></code>} else {</p><p><code></code>m_pDemuxer = new CLAVFDemuxer(this, this);</p><p><code></code>}</p><p><code></code>//打开</p><p><code></code>if(FAILED(hr = m_pDemuxer->Open(pszFileName))) {</p><p><code></code>SAFE_DELETE(m_pDemuxer);</p><p><code></code>return hr;</p><p><code></code>}</p><p><code></code>m_pDemuxer->AddRef();</p><p><code></code>return InitDemuxer();</p><p>}</p><p>在这里我们要注意CLAVSplitter的一个变量：m_pDemuxer。这是一个指向 CBaseDemuxer的指针。因此在这里CLAVSplitter实际上调用了 CBaseDemuxer中的方法。</p><p>从代码中的逻辑我们可以看出：</p><p>1.寻找文件后缀</p><p>2.当文件后缀是：".bdmv"或者".mpls"的时候，m_pDemuxer指向一个CBDDemuxer（我推测这代表目标文件是蓝光文件什么的），其他情况下m_pDemuxer指向一个CLAVFDemuxer。</p><p>3.然后m_pDemuxer会调用Open()方法。</p><p>4.最后会调用一个InitDemuxer()方法。</p><p>在这里我们应该看看m_pDemuxer->Open()这个方法里面有什么。我们先考虑m_pDemuxer指向CLAVFDemuxer的情况。</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>// Demuxer Functions</p><p>// 打开（就是一个封装）</p><p>STDMETHODIMP CLAVFDemuxer::Open(LPCOLESTR pszFileName)</p><p>{</p><p><code></code>return OpenInputStream(NULL, pszFileName, NULL, TRUE);</p><p>}</p><p>发现是一层封装，于是果断决定层层深入。</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>//实际的打开,使用FFMPEG</p><p>STDMETHODIMP CLAVFDemuxer::OpenInputStream(AVIOContext *byteContext, LPCOLESTR pszFileName, const char *format, BOOL bForce)</p><p>{</p><p><code></code>CAutoLock lock(m_pLock);</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>int ret; // return code from avformat functions</p><p><code></code>// Convert the filename from wchar to char for avformat</p><p><code></code>char fileName[4100] = {0};</p><p><code></code>if (pszFileName) {</p><p><code></code>ret = WideCharToMultiByte(CP_UTF8, 0, pszFileName, -1, fileName, 4096, NULL, NULL);</p><p><code></code>}</p><p><code></code>if (_strnicmp("mms:", fileName, 4) == 0) {</p><p><code></code>memmove(fileName+1, fileName, strlen(fileName));</p><p><code></code>memcpy(fileName, "mmsh", 4);</p><p><code></code>}</p><p><code></code>AVIOInterruptCB cb = {avio_interrupt_cb, this};</p><p>trynoformat:</p><p><code></code>// Create the avformat_context</p><p><code></code>// FFMPEG中的函数</p><p><code></code>m_avFormat = avformat_alloc_context();</p><p><code></code>m_avFormat->pb = byteContext;</p><p><code></code>m_avFormat->interrupt_callback = cb;</p><p><code></code>if (m_avFormat->pb)</p><p><code></code>m_avFormat->flags |= AVFMT_FLAG_CUSTOM_IO;</p><p><code></code>LPWSTR extension = pszFileName ? PathFindExtensionW(pszFileName) : NULL;</p><p><code></code>AVInputFormat *inputFormat = NULL;</p><p><code></code>//如果指定了格式</p><p><code></code>if (format) {</p><p><code></code>//查查有木有</p><p><code></code>inputFormat = av_find_input_format(format);</p><p><code></code>} else if (pszFileName) {</p><p><code></code>LPWSTR extension = PathFindExtensionW(pszFileName);</p><p><code></code>for (int i = 0; i &lt; countof(wszImageExtensions); i++) {</p><p><code></code>if (_wcsicmp(extension, wszImageExtensions[i]) == 0) {</p><p><code></code>if (byteContext) {</p><p><code></code>inputFormat = av_find_input_format("image2pipe");</p><p><code></code>} else {</p><p><code></code>inputFormat = av_find_input_format("image2");</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>for (int i = 0; i &lt; countof(wszBlockedExtensions); i++) {</p><p><code></code>if (_wcsicmp(extension, wszBlockedExtensions[i]) == 0) {</p><p><code></code>goto done;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>// Disable loading of external mkv segments, if required</p><p><code></code>if (!m_pSettings->GetLoadMatroskaExternalSegments())</p><p><code></code>m_avFormat->flags |= AVFMT_FLAG_NOEXTERNAL;</p><p><code></code>m_timeOpening = time(NULL);</p><p><code></code>//实际的打开</p><p><code></code>ret = avformat_open_input(&m_avFormat, fileName, inputFormat, NULL);</p><p><code></code>//出错了</p><p><code></code>if (ret &lt; 0) {</p><p><code></code>DbgLog((LOG_ERROR, 0, TEXT("::OpenInputStream(): avformat_open_input failed (%d)"), ret));</p><p><code></code>if (format) {</p><p><code></code>DbgLog((LOG_ERROR, 0, TEXT(" -> trying again without specific format")));</p><p><code></code>format = NULL;</p><p><code></code>//实际的关闭</p><p><code></code>avformat_close_input(&m_avFormat);</p><p><code></code>goto trynoformat;</p><p><code></code>}</p><p><code></code>goto done;</p><p><code></code>}</p><p><code></code>DbgLog((LOG_TRACE, 10, TEXT("::OpenInputStream(): avformat_open_input opened file of type '%S' (took %I64d seconds)"), m_avFormat->iformat->name, time(NULL) - m_timeOpening));</p><p><code></code>m_timeOpening = 0;</p><p><code></code>//初始化AVFormat</p><p><code></code>CHECK_HR(hr = InitAVFormat(pszFileName, bForce));</p><p><code></code>return S_OK;</p><p>done:</p><p><code></code>CleanupAVFormat();</p><p><code></code>return E_FAIL;</p><p>}</p><p>看到这个函数，立马感受到了一种“拨云见日”的感觉。看到了很多FFMPEG的API函数。最重要的依据当属avformat_open_input()了，通过这个函数，打开了实际的文件。如果出现错误，则调用avformat_close_input()进行清理。</p><p>最后，还调用了InitAVFormat()函数：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/12711723#>copy</a></p><p>//初始化AVFormat</p><p>STDMETHODIMP CLAVFDemuxer::InitAVFormat(LPCOLESTR pszFileName, BOOL bForce)</p><p>{</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>const char *format = NULL;</p><p><code></code>//获取InputFormat信息（，短名称，长名称）</p><p><code></code>lavf_get_iformat_infos(m_avFormat->iformat, &format, NULL);</p><p><code></code>if (!bForce && (!format || !m_pSettings->IsFormatEnabled(format))) {</p><p><code></code>DbgLog((LOG_TRACE, 20, L"::InitAVFormat() - format of type '%S' disabled, failing", format ? format : m_avFormat->iformat->name));</p><p><code></code>return E_FAIL;</p><p><code></code>}</p><p><code></code>m_pszInputFormat = format ? format : m_avFormat->iformat->name;</p><p><code></code>m_bVC1SeenTimestamp = FALSE;</p><p><code></code>LPWSTR extension = pszFileName ? PathFindExtensionW(pszFileName) : NULL;</p><p><code></code>m_bMatroska = (_strnicmp(m_pszInputFormat, "matroska", 8) == 0);</p><p><code></code>m_bOgg = (_strnicmp(m_pszInputFormat, "ogg", 3) == 0);</p><p><code></code>m_bAVI = (_strnicmp(m_pszInputFormat, "avi", 3) == 0);</p><p><code></code>m_bMPEGTS = (_strnicmp(m_pszInputFormat, "mpegts", 6) == 0);</p><p><code></code>m_bMPEGPS = (_stricmp(m_pszInputFormat, "mpeg") == 0);</p><p><code></code>m_bRM = (_stricmp(m_pszInputFormat, "rm") == 0);</p><p><code></code>m_bPMP = (_stricmp(m_pszInputFormat, "pmp") == 0);</p><p><code></code>m_bMP4 = (_stricmp(m_pszInputFormat, "mp4") == 0);</p><p><code></code>m_bTSDiscont = m_avFormat->iformat->flags & AVFMT_TS_DISCONT;</p><p><code></code>WCHAR szProt[24] = L"file";</p><p><code></code>if (pszFileName) {</p><p><code></code>DWORD dwNumChars = 24;</p><p><code></code>hr = UrlGetPart(pszFileName, szProt, &dwNumChars, URL_PART_SCHEME, 0);</p><p><code></code>if (SUCCEEDED(hr) && dwNumChars && (_wcsicmp(szProt, L"file") != 0)) {</p><p><code></code>m_avFormat->flags |= AVFMT_FLAG_NETWORK;</p><p><code></code>DbgLog((LOG_TRACE, 10, TEXT("::InitAVFormat(): detected network protocol: %s"), szProt));</p><p><code></code>}</p><p><code></code>}</p><p><code></code>// TODO: make both durations below configurable</p><p><code></code>// decrease analyze duration for network streams</p><p><code></code>if (m_avFormat->flags & AVFMT_FLAG_NETWORK || (m_avFormat->flags & AVFMT_FLAG_CUSTOM_IO && !m_avFormat->pb->seekable)) {</p><p><code></code>// require at least 0.2 seconds</p><p><code></code>m_avFormat->max_analyze_duration = max(m_pSettings->GetNetworkStreamAnalysisDuration() * 1000, 200000);</p><p><code></code>} else {</p><p><code></code>// And increase it for mpeg-ts/ps files</p><p><code></code>if (m_bMPEGTS || m_bMPEGPS)</p><p><code></code>m_avFormat->max_analyze_duration = 10000000;</p><p><code></code>}</p><p><code></code>av_opt_set_int(m_avFormat, "correct_ts_overflow", !m_pBluRay, 0);</p><p><code></code>if (m_bMatroska)</p><p><code></code>m_avFormat->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;</p><p><code></code>m_timeOpening = time(NULL);</p><p><code></code>//获取媒体流信息</p><p><code></code>int ret = avformat_find_stream_info(m_avFormat, NULL);</p><p><code></code>if (ret &lt; 0) {</p><p><code></code>DbgLog((LOG_ERROR, 0, TEXT("::InitAVFormat(): av_find_stream_info failed (%d)"), ret));</p><p><code></code>goto done;</p><p><code></code>}</p><p><code></code>DbgLog((LOG_TRACE, 10, TEXT("::InitAVFormat(): avformat_find_stream_info finished, took %I64d seconds"), time(NULL) - m_timeOpening));</p><p><code></code>m_timeOpening = 0;</p><p><code></code>// Check if this is a m2ts in a BD structure, and if it is, read some extra stream properties out of the CLPI files</p><p><code></code>if (m_pBluRay) {</p><p><code></code>m_pBluRay->ProcessClipLanguages();</p><p><code></code>} else if (pszFileName && m_bMPEGTS) {</p><p><code></code>CheckBDM2TSCPLI(pszFileName);</p><p><code></code>}</p><p><code></code>SAFE_CO_FREE(m_stOrigParser);</p><p><code></code>m_stOrigParser = (enum AVStreamParseType *)CoTaskMemAlloc(m_avFormat->nb_streams * sizeof(enum AVStreamParseType));</p><p><code></code>if (!m_stOrigParser)</p><p><code></code>return E_OUTOFMEMORY;</p><p><code></code>for(unsigned int idx = 0; idx &lt; m_avFormat->nb_streams; ++idx) {</p><p><code></code>AVStream *st = m_avFormat->streams[idx];</p><p><code></code>// Disable full stream parsing for these formats</p><p><code></code>if (st->need_parsing == AVSTREAM_PARSE_FULL) {</p><p><code></code>if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {</p><p><code></code>st->need_parsing = AVSTREAM_PARSE_NONE;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (m_bOgg && st->codec->codec_id == AV_CODEC_ID_H264) {</p><p><code></code>st->need_parsing = AVSTREAM_PARSE_FULL;</p><p><code></code>}</p><p><code></code>// Create the parsers with the appropriate flags</p><p><code></code>init_parser(m_avFormat, st);</p><p><code></code>UpdateParserFlags(st);</p><p>#ifdef DEBUG</p><p><code></code>AVProgram *streamProg = av_find_program_from_stream(m_avFormat, NULL, idx);</p><p><code></code>DbgLog((LOG_TRACE, 30, L"Stream %d (pid %d) - program: %d, codec: %S; parsing: %S;", idx, st->id, streamProg ? streamProg->pmt_pid : -1, avcodec_get_name(st->codec->codec_id), lavf_get_parsing_string(st->need_parsing)));</p><p>#endif</p><p><code></code>m_stOrigParser[idx] = st->need_parsing;</p><p><code></code>if ((st->codec->codec_id == AV_CODEC_ID_DTS && st->codec->codec_tag == 0xA2)</p><p><code></code>|| (st->codec->codec_id == AV_CODEC_ID_EAC3 && st->codec->codec_tag == 0xA1))</p><p><code></code>st->disposition |= LAVF_DISPOSITION_SECONDARY_AUDIO;</p><p><code></code>UpdateSubStreams();</p><p><code></code>if (st->codec->codec_type == AVMEDIA_TYPE_ATTACHMENT && (st->codec->codec_id == AV_CODEC_ID_TTF || st->codec->codec_id == AV_CODEC_ID_OTF)) {</p><p><code></code>if (!m_pFontInstaller) {</p><p><code></code>m_pFontInstaller = new CFontInstaller();</p><p><code></code>}</p><p><code></code>m_pFontInstaller->InstallFont(st->codec->extradata, st->codec->extradata_size);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>CHECK_HR(hr = CreateStreams());</p><p><code></code>return S_OK;</p><p>done:</p><p><code></code>//关闭输入</p><p><code></code>CleanupAVFormat();</p><p><code></code>return E_FAIL;</p><p>}</p><p>该函数通过avformat_find_stream_info()等获取到流信息，这里就不多说了。</p><h3 id=lav-filter-源代码分析-3-lav-video-1httpblogcsdnnetleixiaohua1020articledetails13022201><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201><strong>LAV Filter 源代码分析 3： LAV Video （1）</strong></a></h3><p>LAV Video 是使用很广泛的DirectShow Filter。它封装了FFMPEG中的libavcodec，支持十分广泛的视频格式的解码。在这里对其源代码进行详细的分析。</p><p>LAV Video 工程代码的结构如下图所示</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.160.jpeg alt></p><p>直接看LAV Video最主要的类CLAVVideo吧，它的定义位于LAVVideo.h中。</p><p>LAVVideo.h</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>copy</a></p><p>/* 雷霄骅</p><p><code></code>* 中国传媒大学/数字电视技术</p><p><code></code>* <a href=mailto:leixiaohua1020@126.com>leixiaohua1020@126.com</a></p><p><code></code>*</p><p><code></code>*/</p><p>/*</p><p><code></code>* Copyright (C) 2010-2013 Hendrik Leppkes</p><p><code></code>* <a href=http://www.1f0.de>http://www.1f0.de</a></p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License along</p><p><code></code>* with this program; if not, write to the Free Software Foundation, Inc.,</p><p><code></code>* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p><p><code></code>*/</p><p>#pragma once</p><p>#include "decoders/ILAVDecoder.h"</p><p>#include "DecodeThread.h"</p><p>#include "ILAVPinInfo.h"</p><p>#include "LAVPixFmtConverter.h"</p><p>#include "LAVVideoSettings.h"</p><p>#include "H264RandomAccess.h"</p><p>#include "FloatingAverage.h"</p><p>#include "ISpecifyPropertyPages2.h"</p><p>#include "SynchronizedQueue.h"</p><p>#include "subtitles/LAVSubtitleConsumer.h"</p><p>#include "subtitles/LAVVideoSubtitleInputPin.h"</p><p>#include "BaseTrayIcon.h"</p><p>#define LAVC_VIDEO_REGISTRY_KEY L"Software\LAV\Video"</p><p>#define LAVC_VIDEO_REGISTRY_KEY_FORMATS L"Software\LAV\Video\Formats"</p><p>#define LAVC_VIDEO_REGISTRY_KEY_OUTPUT L"Software\LAV\Video\Output"</p><p>#define LAVC_VIDEO_REGISTRY_KEY_HWACCEL L"Software\LAV\Video\HWAccel"</p><p>#define LAVC_VIDEO_LOG_FILE L"LAVVideo.txt"</p><p>#define DEBUG_FRAME_TIMINGS 0</p><p>#define DEBUG_PIXELCONV_TIMINGS 0</p><p>#define LAV_MT_FILTER_QUEUE_SIZE 4</p><p>typedef struct {</p><p><code></code>REFERENCE_TIME rtStart;</p><p><code></code>REFERENCE_TIME rtStop;</p><p>} TimingCache;</p><p>//解码核心类</p><p>//Transform Filter</p><p>[uuid("EE30215D-164F-4A92-A4EB-9D4C13390F9F")]</p><p>class CLAVVideo : public CTransformFilter, public ISpecifyPropertyPages2, public ILAVVideoSettings, public ILAVVideoStatus, public ILAVVideoCallback</p><p>{</p><p>public:</p><p><code></code>CLAVVideo(LPUNKNOWN pUnk, HRESULT* phr);</p><p><code></code>~CLAVVideo();</p><p><code></code>static void CALLBACK StaticInit(BOOL bLoading, const CLSID *clsid);</p><p><code></code>// IUnknown</p><p><code></code>// 查找接口必须实现</p><p><code></code>DECLARE_IUNKNOWN;</p><p><code></code>STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);</p><p><code></code>// ISpecifyPropertyPages2</p><p><code></code>// 属性页</p><p><code></code>// 获取或者创建</p><p><code></code>STDMETHODIMP GetPages(CAUUID *pPages);</p><p><code></code>STDMETHODIMP CreatePage(const GUID& guid, IPropertyPage** ppPage);</p><p><code></code>// ILAVVideoSettings</p><p><code></code>STDMETHODIMP SetRuntimeConfig(BOOL bRuntimeConfig);</p><p><code></code>STDMETHODIMP SetFormatConfiguration(LAVVideoCodec vCodec, BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetFormatConfiguration(LAVVideoCodec vCodec);</p><p><code></code>STDMETHODIMP SetNumThreads(DWORD dwNum);</p><p><code></code>STDMETHODIMP_(DWORD) GetNumThreads();</p><p><code></code>STDMETHODIMP SetStreamAR(DWORD bStreamAR);</p><p><code></code>STDMETHODIMP_(DWORD) GetStreamAR();</p><p><code></code>STDMETHODIMP SetPixelFormat(LAVOutPixFmts pixFmt, BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetPixelFormat(LAVOutPixFmts pixFmt);</p><p><code></code>STDMETHODIMP SetRGBOutputRange(DWORD dwRange);</p><p><code></code>STDMETHODIMP_(DWORD) GetRGBOutputRange();</p><p><code></code>STDMETHODIMP SetDeintFieldOrder(LAVDeintFieldOrder fieldOrder);</p><p><code></code>STDMETHODIMP_(LAVDeintFieldOrder) GetDeintFieldOrder();</p><p><code></code>STDMETHODIMP SetDeintForce(BOOL bForce);</p><p><code></code>STDMETHODIMP_(BOOL) GetDeintForce();</p><p><code></code>STDMETHODIMP SetDeintAggressive(BOOL bAggressive);</p><p><code></code>STDMETHODIMP_(BOOL) GetDeintAggressive();</p><p><code></code>STDMETHODIMP_(DWORD) CheckHWAccelSupport(LAVHWAccel hwAccel);</p><p><code></code>STDMETHODIMP SetHWAccel(LAVHWAccel hwAccel);</p><p><code></code>STDMETHODIMP_(LAVHWAccel) GetHWAccel();</p><p><code></code>STDMETHODIMP SetHWAccelCodec(LAVVideoHWCodec hwAccelCodec, BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetHWAccelCodec(LAVVideoHWCodec hwAccelCodec);</p><p><code></code>STDMETHODIMP SetHWAccelDeintMode(LAVHWDeintModes deintMode);</p><p><code></code>STDMETHODIMP_(LAVHWDeintModes) GetHWAccelDeintMode();</p><p><code></code>STDMETHODIMP SetHWAccelDeintOutput(LAVDeintOutput deintOutput);</p><p><code></code>STDMETHODIMP_(LAVDeintOutput) GetHWAccelDeintOutput();</p><p><code></code>STDMETHODIMP SetHWAccelDeintHQ(BOOL bHQ);</p><p><code></code>STDMETHODIMP_(BOOL) GetHWAccelDeintHQ();</p><p><code></code>STDMETHODIMP SetSWDeintMode(LAVSWDeintModes deintMode);</p><p><code></code>STDMETHODIMP_(LAVSWDeintModes) GetSWDeintMode();</p><p><code></code>STDMETHODIMP SetSWDeintOutput(LAVDeintOutput deintOutput);</p><p><code></code>STDMETHODIMP_(LAVDeintOutput) GetSWDeintOutput();</p><p><code></code>STDMETHODIMP SetDeintTreatAsProgressive(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetDeintTreatAsProgressive();</p><p><code></code>STDMETHODIMP SetDitherMode(LAVDitherMode ditherMode);</p><p><code></code>STDMETHODIMP_(LAVDitherMode) GetDitherMode();</p><p><code></code>STDMETHODIMP SetUseMSWMV9Decoder(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetUseMSWMV9Decoder();</p><p><code></code>STDMETHODIMP SetDVDVideoSupport(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetDVDVideoSupport();</p><p><code></code>STDMETHODIMP SetHWAccelResolutionFlags(DWORD dwResFlags);</p><p><code></code>STDMETHODIMP_(DWORD) GetHWAccelResolutionFlags();</p><p><code></code>STDMETHODIMP SetTrayIcon(BOOL bEnabled);</p><p><code></code>STDMETHODIMP_(BOOL) GetTrayIcon();</p><p><code></code>STDMETHODIMP SetDeinterlacingMode(LAVDeintMode deintMode);</p><p><code></code>STDMETHODIMP_(LAVDeintMode) GetDeinterlacingMode();</p><p><code></code>// ILAVVideoStatus</p><p><code></code>STDMETHODIMP_(const WCHAR *) GetActiveDecoderName() { return m_Decoder.GetDecoderName(); }</p><p><code></code>// CTransformFilter</p><p><code></code>// 核心的</p><p><code></code>HRESULT CheckInputType(const CMediaType* mtIn);</p><p><code></code>HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);</p><p><code></code>HRESULT DecideBufferSize(IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pprop);</p><p><code></code>HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);</p><p><code></code>HRESULT SetMediaType(PIN_DIRECTION dir, const CMediaType *pmt);</p><p><code></code>HRESULT EndOfStream();</p><p><code></code>HRESULT BeginFlush();</p><p><code></code>HRESULT EndFlush();</p><p><code></code>HRESULT NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);</p><p><code></code>//处理的核心</p><p><code></code>//核心一般才有IMediaSample</p><p><code></code>HRESULT Receive(IMediaSample *pIn);</p><p><code></code>HRESULT CheckConnect(PIN_DIRECTION dir, IPin *pPin);</p><p><code></code>HRESULT BreakConnect(PIN_DIRECTION dir);</p><p><code></code>HRESULT CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin);</p><p><code></code>int GetPinCount();</p><p><code></code>CBasePin* GetPin(int n);</p><p><code></code>STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);</p><p><code></code>// ILAVVideoCallback</p><p><code></code>STDMETHODIMP AllocateFrame(LAVFrame **ppFrame);</p><p><code></code>STDMETHODIMP ReleaseFrame(LAVFrame **ppFrame);</p><p><code></code>STDMETHODIMP Deliver(LAVFrame *pFrame);</p><p><code></code>STDMETHODIMP_(LPWSTR) GetFileExtension();</p><p><code></code>STDMETHODIMP_(BOOL) FilterInGraph(PIN_DIRECTION dir, const GUID &clsid) { if (dir == PINDIR_INPUT) return FilterInGraphSafe(m_pInput, clsid); else return FilterInGraphSafe(m_pOutput, clsid); }</p><p><code></code>STDMETHODIMP_(DWORD) GetDecodeFlags() { return m_dwDecodeFlags; }</p><p><code></code>STDMETHODIMP_(CMediaType&) GetInputMediaType() { return m_pInput->CurrentMediaType(); }</p><p><code></code>STDMETHODIMP GetLAVPinInfo(LAVPinInfo &info) { if (m_LAVPinInfoValid) { info = m_LAVPinInfo; return S_OK; } return E_FAIL; }</p><p><code></code>STDMETHODIMP_(CBasePin*) GetOutputPin() { return m_pOutput; }</p><p><code></code>STDMETHODIMP_(CMediaType&) GetOutputMediaType() { return m_pOutput->CurrentMediaType(); }</p><p><code></code>STDMETHODIMP DVDStripPacket(BYTE*& p, long& len) { static_cast&lt;CDeCSSTransformInputPin*>(m_pInput)->StripPacket(p, len); return S_OK; }</p><p><code></code>STDMETHODIMP_(LAVFrame*) GetFlushFrame();</p><p><code></code>STDMETHODIMP ReleaseAllDXVAResources() { ReleaseLastSequenceFrame(); return S_OK; }</p><p>public:</p><p><code></code>// Pin Configuration</p><p><code></code>const static AMOVIESETUP_MEDIATYPE sudPinTypesIn[];</p><p><code></code>const static int sudPinTypesInCount;</p><p><code></code>const static AMOVIESETUP_MEDIATYPE sudPinTypesOut[];</p><p><code></code>const static int sudPinTypesOutCount;</p><p>private:</p><p><code></code>HRESULT LoadDefaults();</p><p><code></code>HRESULT ReadSettings(HKEY rootKey);</p><p><code></code>HRESULT LoadSettings();</p><p><code></code>HRESULT SaveSettings();</p><p><code></code>HRESULT CreateTrayIcon();</p><p><code></code>HRESULT CreateDecoder(const CMediaType *pmt);</p><p><code></code>HRESULT GetDeliveryBuffer(IMediaSample** ppOut, int width, int height, AVRational ar, DXVA2_ExtendedFormat dxvaExtFormat, REFERENCE_TIME avgFrameDuration);</p><p><code></code>HRESULT ReconnectOutput(int width, int height, AVRational ar, DXVA2_ExtendedFormat dxvaExtFlags, REFERENCE_TIME avgFrameDuration, BOOL bDXVA = FALSE);</p><p><code></code>HRESULT SetFrameFlags(IMediaSample* pMS, LAVFrame *pFrame);</p><p><code></code>HRESULT NegotiatePixelFormat(CMediaType &mt, int width, int height);</p><p><code></code>BOOL IsInterlaced();</p><p><code></code>HRESULT Filter(LAVFrame *pFrame);</p><p><code></code>HRESULT DeliverToRenderer(LAVFrame *pFrame);</p><p><code></code>HRESULT PerformFlush();</p><p><code></code>HRESULT ReleaseLastSequenceFrame();</p><p><code></code>HRESULT GetD3DBuffer(LAVFrame *pFrame);</p><p><code></code>HRESULT RedrawStillImage();</p><p><code></code>HRESULT SetInDVDMenu(bool menu) { m_bInDVDMenu = menu; return S_OK; }</p><p><code></code>enum {CNTRL_EXIT, CNTRL_REDRAW};</p><p><code></code>HRESULT ControlCmd(DWORD cmd) {</p><p><code></code>return m_ControlThread->CallWorker(cmd);</p><p><code></code>}</p><p>private:</p><p><code></code>friend class CVideoOutputPin;</p><p><code></code>friend class CDecodeThread;</p><p><code></code>friend class CLAVControlThread;</p><p><code></code>friend class CLAVSubtitleProvider;</p><p><code></code>friend class CLAVSubtitleConsumer;</p><p><code></code>//解码线程</p><p><code></code>CDecodeThread m_Decoder;</p><p><code></code>CAMThread *m_ControlThread;</p><p><code></code>REFERENCE_TIME m_rtPrevStart;</p><p><code></code>REFERENCE_TIME m_rtPrevStop;</p><p><code></code>BOOL m_bForceInputAR;</p><p><code></code>BOOL m_bSendMediaType;</p><p><code></code>BOOL m_bFlushing;</p><p><code></code>HRESULT m_hrDeliver;</p><p><code></code>CLAVPixFmtConverter m_PixFmtConverter;</p><p><code></code>std::wstring m_strExtension;</p><p><code></code>DWORD m_bDXVAExtFormatSupport;</p><p><code></code>DWORD m_bMadVR;</p><p><code></code>DWORD m_bOverlayMixer;</p><p><code></code>DWORD m_dwDecodeFlags;</p><p><code></code>BOOL m_bInDVDMenu;</p><p><code></code>AVFilterGraph *m_pFilterGraph;</p><p><code></code>AVFilterContext *m_pFilterBufferSrc;</p><p><code></code>AVFilterContext *m_pFilterBufferSink;</p><p><code></code>LAVPixelFormat m_filterPixFmt;</p><p><code></code>int m_filterWidth;</p><p><code></code>int m_filterHeight;</p><p><code></code>LAVFrame m_FilterPrevFrame;</p><p><code></code>BOOL m_LAVPinInfoValid;</p><p><code></code>LAVPinInfo m_LAVPinInfo;</p><p><code></code>CLAVVideoSubtitleInputPin *m_pSubtitleInput;</p><p><code></code>CLAVSubtitleConsumer *m_SubtitleConsumer;</p><p><code></code>LAVFrame *m_pLastSequenceFrame;</p><p><code></code>AM_SimpleRateChange m_DVDRate;</p><p><code></code>BOOL m_bRuntimeConfig;</p><p><code></code>struct VideoSettings {</p><p><code></code>BOOL TrayIcon;</p><p><code></code>DWORD StreamAR;</p><p><code></code>DWORD NumThreads;</p><p><code></code>BOOL bFormats[Codec_VideoNB];</p><p><code></code>BOOL bMSWMV9DMO;</p><p><code></code>BOOL bPixFmts[LAVOutPixFmt_NB];</p><p><code></code>DWORD RGBRange;</p><p><code></code>DWORD HWAccel;</p><p><code></code>BOOL bHWFormats[HWCodec_NB];</p><p><code></code>DWORD HWAccelResFlags;</p><p><code></code>DWORD HWDeintMode;</p><p><code></code>DWORD HWDeintOutput;</p><p><code></code>BOOL HWDeintHQ;</p><p><code></code>DWORD DeintFieldOrder;</p><p><code></code>LAVDeintMode DeintMode;</p><p><code></code>DWORD SWDeintMode;</p><p><code></code>DWORD SWDeintOutput;</p><p><code></code>DWORD DitherMode;</p><p><code></code>BOOL bDVDVideo;</p><p><code></code>} m_settings;</p><p><code></code>CBaseTrayIcon *m_pTrayIcon;</p><p>#ifdef DEBUG</p><p><code></code>FloatingAverage<double> m_pixFmtTimingAvg;</p><p>#endif</p><p>};</p><p>可见该类继承了CTransformFilter，其的功能真的是非常丰富的。在这里肯定无法对其进行一一分析，只能选择其中重点的函数进行一下分析。</p><p>该类中包含了解码线程类：CDecodeThread m_Decoder;，这里封装了解码功能。</p><p>同时该类中包含了函数Receive(IMediaSample *pIn);，是发挥解码功能的函数，其中pIn是输入的解码前的视频压缩编码数据。</p><p>下面来看看Receive()函数：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>copy</a></p><p>//处理的核心</p><p>//核心一般才有IMediaSample</p><p>HRESULT CLAVVideo::Receive(IMediaSample *pIn)</p><p>{</p><p><code></code>CAutoLock cAutoLock(&m_csReceive);</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>AM_SAMPLE2_PROPERTIES const *pProps = m_pInput->SampleProps();</p><p><code></code>if(pProps->dwStreamId != AM_STREAM_MEDIA) {</p><p><code></code>return m_pOutput->Deliver(pIn);</p><p><code></code>}</p><p><code></code>AM_MEDIA_TYPE *pmt = NULL;</p><p><code></code>//获取媒体类型等等</p><p><code></code>if (SUCCEEDED(pIn->GetMediaType(&pmt)) && pmt) {</p><p><code></code>CMediaType mt = *pmt;</p><p><code></code>DeleteMediaType(pmt);</p><p><code></code>if (mt != m_pInput->CurrentMediaType() || !(m_dwDecodeFlags & LAV_VIDEO_DEC_FLAG_DVD)) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"::Receive(): Input sample contained media type, dynamic format change..."));</p><p><code></code>m_Decoder.EndOfStream();</p><p><code></code>hr = m_pInput->SetMediaType(&mt);</p><p><code></code>if (FAILED(hr)) {</p><p><code></code>DbgLog((LOG_ERROR, 10, L"::Receive(): Setting new media type failed..."));</p><p><code></code>return hr;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>m_hrDeliver = S_OK;</p><p><code></code>// Skip over empty packets</p><p><code></code>if (pIn->GetActualDataLength() == 0) {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>//解码</p><p><code></code>hr = m_Decoder.Decode(pIn);</p><p><code></code>if (FAILED(hr))</p><p><code></code>return hr;</p><p><code></code>if (FAILED(m_hrDeliver))</p><p><code></code>return m_hrDeliver;</p><p><code></code>return S_OK;</p><p>}</p><p>由代码我们可以看出，实际发挥出解码功能的函数是hr = m_Decoder.Decode(pIn);。</p><p>下面我们来看看CDecodeThread类的Decode()方法：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>copy</a></p><p>//解码线程的解码函数</p><p>STDMETHODIMP CDecodeThread::Decode(IMediaSample *pSample)</p><p>{</p><p><code></code>CAutoLock decoderLock(this);</p><p><code></code>if (!CAMThread::ThreadExists())</p><p><code></code>return E_UNEXPECTED;</p><p><code></code>// Wait until the queue is empty</p><p><code></code>while(HasSample())</p><p><code></code>Sleep(1);</p><p><code></code>// Re-init the decoder, if requested</p><p><code></code>// Doing this inside the worker thread alone causes problems</p><p><code></code>// when switching from non-sync to sync, so ensure we're in sync.</p><p><code></code>if (m_bDecoderNeedsReInit) {</p><p><code></code>CAMThread::CallWorker(CMD_REINIT);</p><p><code></code>while (!m_evEOSDone.Check()) {</p><p><code></code>m_evSample.Wait();</p><p><code></code>ProcessOutput();</p><p><code></code>}</p><p><code></code>}</p><p><code></code>m_evDeliver.Reset();</p><p><code></code>m_evSample.Reset();</p><p><code></code>m_evDecodeDone.Reset();</p><p><code></code>pSample->AddRef();</p><p><code></code>// Send data to worker thread, and wake it (if it was waiting)</p><p><code></code>PutSample(pSample);</p><p><code></code>// If we don't have thread safe buffers, we need to synchronize</p><p><code></code>// with the worker thread and deliver them when they are available</p><p><code></code>// and then let it know that we did so</p><p><code></code>if (m_bSyncToProcess) {</p><p><code></code>while (!m_evDecodeDone.Check()) {</p><p><code></code>m_evSample.Wait();</p><p><code></code>ProcessOutput();</p><p><code></code>}</p><p><code></code>}</p><p><code></code>ProcessOutput();</p><p><code></code>return S_OK;</p><p>}</p><p>这个方法乍一看感觉很抽象，好像没看见直接调用任何解码的函数。如果LAVVideo的封装的ffmpeg的libavcodec的话，应该是最终调用avcodec_decode_video2()才对啊。。。先来看看CDecodeThread这个类的定义吧！</p><p>DecodeThread.h</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>copy</a></p><p>/* 雷霄骅</p><p><code></code>* 中国传媒大学/数字电视技术</p><p><code></code>* <a href=mailto:leixiaohua1020@126.com>leixiaohua1020@126.com</a></p><p><code></code>*</p><p><code></code>*/</p><p>/*</p><p><code></code>* Copyright (C) 2010-2013 Hendrik Leppkes</p><p><code></code>* <a href=http://www.1f0.de>http://www.1f0.de</a></p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License along</p><p><code></code>* with this program; if not, write to the Free Software Foundation, Inc.,</p><p><code></code>* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p><p><code></code>*/</p><p>#pragma once</p><p>#include "decoders/ILAVDecoder.h"</p><p>#include "SynchronizedQueue.h"</p><p>class CLAVVideo;</p><p>class CDecodeThread : public ILAVVideoCallback, protected CAMThread, protected CCritSec</p><p>{</p><p>public:</p><p><code></code>CDecodeThread(CLAVVideo *pLAVVideo);</p><p><code></code>~CDecodeThread();</p><p><code></code>// Parts of ILAVDecoder</p><p><code></code>STDMETHODIMP_(const WCHAR*) GetDecoderName() { return m_pDecoder ? m_pDecoder->GetDecoderName() : NULL; }</p><p><code></code>STDMETHODIMP_(long) GetBufferCount() { return m_pDecoder ? m_pDecoder->GetBufferCount() : 4; }</p><p><code></code>STDMETHODIMP_(BOOL) IsInterlaced() { return m_pDecoder ? m_pDecoder->IsInterlaced() : TRUE; }</p><p><code></code>STDMETHODIMP GetPixelFormat(LAVPixelFormat *pPix, int *pBpp) { ASSERT(m_pDecoder); return m_pDecoder->GetPixelFormat(pPix, pBpp); }</p><p><code></code>STDMETHODIMP_(REFERENCE_TIME) GetFrameDuration() { ASSERT(m_pDecoder); return m_pDecoder->GetFrameDuration(); }</p><p><code></code>STDMETHODIMP HasThreadSafeBuffers() { return m_pDecoder ? m_pDecoder->HasThreadSafeBuffers() : S_FALSE; }</p><p><code></code>STDMETHODIMP CreateDecoder(const CMediaType *pmt, AVCodecID codec);</p><p><code></code>STDMETHODIMP Close();</p><p><code></code>//解码线程的解码函数</p><p><code></code>STDMETHODIMP Decode(IMediaSample *pSample);</p><p><code></code>STDMETHODIMP Flush();</p><p><code></code>STDMETHODIMP EndOfStream();</p><p><code></code>STDMETHODIMP InitAllocator(IMemAllocator **ppAlloc);</p><p><code></code>STDMETHODIMP PostConnect(IPin *pPin);</p><p><code></code>STDMETHODIMP_(BOOL) IsHWDecoderActive() { return m_bHWDecoder; }</p><p><code></code>// ILAVVideoCallback</p><p><code></code>STDMETHODIMP AllocateFrame(LAVFrame **ppFrame);</p><p><code></code>STDMETHODIMP ReleaseFrame(LAVFrame **ppFrame);</p><p><code></code>STDMETHODIMP Deliver(LAVFrame *pFrame);</p><p><code></code>STDMETHODIMP_(LPWSTR) GetFileExtension();</p><p><code></code>STDMETHODIMP_(BOOL) FilterInGraph(PIN_DIRECTION dir, const GUID &clsid);</p><p><code></code>STDMETHODIMP_(DWORD) GetDecodeFlags();</p><p><code></code>STDMETHODIMP_(CMediaType&) GetInputMediaType();</p><p><code></code>STDMETHODIMP GetLAVPinInfo(LAVPinInfo &info);</p><p><code></code>STDMETHODIMP_(CBasePin*) GetOutputPin();</p><p><code></code>STDMETHODIMP_(CMediaType&) GetOutputMediaType();</p><p><code></code>STDMETHODIMP DVDStripPacket(BYTE*& p, long& len);</p><p><code></code>STDMETHODIMP_(LAVFrame*) GetFlushFrame();</p><p><code></code>STDMETHODIMP ReleaseAllDXVAResources();</p><p>protected:</p><p><code></code>//包含了对进程的各种操作，重要</p><p><code></code>DWORD ThreadProc();</p><p>private:</p><p><code></code>STDMETHODIMP CreateDecoderInternal(const CMediaType *pmt, AVCodecID codec);</p><p><code></code>STDMETHODIMP PostConnectInternal(IPin *pPin);</p><p><code></code>STDMETHODIMP DecodeInternal(IMediaSample *pSample);</p><p><code></code>STDMETHODIMP ClearQueues();</p><p><code></code>STDMETHODIMP ProcessOutput();</p><p><code></code>bool HasSample();</p><p><code></code>void PutSample(IMediaSample *pSample);</p><p><code></code>IMediaSample* GetSample();</p><p><code></code>void ReleaseSample();</p><p><code></code>bool CheckForEndOfSequence(IMediaSample *pSample);</p><p>private:</p><p>//各种对进程进行的操作</p><p><code></code>enum {CMD_CREATE_DECODER, CMD_CLOSE_DECODER, CMD_FLUSH, CMD_EOS, CMD_EXIT, CMD_INIT_ALLOCATOR, CMD_POST_CONNECT, CMD_REINIT};</p><p><code></code>//注意DecodeThread像是一个处于中间位置的东西</p><p><code></code>//连接了Filter核心类CLAVVideo和解码器的接口ILAVDecoder</p><p><code></code>CLAVVideo *m_pLAVVideo;</p><p><code></code>ILAVDecoder *m_pDecoder;</p><p><code></code>AVCodecID m_Codec;</p><p><code></code>BOOL m_bHWDecoder;</p><p><code></code>BOOL m_bHWDecoderFailed;</p><p><code></code>BOOL m_bSyncToProcess;</p><p><code></code>BOOL m_bDecoderNeedsReInit;</p><p><code></code>CAMEvent m_evInput;</p><p><code></code>CAMEvent m_evDeliver;</p><p><code></code>CAMEvent m_evSample;</p><p><code></code>CAMEvent m_evDecodeDone;</p><p><code></code>CAMEvent m_evEOSDone;</p><p><code></code>CCritSec m_ThreadCritSec;</p><p><code></code>struct {</p><p><code></code>const CMediaType *pmt;</p><p><code></code>AVCodecID codec;</p><p><code></code>IMemAllocator **allocator;</p><p><code></code>IPin *pin;</p><p><code></code>} m_ThreadCallContext;</p><p><code></code>CSynchronizedQueue&lt;LAVFrame *> m_Output;</p><p><code></code>CCritSec m_SampleCritSec;</p><p><code></code>IMediaSample *m_NextSample;</p><p><code></code>IMediaSample *m_TempSample[2];</p><p><code></code>IMediaSample *m_FailedSample;</p><p><code></code>std::wstring m_processName;</p><p>};</p><p>从名字上我们可以判断，这个类用于管理解码的线程。在这里我们关注该类里面的两个指针变量： CLAVVideo *m_pLAVVideo;</p><p><code></code>ILAVDecoder *m_pDecoder;</p><p>其中第一个指针变量就是这个工程中最核心的类CLAVVideo，而第二个指针变量则是解码器的接口。通过这个接口就可以调用具体解码器的相应方法了。（注：在源代码中发现，解码器不光包含libavcodec，也可以是wmv9等等，换句话说，是可以扩展其他种类的解码器的。不过就目前的情况来看，lavvideo似乎不如ffdshow支持的解码器种类多）</p><p>该类里面还有一个函数：</p><p>ThreadProc()</p><p>该函数中包含了对线程的各种操作，其中包含调用了ILAVDecoder接口的各种方法：</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13022201#>copy</a></p><p>//包含了对进程的各种操作</p><p>DWORD CDecodeThread::ThreadProc()</p><p>{</p><p><code></code>HRESULT hr;</p><p><code></code>DWORD cmd;</p><p><code></code>BOOL bEOS = FALSE;</p><p><code></code>BOOL bReinit = FALSE;</p><p><code></code>SetThreadName(-1, "LAVVideo Decode Thread");</p><p><code></code>HANDLE hWaitEvents[2] = { GetRequestHandle(), m_evInput };</p><p><code></code>//不停转圈，永不休止</p><p><code></code>while(1) {</p><p><code></code>if (!bEOS && !bReinit) {</p><p><code></code>// Wait for either an input sample, or an request</p><p><code></code>WaitForMultipleObjects(2, hWaitEvents, FALSE, INFINITE);</p><p><code></code>}</p><p><code></code>//根据操作命令的不同</p><p><code></code>if (CheckRequest(&cmd)) {</p><p><code></code>switch (cmd) {</p><p><code></code>//创建解码器</p><p><code></code>case CMD_CREATE_DECODER:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>//创建</p><p><code></code>hr = CreateDecoderInternal(m_ThreadCallContext.pmt, m_ThreadCallContext.codec);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.pmt = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_CLOSE_DECODER:</p><p><code></code>{</p><p><code></code>//关闭</p><p><code></code>ClearQueues();</p><p><code></code>SAFE_DELETE(m_pDecoder);</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_FLUSH:</p><p><code></code>{</p><p><code></code>//清楚</p><p><code></code>ClearQueues();</p><p><code></code>m_pDecoder->Flush();</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_EOS:</p><p><code></code>{</p><p><code></code>bEOS = TRUE;</p><p><code></code>m_evEOSDone.Reset();</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_EXIT:</p><p><code></code>{</p><p><code></code>//退出</p><p><code></code>Reply(S_OK);</p><p><code></code>return 0;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_INIT_ALLOCATOR:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>hr = m_pDecoder->InitAllocator(m_ThreadCallContext.allocator);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.allocator = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_POST_CONNECT:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>hr = PostConnectInternal(m_ThreadCallContext.pin);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.pin = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_REINIT:</p><p><code></code>{</p><p><code></code>//重启</p><p><code></code>CMediaType &mt = m_pLAVVideo->GetInputMediaType();</p><p><code></code>CreateDecoderInternal(&mt, m_Codec);</p><p><code></code>m_TempSample[1] = m_NextSample;</p><p><code></code>m_NextSample = m_FailedSample;</p><p><code></code>m_FailedSample = NULL;</p><p><code></code>bReinit = TRUE;</p><p><code></code>m_evEOSDone.Reset();</p><p><code></code>Reply(S_OK);</p><p><code></code>m_bDecoderNeedsReInit = FALSE;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>ASSERT(0);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (m_bDecoderNeedsReInit) {</p><p><code></code>m_evInput.Reset();</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>if (bReinit && !m_NextSample) {</p><p><code></code>if (m_TempSample[0]) {</p><p><code></code>m_NextSample = m_TempSample[0];</p><p><code></code>m_TempSample[0] = NULL;</p><p><code></code>} else if (m_TempSample[1]) {</p><p><code></code>m_NextSample = m_TempSample[1];</p><p><code></code>m_TempSample[1] = NULL;</p><p><code></code>} else {</p><p><code></code>bReinit = FALSE;</p><p><code></code>m_evEOSDone.Set();</p><p><code></code>m_evSample.Set();</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//获得一份数据</p><p><code></code>IMediaSample *pSample = GetSample();</p><p><code></code>if (!pSample) {</p><p><code></code>// Process the EOS now that the sample queue is empty</p><p><code></code>if (bEOS) {</p><p><code></code>bEOS = FALSE;</p><p><code></code>m_pDecoder->EndOfStream();</p><p><code></code>m_evEOSDone.Set();</p><p><code></code>m_evSample.Set();</p><p><code></code>}</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>//解码</p><p><code></code>DecodeInternal(pSample);</p><p><code></code>// Release the sample</p><p><code></code>//释放</p><p><code></code>SafeRelease(&pSample);</p><p><code></code>// Indicates we're done decoding this sample</p><p><code></code>m_evDecodeDone.Set();</p><p><code></code>// Set the Sample Event to unblock any waiting threads</p><p><code></code>m_evSample.Set();</p><p><code></code>}</p><p><code></code>return 0;</p><p>}</p><p>先分析到这里了，至于ILAVDecoder接口方面的东西下篇文章再写。</p><h3 id=lav-filter-源代码分析-4-lav-video-2httpblogcsdnnetleixiaohua1020articledetails13272409><a href=http://blog.csdn.net/leixiaohua1020/article/details/13272409><strong>LAV Filter 源代码分析 4： LAV Video （2）</strong></a></h3><p>文章中提到LAVVideo主要通过CDecodeThread这个类进行解码线程的管理，其中有一个关键的管理函数：ThreadProc()，包含了对解码线程的各种操作。函数如下所示：</p><p>//包含了对进程的各种操作</p><p>DWORD CDecodeThread::ThreadProc()</p><p>{</p><p><code></code>HRESULT hr;</p><p><code></code>DWORD cmd;</p><p><code></code>BOOL bEOS = FALSE;</p><p><code></code>BOOL bReinit = FALSE;</p><p><code></code>SetThreadName(-1, "LAVVideo Decode Thread");</p><p><code></code>HANDLE hWaitEvents[2] = { GetRequestHandle(), m_evInput };</p><p><code></code>//不停转圈，永不休止</p><p><code></code>while(1) {</p><p><code></code>if (!bEOS && !bReinit) {</p><p><code></code>// Wait for either an input sample, or an request</p><p><code></code>WaitForMultipleObjects(2, hWaitEvents, FALSE, INFINITE);</p><p><code></code>}</p><p><code></code>//根据操作命令的不同</p><p><code></code>if (CheckRequest(&cmd)) {</p><p><code></code>switch (cmd) {</p><p><code></code>//创建解码器</p><p><code></code>case CMD_CREATE_DECODER:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>//创建</p><p><code></code>hr = CreateDecoderInternal(m_ThreadCallContext.pmt, m_ThreadCallContext.codec);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.pmt = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_CLOSE_DECODER:</p><p><code></code>{</p><p><code></code>//关闭</p><p><code></code>ClearQueues();</p><p><code></code>SAFE_DELETE(m_pDecoder);</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_FLUSH:</p><p><code></code>{</p><p><code></code>//清楚</p><p><code></code>ClearQueues();</p><p><code></code>m_pDecoder->Flush();</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_EOS:</p><p><code></code>{</p><p><code></code>bEOS = TRUE;</p><p><code></code>m_evEOSDone.Reset();</p><p><code></code>Reply(S_OK);</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_EXIT:</p><p><code></code>{</p><p><code></code>//退出</p><p><code></code>Reply(S_OK);</p><p><code></code>return 0;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_INIT_ALLOCATOR:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>hr = m_pDecoder->InitAllocator(m_ThreadCallContext.allocator);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.allocator = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_POST_CONNECT:</p><p><code></code>{</p><p><code></code>CAutoLock lock(&m_ThreadCritSec);</p><p><code></code>hr = PostConnectInternal(m_ThreadCallContext.pin);</p><p><code></code>Reply(hr);</p><p><code></code>m_ThreadCallContext.pin = NULL;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>case CMD_REINIT:</p><p><code></code>{</p><p><code></code>//重启</p><p><code></code>CMediaType &mt = m_pLAVVideo->GetInputMediaType();</p><p><code></code>CreateDecoderInternal(&mt, m_Codec);</p><p><code></code>m_TempSample[1] = m_NextSample;</p><p><code></code>m_NextSample = m_FailedSample;</p><p><code></code>m_FailedSample = NULL;</p><p><code></code>bReinit = TRUE;</p><p><code></code>m_evEOSDone.Reset();</p><p><code></code>Reply(S_OK);</p><p><code></code>m_bDecoderNeedsReInit = FALSE;</p><p><code></code>}</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>ASSERT(0);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (m_bDecoderNeedsReInit) {</p><p><code></code>m_evInput.Reset();</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>if (bReinit && !m_NextSample) {</p><p><code></code>if (m_TempSample[0]) {</p><p><code></code>m_NextSample = m_TempSample[0];</p><p><code></code>m_TempSample[0] = NULL;</p><p><code></code>} else if (m_TempSample[1]) {</p><p><code></code>m_NextSample = m_TempSample[1];</p><p><code></code>m_TempSample[1] = NULL;</p><p><code></code>} else {</p><p><code></code>bReinit = FALSE;</p><p><code></code>m_evEOSDone.Set();</p><p><code></code>m_evSample.Set();</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//获得一份数据</p><p><code></code>IMediaSample *pSample = GetSample();</p><p><code></code>if (!pSample) {</p><p><code></code>// Process the EOS now that the sample queue is empty</p><p><code></code>if (bEOS) {</p><p><code></code>bEOS = FALSE;</p><p><code></code>m_pDecoder->EndOfStream();</p><p><code></code>m_evEOSDone.Set();</p><p><code></code>m_evSample.Set();</p><p><code></code>}</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>//解码</p><p><code></code>DecodeInternal(pSample);</p><p><code></code>// Release the sample</p><p><code></code>//释放</p><p><code></code>SafeRelease(&pSample);</p><p><code></code>// Indicates we're done decoding this sample</p><p><code></code>m_evDecodeDone.Set();</p><p><code></code>// Set the Sample Event to unblock any waiting threads</p><p><code></code>m_evSample.Set();</p><p><code></code>}</p><p><code></code>return 0;</p><p>}</p><p>该函数中，DecodeInternal(pSample)为实际上真正具有解码功能的函数，来看看它的源代码吧：</p><p>STDMETHODIMP CDecodeThread::DecodeInternal(IMediaSample *pSample)</p><p>{</p><p><code></code>HRESULT hr = S_OK;</p><p><code></code>if (!m_pDecoder)</p><p><code></code>return E_UNEXPECTED;</p><p><code></code>//调用接口进行解码</p><p><code></code>hr = m_pDecoder->Decode(pSample);</p><p><code></code>// If a hardware decoder indicates a hard failure, we switch back to software</p><p><code></code>// This is used to indicate incompatible media</p><p><code></code>if (FAILED(hr) && m_bHWDecoder) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"::Receive(): Hardware decoder indicates failure, switching back to software"));</p><p><code></code>m_bHWDecoderFailed = TRUE;</p><p><code></code>// Store the failed sample for re-try in a moment</p><p><code></code>m_FailedSample = pSample;</p><p><code></code>m_FailedSample->AddRef();</p><p><code></code>// Schedule a re-init when the main thread goes there the next time</p><p><code></code>m_bDecoderNeedsReInit = TRUE;</p><p><code></code>// Make room in the sample buffer, to ensure the main thread can get in</p><p><code></code>m_TempSample[0] = GetSample();</p><p><code></code>}</p><p><code></code>return S_OK;</p><p>}</p><p>该函数比较简短，从源代码中可以看出，调用了m_pDecoder的Decode()方法。其中m_pDecoder为ILAVDecoder类型的指针，而ILAVDecoder是一个接口，并不包含实际的方法，如下所示。注意，从程序注释中可以看出，每一个解码器都需要实现该接口规定的函数。</p><p>//接口</p><p>interface ILAVDecoder</p><p>{</p><p><code></code>/**</p><p><code></code>* Virtual destructor</p><p><code></code>*/</p><p><code></code>virtual ~ILAVDecoder(void) {};</p><p><code></code>/**</p><p><code></code>* Initialize interfaces with the LAV Video core</p><p><code></code>* This function should also be used to create all interfaces with external DLLs</p><p><code></code>*</p><p><code></code>* @param pSettings reference to the settings interface</p><p><code></code>* @param pCallback reference to the callback interface</p><p><code></code>* @return S_OK on success, error code if this decoder is lacking an external support dll</p><p><code></code>*/</p><p><code></code>STDMETHOD(InitInterfaces)(ILAVVideoSettings *pSettings, ILAVVideoCallback *pCallback) PURE;</p><p><code></code>/**</p><p><code></code>* Check if the decoder is functional</p><p><code></code>*/</p><p><code></code>STDMETHOD(Check)() PURE;</p><p><code></code>/**</p><p><code></code>* Initialize the codec to decode a stream specified by codec and pmt.</p><p><code></code>*</p><p><code></code>* @param codec Codec Id</p><p><code></code>* @param pmt DirectShow Media Type</p><p><code></code>* @return S_OK on success, an error code otherwise</p><p><code></code>*/</p><p><code></code>STDMETHOD(InitDecoder)(AVCodecID codec, const CMediaType *pmt) PURE;</p><p><code></code>/**</p><p><code></code>* Decode a frame.</p><p><code></code>*</p><p><code></code>* @param pSample Media Sample to decode</p><p><code></code>* @return S_OK if decoding was successfull, S_FALSE if no frame could be extracted, an error code if the decoder is not compatible with the bitstream</p><p><code></code>*</p><p><code></code>* Note: When returning an actual error code, the filter will switch to the fallback software decoder! This should only be used for catastrophic failures,</p><p><code></code>* like trying to decode a unsupported format on a hardware decoder.</p><p><code></code>*/</p><p><code></code>STDMETHOD(Decode)(IMediaSample *pSample) PURE;</p><p><code></code>/**</p><p><code></code>* Flush the decoder after a seek.</p><p><code></code>* The decoder should discard any remaining data.</p><p><code></code>*</p><p><code></code>* @return unused</p><p><code></code>*/</p><p><code></code>STDMETHOD(Flush)() PURE;</p><p><code></code>/**</p><p><code></code>* End of Stream</p><p><code></code>* The decoder is asked to output any buffered frames for immediate delivery</p><p><code></code>*</p><p><code></code>* @return unused</p><p><code></code>*/</p><p><code></code>STDMETHOD(EndOfStream)() PURE;</p><p><code></code>/**</p><p><code></code>* Query the decoder for the current pixel format</p><p><code></code>* Mostly used by the media type creation logic before playback starts</p><p><code></code>*</p><p><code></code>* @return the pixel format used in the decoding process</p><p><code></code>*/</p><p><code></code>STDMETHOD(GetPixelFormat)(LAVPixelFormat *pPix, int *pBpp) PURE;</p><p><code></code>/**</p><p><code></code>* Get the frame duration.</p><p><code></code>*</p><p><code></code>* This function is not mandatory, and if you cannot provide any specific duration, return 0.</p><p><code></code>*/</p><p><code></code>STDMETHOD_(REFERENCE_TIME, GetFrameDuration)() PURE;</p><p><code></code>/**</p><p><code></code>* Query whether the format can potentially be interlaced.</p><p><code></code>* This function should return false if the format can 100% not be interlaced, and true if it can be interlaced (but also progressive).</p><p><code></code>*/</p><p><code></code>STDMETHOD_(BOOL, IsInterlaced)() PURE;</p><p><code></code>/**</p><p><code></code>* Allows the decoder to handle an allocator.</p><p><code></code>* Used by DXVA2 decoding</p><p><code></code>*/</p><p><code></code>STDMETHOD(InitAllocator)(IMemAllocator **ppAlloc) PURE;</p><p><code></code>/**</p><p><code></code>* Function called after connection is established, with the pin as argument</p><p><code></code>*/</p><p><code></code>STDMETHOD(PostConnect)(IPin *pPin) PURE;</p><p><code></code>/**</p><p><code></code>* Get the number of sample buffers optimal for this decoder</p><p><code></code>*/</p><p><code></code>STDMETHOD_(long, GetBufferCount)() PURE;</p><p><code></code>/**</p><p><code></code>* Get the name of the decoder</p><p><code></code>*/</p><p><code></code>STDMETHOD_(const WCHAR*, GetDecoderName)() PURE;</p><p><code></code>/**</p><p><code></code>* Get whether the decoder outputs thread-safe buffers</p><p><code></code>*/</p><p><code></code>STDMETHOD(HasThreadSafeBuffers)() PURE;</p><p><code></code>/**</p><p><code></code>* Get whether the decoder should sync to the main thread</p><p><code></code>*/</p><p><code></code>STDMETHOD(SyncToProcessThread)() PURE;</p><p>};</p><p>下面来看看封装libavcodec库的类吧，该类的定义位于decoders文件夹下，名为avcodec.h，如图所示：<img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.161.jpeg alt></p><p>该类名字叫CDecAvcodec，其继承了CDecBase。而CDecBase继承了ILAVDecoder。</p><p>/*</p><p><code></code>* Copyright (C) 2010-2013 Hendrik Leppkes</p><p><code></code>* <a href=http://www.1f0.de>http://www.1f0.de</a></p><p><code></code>*</p><p><code></code>* This program is free software; you can redistribute it and/or modify</p><p><code></code>* it under the terms of the GNU General Public License as published by</p><p><code></code>* the Free Software Foundation; either version 2 of the License, or</p><p><code></code>* (at your option) any later version.</p><p><code></code>*</p><p><code></code>* This program is distributed in the hope that it will be useful,</p><p><code></code>* but WITHOUT ANY WARRANTY; without even the implied warranty of</p><p><code></code>* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p><p><code></code>* GNU General Public License for more details.</p><p><code></code>*</p><p><code></code>* You should have received a copy of the GNU General Public License along</p><p><code></code>* with this program; if not, write to the Free Software Foundation, Inc.,</p><p><code></code>* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p><p><code></code>*/</p><p>#pragma once</p><p>#include "DecBase.h"</p><p>#include "H264RandomAccess.h"</p><p>#include <map></p><p>#define AVCODEC_MAX_THREADS 16</p><p>typedef struct {</p><p><code></code>REFERENCE_TIME rtStart;</p><p><code></code>REFERENCE_TIME rtStop;</p><p>} TimingCache;</p><p>//解码器（AVCODEC）（其实还有WMV9，CUVID等）</p><p>class CDecAvcodec : public CDecBase</p><p>{</p><p>public:</p><p><code></code>CDecAvcodec(void);</p><p><code></code>virtual ~CDecAvcodec(void);</p><p><code></code>// ILAVDecoder</p><p><code></code>STDMETHODIMP InitDecoder(AVCodecID codec, const CMediaType *pmt);</p><p><code></code>//解码</p><p><code></code>STDMETHODIMP Decode(const BYTE *buffer, int buflen, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL bSyncPoint, BOOL bDiscontinuity);</p><p><code></code>STDMETHODIMP Flush();</p><p><code></code>STDMETHODIMP EndOfStream();</p><p><code></code>STDMETHODIMP GetPixelFormat(LAVPixelFormat *pPix, int *pBpp);</p><p><code></code>STDMETHODIMP_(REFERENCE_TIME) GetFrameDuration();</p><p><code></code>STDMETHODIMP_(BOOL) IsInterlaced();</p><p><code></code>STDMETHODIMP_(const WCHAR*) GetDecoderName() { return L"avcodec"; }</p><p><code></code>STDMETHODIMP HasThreadSafeBuffers() { return S_OK; }</p><p><code></code>STDMETHODIMP SyncToProcessThread() { return m_pAVCtx && m_pAVCtx->thread_count > 1 ? S_OK : S_FALSE; }</p><p><code></code>// CDecBase</p><p><code></code>STDMETHODIMP Init();</p><p>protected:</p><p><code></code>virtual HRESULT AdditionaDecoderInit() { return S_FALSE; }</p><p><code></code>virtual HRESULT PostDecode() { return S_FALSE; }</p><p><code></code>virtual HRESULT HandleDXVA2Frame(LAVFrame *pFrame) { return S_FALSE; }</p><p><code></code>//销毁解码器，各种Free</p><p><code></code>STDMETHODIMP DestroyDecoder();</p><p>private:</p><p><code></code>STDMETHODIMP ConvertPixFmt(AVFrame *pFrame, LAVFrame *pOutFrame);</p><p>protected:</p><p><code></code>AVCodecContext *m_pAVCtx;</p><p><code></code>AVFrame *m_pFrame;</p><p><code></code>AVCodecID m_nCodecId;</p><p><code></code>BOOL m_bDXVA;</p><p>private:</p><p><code></code>AVCodec *m_pAVCodec;</p><p><code></code>AVCodecParserContext *m_pParser;</p><p><code></code>BYTE *m_pFFBuffer;</p><p><code></code>BYTE *m_pFFBuffer2;</p><p><code></code>int m_nFFBufferSize;</p><p><code></code>int m_nFFBufferSize2;</p><p><code></code>SwsContext *m_pSwsContext;</p><p><code></code>CH264RandomAccess m_h264RandomAccess;</p><p><code></code>BOOL m_bNoBufferConsumption;</p><p><code></code>BOOL m_bHasPalette;</p><p><code></code>// Timing settings</p><p><code></code>BOOL m_bFFReordering;</p><p><code></code>BOOL m_bCalculateStopTime;</p><p><code></code>BOOL m_bRVDropBFrameTimings;</p><p><code></code>BOOL m_bInputPadded;</p><p><code></code>BOOL m_bBFrameDelay;</p><p><code></code>TimingCache m_tcBFrameDelay[2];</p><p><code></code>int m_nBFramePos;</p><p><code></code>TimingCache m_tcThreadBuffer[AVCODEC_MAX_THREADS];</p><p><code></code>int m_CurrentThread;</p><p><code></code>REFERENCE_TIME m_rtStartCache;</p><p><code></code>BOOL m_bResumeAtKeyFrame;</p><p><code></code>BOOL m_bWaitingForKeyFrame;</p><p><code></code>int m_iInterlaced;</p><p>};</p><p>从CDecAvcodec类的定义可以看出，包含了各种功能的函数。首先我们看看初始化函数Init()</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13272409#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13272409#>copy</a></p><p>// ILAVDecoder</p><p>STDMETHODIMP CDecAvcodec::Init()</p><p>{</p><p>#ifdef DEBUG</p><p><code></code>DbgSetModuleLevel (LOG_CUSTOM1, DWORD_MAX); // FFMPEG messages use custom1</p><p><code></code>av_log_set_callback(lavf_log_callback);</p><p>#else</p><p><code></code>av_log_set_callback(NULL);</p><p>#endif</p><p><code></code>//注册</p><p><code></code>avcodec_register_all();</p><p><code></code>return S_OK;</p><p>}</p><p>可见其调用了ffmpeg的API函数avcodec_register_all()进行了解码器的注册。</p><p>我们再来看看其解码函数Decode()：</p><p>//解码</p><p>STDMETHODIMP CDecAvcodec::Decode(const BYTE *buffer, int buflen, REFERENCE_TIME rtStartIn, REFERENCE_TIME rtStopIn, BOOL bSyncPoint, BOOL bDiscontinuity)</p><p>{</p><p><code></code>int got_picture = 0;</p><p><code></code>int used_bytes = 0;</p><p><code></code>BOOL bParserFrame = FALSE;</p><p><code></code>BOOL bFlush = (buffer == NULL);</p><p><code></code>BOOL bEndOfSequence = FALSE;</p><p><code></code>//初始化Packet</p><p><code></code>AVPacket avpkt;</p><p><code></code>av_init_packet(&avpkt);</p><p><code></code>if (m_pAVCtx->active_thread_type & FF_THREAD_FRAME) {</p><p><code></code>if (!m_bFFReordering) {</p><p><code></code>m_tcThreadBuffer[m_CurrentThread].rtStart = rtStartIn;</p><p><code></code>m_tcThreadBuffer[m_CurrentThread].rtStop = rtStopIn;</p><p><code></code>}</p><p><code></code>m_CurrentThread = (m_CurrentThread + 1) % m_pAVCtx->thread_count;</p><p><code></code>} else if (m_bBFrameDelay) {</p><p><code></code>m_tcBFrameDelay[m_nBFramePos].rtStart = rtStartIn;</p><p><code></code>m_tcBFrameDelay[m_nBFramePos].rtStop = rtStopIn;</p><p><code></code>m_nBFramePos = !m_nBFramePos;</p><p><code></code>}</p><p><code></code>uint8_t *pDataBuffer = NULL;</p><p><code></code>if (!bFlush && buflen > 0) {</p><p><code></code>if (!m_bInputPadded && (!(m_pAVCtx->active_thread_type & FF_THREAD_FRAME) || m_pParser)) {</p><p><code></code>// Copy bitstream into temporary buffer to ensure overread protection</p><p><code></code>// Verify buffer size</p><p><code></code>if (buflen > m_nFFBufferSize) {</p><p><code></code>m_nFFBufferSize = buflen;</p><p><code></code>m_pFFBuffer = (BYTE *)av_realloc_f(m_pFFBuffer, m_nFFBufferSize + FF_INPUT_BUFFER_PADDING_SIZE, 1);</p><p><code></code>if (!m_pFFBuffer) {</p><p><code></code>m_nFFBufferSize = 0;</p><p><code></code>return E_OUTOFMEMORY;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>memcpy(m_pFFBuffer, buffer, buflen);</p><p><code></code>memset(m_pFFBuffer+buflen, 0, FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>pDataBuffer = m_pFFBuffer;</p><p><code></code>} else {</p><p><code></code>pDataBuffer = (uint8_t *)buffer;</p><p><code></code>}</p><p><code></code>if (m_nCodecId == AV_CODEC_ID_H264) {</p><p><code></code>BOOL bRecovered = m_h264RandomAccess.searchRecoveryPoint(pDataBuffer, buflen);</p><p><code></code>if (!bRecovered) {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>} else if (m_nCodecId == AV_CODEC_ID_VP8 && m_bWaitingForKeyFrame) {</p><p><code></code>if (!(pDataBuffer[0] & 1)) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"::Decode(): Found VP8 key-frame, resuming decoding"));</p><p><code></code>m_bWaitingForKeyFrame = FALSE;</p><p><code></code>} else {</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>while (buflen > 0 || bFlush) {</p><p><code></code>REFERENCE_TIME rtStart = rtStartIn, rtStop = rtStopIn;</p><p><code></code>if (!bFlush) {</p><p><code></code>//设置AVPacket中的数据</p><p><code></code>avpkt.data = pDataBuffer;</p><p><code></code>avpkt.size = buflen;</p><p><code></code>avpkt.pts = rtStartIn;</p><p><code></code>if (rtStartIn != AV_NOPTS_VALUE && rtStopIn != AV_NOPTS_VALUE)</p><p><code></code>avpkt.duration = (int)(rtStopIn - rtStartIn);</p><p><code></code>else</p><p><code></code>avpkt.duration = 0;</p><p><code></code>avpkt.flags = AV_PKT_FLAG_KEY;</p><p><code></code>if (m_bHasPalette) {</p><p><code></code>m_bHasPalette = FALSE;</p><p><code></code>uint32_t *pal = (uint32_t *)av_packet_new_side_data(&avpkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);</p><p><code></code>int pal_size = FFMIN((1 &lt;&lt; m_pAVCtx->bits_per_coded_sample) &lt;&lt; 2, m_pAVCtx->extradata_size);</p><p><code></code>uint8_t *pal_src = m_pAVCtx->extradata + m_pAVCtx->extradata_size - pal_size;</p><p><code></code>for (int i = 0; i &lt; pal_size/4; i++)</p><p><code></code>pal[i] = 0xFF&lt;&lt;24 | AV_RL32(pal_src+4*i);</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>avpkt.data = NULL;</p><p><code></code>avpkt.size = 0;</p><p><code></code>}</p><p><code></code>// Parse the data if a parser is present</p><p><code></code>// This is mandatory for MPEG-1/2</p><p><code></code>// 不一定需要</p><p><code></code>if (m_pParser) {</p><p><code></code>BYTE *pOut = NULL;</p><p><code></code>int pOut_size = 0;</p><p><code></code>used_bytes = av_parser_parse2(m_pParser, m_pAVCtx, &pOut, &pOut_size, avpkt.data, avpkt.size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);</p><p><code></code>if (used_bytes == 0 && pOut_size == 0 && !bFlush) {</p><p><code></code>DbgLog((LOG_TRACE, 50, L"::Decode() - could not process buffer, starving?"));</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>// Update start time cache</p><p><code></code>// If more data was read then output, update the cache (incomplete frame)</p><p><code></code>// If output is bigger, a frame was completed, update the actual rtStart with the cached value, and then overwrite the cache</p><p><code></code>if (used_bytes > pOut_size) {</p><p><code></code>if (rtStartIn != AV_NOPTS_VALUE)</p><p><code></code>m_rtStartCache = rtStartIn;</p><p><code></code>} else if (used_bytes == pOut_size || ((used_bytes + 9) == pOut_size)) {</p><p><code></code>// Why +9 above?</p><p><code></code>// Well, apparently there are some broken MKV muxers that like to mux the MPEG-2 PICTURE_START_CODE block (which is 9 bytes) in the package with the previous frame</p><p><code></code>// This would cause the frame timestamps to be delayed by one frame exactly, and cause timestamp reordering to go wrong.</p><p><code></code>// So instead of failing on those samples, lets just assume that 9 bytes are that case exactly.</p><p><code></code>m_rtStartCache = rtStartIn = AV_NOPTS_VALUE;</p><p><code></code>} else if (pOut_size > used_bytes) {</p><p><code></code>rtStart = m_rtStartCache;</p><p><code></code>m_rtStartCache = rtStartIn;</p><p><code></code>// The value was used once, don't use it for multiple frames, that ends up in weird timings</p><p><code></code>rtStartIn = AV_NOPTS_VALUE;</p><p><code></code>}</p><p><code></code>bParserFrame = (pOut_size > 0);</p><p><code></code>if (pOut_size > 0 || bFlush) {</p><p><code></code>if (pOut && pOut_size > 0) {</p><p><code></code>if (pOut_size > m_nFFBufferSize2) {</p><p><code></code>m_nFFBufferSize2 = pOut_size;</p><p><code></code>m_pFFBuffer2 = (BYTE *)av_realloc_f(m_pFFBuffer2, m_nFFBufferSize2 + FF_INPUT_BUFFER_PADDING_SIZE, 1);</p><p><code></code>if (!m_pFFBuffer2) {</p><p><code></code>m_nFFBufferSize2 = 0;</p><p><code></code>return E_OUTOFMEMORY;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>memcpy(m_pFFBuffer2, pOut, pOut_size);</p><p><code></code>memset(m_pFFBuffer2+pOut_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>avpkt.data = m_pFFBuffer2;</p><p><code></code>avpkt.size = pOut_size;</p><p><code></code>avpkt.pts = rtStart;</p><p><code></code>avpkt.duration = 0;</p><p><code></code>const uint8_t *eosmarker = CheckForEndOfSequence(m_nCodecId, avpkt.data, avpkt.size, &m_MpegParserState);</p><p><code></code>if (eosmarker) {</p><p><code></code>bEndOfSequence = TRUE;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>avpkt.data = NULL;</p><p><code></code>avpkt.size = 0;</p><p><code></code>}</p><p><code></code>//真正的解码</p><p><code></code>int ret2 = avcodec_decode_video2 (m_pAVCtx, m_pFrame, &got_picture, &avpkt);</p><p><code></code>if (ret2 &lt; 0) {</p><p><code></code>DbgLog((LOG_TRACE, 50, L"::Decode() - decoding failed despite successfull parsing"));</p><p><code></code>got_picture = 0;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>got_picture = 0;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>used_bytes = avcodec_decode_video2 (m_pAVCtx, m_pFrame, &got_picture, &avpkt);</p><p><code></code>}</p><p><code></code>if (FAILED(PostDecode())) {</p><p><code></code>av_frame_unref(m_pFrame);</p><p><code></code>return E_FAIL;</p><p><code></code>}</p><p><code></code>// Decoding of this frame failed ... oh well!</p><p><code></code>if (used_bytes &lt; 0) {</p><p><code></code>av_frame_unref(m_pFrame);</p><p><code></code>return S_OK;</p><p><code></code>}</p><p><code></code>// When Frame Threading, we won't know how much data has been consumed, so it by default eats everything.</p><p><code></code>// In addition, if no data got consumed, and no picture was extracted, the frame probably isn't all that useufl.</p><p><code></code>// The MJPEB decoder is somewhat buggy and doesn't let us know how much data was consumed really...</p><p><code></code>if ((!m_pParser && (m_pAVCtx->active_thread_type & FF_THREAD_FRAME || (!got_picture && used_bytes == 0))) || m_bNoBufferConsumption || bFlush) {</p><p><code></code>buflen = 0;</p><p><code></code>} else {</p><p><code></code>buflen -= used_bytes;</p><p><code></code>pDataBuffer += used_bytes;</p><p><code></code>}</p><p><code></code>// Judge frame usability</p><p><code></code>// This determines if a frame is artifact free and can be delivered</p><p><code></code>// For H264 this does some wicked magic hidden away in the H264RandomAccess class</p><p><code></code>// MPEG-2 and VC-1 just wait for a keyframe..</p><p><code></code>if (m_nCodecId == AV_CODEC_ID_H264 && (bParserFrame || !m_pParser || got_picture)) {</p><p><code></code>m_h264RandomAccess.judgeFrameUsability(m_pFrame, &got_picture);</p><p><code></code>} else if (m_bResumeAtKeyFrame) {</p><p><code></code>if (m_bWaitingForKeyFrame && got_picture) {</p><p><code></code>if (m_pFrame->key_frame) {</p><p><code></code>DbgLog((LOG_TRACE, 50, L"::Decode() - Found Key-Frame, resuming decoding at %I64d", m_pFrame->pkt_pts));</p><p><code></code>m_bWaitingForKeyFrame = FALSE;</p><p><code></code>} else {</p><p><code></code>got_picture = 0;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>// Handle B-frame delay for frame threading codecs</p><p><code></code>if ((m_pAVCtx->active_thread_type & FF_THREAD_FRAME) && m_bBFrameDelay) {</p><p><code></code>m_tcBFrameDelay[m_nBFramePos] = m_tcThreadBuffer[m_CurrentThread];</p><p><code></code>m_nBFramePos = !m_nBFramePos;</p><p><code></code>}</p><p><code></code>if (!got_picture || !m_pFrame->data[0]) {</p><p><code></code>if (!avpkt.size)</p><p><code></code>bFlush = FALSE; // End flushing, no more frames</p><p><code></code>av_frame_unref(m_pFrame);</p><p><code></code>continue;</p><p><code></code>}</p><p><code></code>///////////////////////////////////////////////////////////////////////////////////////////////</p><p><code></code>// Determine the proper timestamps for the frame, based on different possible flags.</p><p><code></code>///////////////////////////////////////////////////////////////////////////////////////////////</p><p><code></code>if (m_bFFReordering) {</p><p><code></code>rtStart = m_pFrame->pkt_pts;</p><p><code></code>if (m_pFrame->pkt_duration)</p><p><code></code>rtStop = m_pFrame->pkt_pts + m_pFrame->pkt_duration;</p><p><code></code>else</p><p><code></code>rtStop = AV_NOPTS_VALUE;</p><p><code></code>} else if (m_bBFrameDelay && m_pAVCtx->has_b_frames) {</p><p><code></code>rtStart = m_tcBFrameDelay[m_nBFramePos].rtStart;</p><p><code></code>rtStop = m_tcBFrameDelay[m_nBFramePos].rtStop;</p><p><code></code>} else if (m_pAVCtx->active_thread_type & FF_THREAD_FRAME) {</p><p><code></code>unsigned index = m_CurrentThread;</p><p><code></code>rtStart = m_tcThreadBuffer[index].rtStart;</p><p><code></code>rtStop = m_tcThreadBuffer[index].rtStop;</p><p><code></code>}</p><p><code></code>if (m_bRVDropBFrameTimings && m_pFrame->pict_type == AV_PICTURE_TYPE_B) {</p><p><code></code>rtStart = AV_NOPTS_VALUE;</p><p><code></code>}</p><p><code></code>if (m_bCalculateStopTime)</p><p><code></code>rtStop = AV_NOPTS_VALUE;</p><p><code></code>///////////////////////////////////////////////////////////////////////////////////////////////</p><p><code></code>// All required values collected, deliver the frame</p><p><code></code>///////////////////////////////////////////////////////////////////////////////////////////////</p><p><code></code>LAVFrame *pOutFrame = NULL;</p><p><code></code>AllocateFrame(&pOutFrame);</p><p><code></code>AVRational display_aspect_ratio;</p><p><code></code>int64_t num = (int64_t)m_pFrame->sample_aspect_ratio.num * m_pFrame->width;</p><p><code></code>int64_t den = (int64_t)m_pFrame->sample_aspect_ratio.den * m_pFrame->height;</p><p><code></code>av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den, num, den, 1 &lt;&lt; 30);</p><p><code></code>pOutFrame->width = m_pFrame->width;</p><p><code></code>pOutFrame->height = m_pFrame->height;</p><p><code></code>pOutFrame->aspect_ratio = display_aspect_ratio;</p><p><code></code>pOutFrame->repeat = m_pFrame->repeat_pict;</p><p><code></code>pOutFrame->key_frame = m_pFrame->key_frame;</p><p><code></code>pOutFrame->frame_type = av_get_picture_type_char(m_pFrame->pict_type);</p><p><code></code>pOutFrame->ext_format = GetDXVA2ExtendedFlags(m_pAVCtx, m_pFrame);</p><p><code></code>if (m_pFrame->interlaced_frame || (!m_pAVCtx->progressive_sequence && (m_nCodecId == AV_CODEC_ID_H264 || m_nCodecId == AV_CODEC_ID_MPEG2VIDEO)))</p><p><code></code>m_iInterlaced = 1;</p><p><code></code>else if (m_pAVCtx->progressive_sequence)</p><p><code></code>m_iInterlaced = 0;</p><p><code></code>pOutFrame->interlaced = (m_pFrame->interlaced_frame || (m_iInterlaced == 1 && m_pSettings->GetDeinterlacingMode() == DeintMode_Aggressive) || m_pSettings->GetDeinterlacingMode() == DeintMode_Force) && !(m_pSettings->GetDeinterlacingMode() == DeintMode_Disable);</p><p><code></code>LAVDeintFieldOrder fo = m_pSettings->GetDeintFieldOrder();</p><p><code></code>pOutFrame->tff = (fo == DeintFieldOrder_Auto) ? m_pFrame->top_field_first : (fo == DeintFieldOrder_TopFieldFirst);</p><p><code></code>pOutFrame->rtStart = rtStart;</p><p><code></code>pOutFrame->rtStop = rtStop;</p><p><code></code>PixelFormatMapping map = getPixFmtMapping((AVPixelFormat)m_pFrame->format);</p><p><code></code>pOutFrame->format = map.lavpixfmt;</p><p><code></code>pOutFrame->bpp = map.bpp;</p><p><code></code>if (m_nCodecId == AV_CODEC_ID_MPEG2VIDEO || m_nCodecId == AV_CODEC_ID_MPEG1VIDEO)</p><p><code></code>pOutFrame->avgFrameDuration = GetFrameDuration();</p><p><code></code>if (map.conversion) {</p><p><code></code>ConvertPixFmt(m_pFrame, pOutFrame);</p><p><code></code>} else {</p><p><code></code>for (int i = 0; i &lt; 4; i++) {</p><p><code></code>pOutFrame->data[i] = m_pFrame->data[i];</p><p><code></code>pOutFrame->stride[i] = m_pFrame->linesize[i];</p><p><code></code>}</p><p><code></code>pOutFrame->priv_data = av_frame_alloc();</p><p><code></code>av_frame_ref((AVFrame *)pOutFrame->priv_data, m_pFrame);</p><p><code></code>pOutFrame->destruct = lav_avframe_free;</p><p><code></code>}</p><p><code></code>if (bEndOfSequence)</p><p><code></code>pOutFrame->flags |= LAV_FRAME_FLAG_END_OF_SEQUENCE;</p><p><code></code>if (pOutFrame->format == LAVPixFmt_DXVA2) {</p><p><code></code>pOutFrame->data[0] = m_pFrame->data[4];</p><p><code></code>HandleDXVA2Frame(pOutFrame);</p><p><code></code>} else {</p><p><code></code>Deliver(pOutFrame);</p><p><code></code>}</p><p><code></code>if (bEndOfSequence) {</p><p><code></code>bEndOfSequence = FALSE;</p><p><code></code>if (pOutFrame->format == LAVPixFmt_DXVA2) {</p><p><code></code>HandleDXVA2Frame(m_pCallback->GetFlushFrame());</p><p><code></code>} else {</p><p><code></code>Deliver(m_pCallback->GetFlushFrame());</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (bFlush) {</p><p><code></code>m_CurrentThread = (m_CurrentThread + 1) % m_pAVCtx->thread_count;</p><p><code></code>}</p><p><code></code>av_frame_unref(m_pFrame);</p><p><code></code>}</p><p><code></code>return S_OK;</p><p>}</p><p>终于，我们从这个函数中看到了很多的ffmpeg的API，结构体，以及变量。比如解码视频的函数avcodec_decode_video2()。</p><p>解码器初始化函数：InitDecoder()</p><p>//创建解码器</p><p>STDMETHODIMP CDecAvcodec::InitDecoder(AVCodecID codec, const CMediaType *pmt)</p><p>{</p><p><code></code>//要是有，先销毁</p><p><code></code>DestroyDecoder();</p><p><code></code>DbgLog((LOG_TRACE, 10, L"Initializing ffmpeg for codec %S", avcodec_get_name(codec)));</p><p><code></code>BITMAPINFOHEADER *pBMI = NULL;</p><p><code></code>videoFormatTypeHandler((const BYTE *)pmt->Format(), pmt->FormatType(), &pBMI);</p><p><code></code>//查找解码器</p><p><code></code>m_pAVCodec = avcodec_find_decoder(codec);</p><p><code></code>CheckPointer(m_pAVCodec, VFW_E_UNSUPPORTED_VIDEO);</p><p><code></code>//初始化上下文环境</p><p><code></code>m_pAVCtx = avcodec_alloc_context3(m_pAVCodec);</p><p><code></code>CheckPointer(m_pAVCtx, E_POINTER);</p><p><code></code>if(codec == AV_CODEC_ID_MPEG1VIDEO || codec == AV_CODEC_ID_MPEG2VIDEO || pmt->subtype == FOURCCMap(MKTAG('H','2','6','4')) || pmt->subtype == FOURCCMap(MKTAG('h','2','6','4'))) {</p><p><code></code>m_pParser = av_parser_init(codec);</p><p><code></code>}</p><p><code></code>DWORD dwDecFlags = m_pCallback->GetDecodeFlags();</p><p><code></code>LONG biRealWidth = pBMI->biWidth, biRealHeight = pBMI->biHeight;</p><p><code></code>if (pmt->formattype == FORMAT_VideoInfo || pmt->formattype == FORMAT_MPEGVideo) {</p><p><code></code>VIDEOINFOHEADER *vih = (VIDEOINFOHEADER *)pmt->Format();</p><p><code></code>if (vih->rcTarget.right != 0 && vih->rcTarget.bottom != 0) {</p><p><code></code>biRealWidth = vih->rcTarget.right;</p><p><code></code>biRealHeight = vih->rcTarget.bottom;</p><p><code></code>}</p><p><code></code>} else if (pmt->formattype == FORMAT_VideoInfo2 || pmt->formattype == FORMAT_MPEG2Video) {</p><p><code></code>VIDEOINFOHEADER2 *vih2 = (VIDEOINFOHEADER2 *)pmt->Format();</p><p><code></code>if (vih2->rcTarget.right != 0 && vih2->rcTarget.bottom != 0) {</p><p><code></code>biRealWidth = vih2->rcTarget.right;</p><p><code></code>biRealHeight = vih2->rcTarget.bottom;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>//各种赋值</p><p><code></code>m_pAVCtx->codec_id = codec;</p><p><code></code>m_pAVCtx->codec_tag = pBMI->biCompression;</p><p><code></code>m_pAVCtx->coded_width = pBMI->biWidth;</p><p><code></code>m_pAVCtx->coded_height = abs(pBMI->biHeight);</p><p><code></code>m_pAVCtx->bits_per_coded_sample = pBMI->biBitCount;</p><p><code></code>m_pAVCtx->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;</p><p><code></code>m_pAVCtx->err_recognition = AV_EF_CAREFUL;</p><p><code></code>m_pAVCtx->workaround_bugs = FF_BUG_AUTODETECT;</p><p><code></code>m_pAVCtx->refcounted_frames = 1;</p><p><code></code>if (codec == AV_CODEC_ID_H264)</p><p><code></code>m_pAVCtx->flags2 |= CODEC_FLAG2_SHOW_ALL;</p><p><code></code>// Setup threading</p><p><code></code>int thread_type = getThreadFlags(codec);</p><p><code></code>if (thread_type) {</p><p><code></code>// Thread Count. 0 = auto detect</p><p><code></code>int thread_count = m_pSettings->GetNumThreads();</p><p><code></code>if (thread_count == 0) {</p><p><code></code>thread_count = av_cpu_count() * 3 / 2;</p><p><code></code>}</p><p><code></code>m_pAVCtx->thread_count = max(1, min(thread_count, AVCODEC_MAX_THREADS));</p><p><code></code>m_pAVCtx->thread_type = thread_type;</p><p><code></code>} else {</p><p><code></code>m_pAVCtx->thread_count = 1;</p><p><code></code>}</p><p><code></code>if (dwDecFlags & LAV_VIDEO_DEC_FLAG_NO_MT) {</p><p><code></code>m_pAVCtx->thread_count = 1;</p><p><code></code>}</p><p><code></code>//初始化AVFrame</p><p><code></code>m_pFrame = av_frame_alloc();</p><p><code></code>CheckPointer(m_pFrame, E_POINTER);</p><p><code></code>m_h264RandomAccess.SetAVCNALSize(0);</p><p><code></code>// Process Extradata</p><p><code></code>//处理ExtraData</p><p><code></code>BYTE *extra = NULL;</p><p><code></code>size_t extralen = 0;</p><p><code></code>getExtraData(*pmt, NULL, &extralen);</p><p><code></code>BOOL bH264avc = FALSE;</p><p><code></code>if (extralen > 0) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"-> Processing extradata of %d bytes", extralen));</p><p><code></code>// Reconstruct AVC1 extradata format</p><p><code></code>if (pmt->formattype == FORMAT_MPEG2Video && (m_pAVCtx->codec_tag == MAKEFOURCC('a','v','c','1') || m_pAVCtx->codec_tag == MAKEFOURCC('A','V','C','1') || m_pAVCtx->codec_tag == MAKEFOURCC('C','C','V','1'))) {</p><p><code></code>MPEG2VIDEOINFO *mp2vi = (MPEG2VIDEOINFO *)pmt->Format();</p><p><code></code>extralen += 7;</p><p><code></code>extra = (uint8_t *)av_mallocz(extralen + FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>extra[0] = 1;</p><p><code></code>extra[1] = (BYTE)mp2vi->dwProfile;</p><p><code></code>extra[2] = 0;</p><p><code></code>extra[3] = (BYTE)mp2vi->dwLevel;</p><p><code></code>extra[4] = (BYTE)(mp2vi->dwFlags ? mp2vi->dwFlags : 4) - 1;</p><p><code></code>// Actually copy the metadata into our new buffer</p><p><code></code>size_t actual_len;</p><p><code></code>getExtraData(*pmt, extra+6, &actual_len);</p><p><code></code>// Count the number of SPS/PPS in them and set the length</p><p><code></code>// We'll put them all into one block and add a second block with 0 elements afterwards</p><p><code></code>// The parsing logic does not care what type they are, it just expects 2 blocks.</p><p><code></code>BYTE *p = extra+6, *end = extra+6+actual_len;</p><p><code></code>BOOL bSPS = FALSE, bPPS = FALSE;</p><p><code></code>int count = 0;</p><p><code></code>while (p+1 &lt; end) {</p><p><code></code>unsigned len = (((unsigned)p[0] &lt;&lt; 8) | p[1]) + 2;</p><p><code></code>if (p + len > end) {</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>if ((p[2] & 0x1F) == 7)</p><p><code></code>bSPS = TRUE;</p><p><code></code>if ((p[2] & 0x1F) == 8)</p><p><code></code>bPPS = TRUE;</p><p><code></code>count++;</p><p><code></code>p += len;</p><p><code></code>}</p><p><code></code>extra[5] = count;</p><p><code></code>extra[extralen-1] = 0;</p><p><code></code>bH264avc = TRUE;</p><p><code></code>m_h264RandomAccess.SetAVCNALSize(mp2vi->dwFlags);</p><p><code></code>} else if (pmt->subtype == MEDIASUBTYPE_LAV_RAWVIDEO) {</p><p><code></code>if (extralen &lt; sizeof(m_pAVCtx->pix_fmt)) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"-> LAV RAW Video extradata is missing.."));</p><p><code></code>} else {</p><p><code></code>extra = (uint8_t *)av_mallocz(extralen + FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>getExtraData(*pmt, extra, NULL);</p><p><code></code>m_pAVCtx->pix_fmt = *(AVPixelFormat *)extra;</p><p><code></code>extralen -= sizeof(AVPixelFormat);</p><p><code></code>memmove(extra, extra+sizeof(AVPixelFormat), extralen);</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>// Just copy extradata for other formats</p><p><code></code>extra = (uint8_t *)av_mallocz(extralen + FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>getExtraData(*pmt, extra, NULL);</p><p><code></code>}</p><p><code></code>// Hack to discard invalid MP4 metadata with AnnexB style video</p><p><code></code>if (codec == AV_CODEC_ID_H264 && !bH264avc && extra[0] == 1) {</p><p><code></code>av_freep(&extra);</p><p><code></code>extralen = 0;</p><p><code></code>}</p><p><code></code>m_pAVCtx->extradata = extra;</p><p><code></code>m_pAVCtx->extradata_size = (int)extralen;</p><p><code></code>} else {</p><p><code></code>if (codec == AV_CODEC_ID_VP6 || codec == AV_CODEC_ID_VP6A || codec == AV_CODEC_ID_VP6F) {</p><p><code></code>int cropH = pBMI->biWidth - biRealWidth;</p><p><code></code>int cropV = pBMI->biHeight - biRealHeight;</p><p><code></code>if (cropH >= 0 && cropH &lt;= 0x0f && cropV >= 0 && cropV &lt;= 0x0f) {</p><p><code></code>m_pAVCtx->extradata = (uint8_t *)av_mallocz(1 + FF_INPUT_BUFFER_PADDING_SIZE);</p><p><code></code>m_pAVCtx->extradata_size = 1;</p><p><code></code>m_pAVCtx->extradata[0] = (cropH &lt;&lt; 4) | cropV;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>}</p><p><code></code>m_h264RandomAccess.flush(m_pAVCtx->thread_count);</p><p><code></code>m_CurrentThread = 0;</p><p><code></code>m_rtStartCache = AV_NOPTS_VALUE;</p><p><code></code>LAVPinInfo lavPinInfo = {0};</p><p><code></code>BOOL bLAVInfoValid = SUCCEEDED(m_pCallback->GetLAVPinInfo(lavPinInfo));</p><p><code></code>m_bInputPadded = dwDecFlags & LAV_VIDEO_DEC_FLAG_LAVSPLITTER;</p><p><code></code>// Setup codec-specific timing logic</p><p><code></code>BOOL bVC1IsPTS = (codec == AV_CODEC_ID_VC1 && !(dwDecFlags & LAV_VIDEO_DEC_FLAG_VC1_DTS));</p><p><code></code>// Use ffmpegs logic to reorder timestamps</p><p><code></code>// This is required for H264 content (except AVI), and generally all codecs that use frame threading</p><p><code></code>// VC-1 is also a special case. Its required for splitters that deliver PTS timestamps (see bVC1IsPTS above)</p><p><code></code>m_bFFReordering = ( codec == AV_CODEC_ID_H264 && !(dwDecFlags & LAV_VIDEO_DEC_FLAG_H264_AVI))</p><p><code></code>|| codec == AV_CODEC_ID_VP8</p><p><code></code>|| codec == AV_CODEC_ID_VP3</p><p><code></code>|| codec == AV_CODEC_ID_THEORA</p><p><code></code>|| codec == AV_CODEC_ID_HUFFYUV</p><p><code></code>|| codec == AV_CODEC_ID_FFVHUFF</p><p><code></code>|| codec == AV_CODEC_ID_MPEG2VIDEO</p><p><code></code>|| codec == AV_CODEC_ID_MPEG1VIDEO</p><p><code></code>|| codec == AV_CODEC_ID_DIRAC</p><p><code></code>|| codec == AV_CODEC_ID_UTVIDEO</p><p><code></code>|| codec == AV_CODEC_ID_DNXHD</p><p><code></code>|| codec == AV_CODEC_ID_JPEG2000</p><p><code></code>|| (codec == AV_CODEC_ID_MPEG4 && pmt->formattype == FORMAT_MPEG2Video)</p><p><code></code>|| bVC1IsPTS;</p><p><code></code>// Stop time is unreliable, drop it and calculate it</p><p><code></code>m_bCalculateStopTime = (codec == AV_CODEC_ID_H264 || codec == AV_CODEC_ID_DIRAC || (codec == AV_CODEC_ID_MPEG4 && pmt->formattype == FORMAT_MPEG2Video) || bVC1IsPTS);</p><p><code></code>// Real Video content has some odd timestamps</p><p><code></code>// LAV Splitter does them allright with RV30/RV40, everything else screws them up</p><p><code></code>m_bRVDropBFrameTimings = (codec == AV_CODEC_ID_RV10 || codec == AV_CODEC_ID_RV20 || ((codec == AV_CODEC_ID_RV30 || codec == AV_CODEC_ID_RV40) && (!(dwDecFlags & LAV_VIDEO_DEC_FLAG_LAVSPLITTER) || (bLAVInfoValid && (lavPinInfo.flags & LAV_STREAM_FLAG_RV34_MKV)))));</p><p><code></code>// Enable B-Frame delay handling</p><p><code></code>m_bBFrameDelay = !m_bFFReordering && !m_bRVDropBFrameTimings;</p><p><code></code>m_bWaitingForKeyFrame = TRUE;</p><p><code></code>m_bResumeAtKeyFrame = codec == AV_CODEC_ID_MPEG2VIDEO</p><p><code></code>|| codec == AV_CODEC_ID_VC1</p><p><code></code>|| codec == AV_CODEC_ID_RV30</p><p><code></code>|| codec == AV_CODEC_ID_RV40</p><p><code></code>|| codec == AV_CODEC_ID_VP3</p><p><code></code>|| codec == AV_CODEC_ID_THEORA</p><p><code></code>|| codec == AV_CODEC_ID_MPEG4;</p><p><code></code>m_bNoBufferConsumption = codec == AV_CODEC_ID_MJPEGB</p><p><code></code>|| codec == AV_CODEC_ID_LOCO</p><p><code></code>|| codec == AV_CODEC_ID_JPEG2000;</p><p><code></code>m_bHasPalette = m_pAVCtx->bits_per_coded_sample &lt;= 8 && m_pAVCtx->extradata_size && !(dwDecFlags & LAV_VIDEO_DEC_FLAG_LAVSPLITTER)</p><p><code></code>&& (codec == AV_CODEC_ID_MSVIDEO1</p><p><code></code>|| codec == AV_CODEC_ID_MSRLE</p><p><code></code>|| codec == AV_CODEC_ID_CINEPAK</p><p><code></code>|| codec == AV_CODEC_ID_8BPS</p><p><code></code>|| codec == AV_CODEC_ID_QPEG</p><p><code></code>|| codec == AV_CODEC_ID_QTRLE</p><p><code></code>|| codec == AV_CODEC_ID_TSCC);</p><p><code></code>if (FAILED(AdditionaDecoderInit())) {</p><p><code></code>return E_FAIL;</p><p><code></code>}</p><p><code></code>if (bLAVInfoValid) {</p><p><code></code>// Setting has_b_frames to a proper value will ensure smoother decoding of H264</p><p><code></code>if (lavPinInfo.has_b_frames >= 0) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"-> Setting has_b_frames to %d", lavPinInfo.has_b_frames));</p><p><code></code>m_pAVCtx->has_b_frames = lavPinInfo.has_b_frames;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>// Open the decoder</p><p><code></code>//打开解码器</p><p><code></code>int ret = avcodec_open2(m_pAVCtx, m_pAVCodec, NULL);</p><p><code></code>if (ret >= 0) {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"-> ffmpeg codec opened successfully (ret: %d)", ret));</p><p><code></code>m_nCodecId = codec;</p><p><code></code>} else {</p><p><code></code>DbgLog((LOG_TRACE, 10, L"-> ffmpeg codec failed to open (ret: %d)", ret));</p><p><code></code>DestroyDecoder();</p><p><code></code>return VFW_E_UNSUPPORTED_VIDEO;</p><p><code></code>}</p><p><code></code>m_iInterlaced = 0;</p><p><code></code>for (int i = 0; i &lt; countof(ff_interlace_capable); i++) {</p><p><code></code>if (codec == ff_interlace_capable[i]) {</p><p><code></code>m_iInterlaced = -1;</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>// Detect chroma and interlaced</p><p><code></code>if (m_pAVCtx->extradata && m_pAVCtx->extradata_size) {</p><p><code></code>if (codec == AV_CODEC_ID_MPEG2VIDEO) {</p><p><code></code>CMPEG2HeaderParser mpeg2Parser(extra, extralen);</p><p><code></code>if (mpeg2Parser.hdr.valid) {</p><p><code></code>if (mpeg2Parser.hdr.chroma &lt; 2) {</p><p><code></code>m_pAVCtx->pix_fmt = AV_PIX_FMT_YUV420P;</p><p><code></code>} else if (mpeg2Parser.hdr.chroma == 2) {</p><p><code></code>m_pAVCtx->pix_fmt = AV_PIX_FMT_YUV422P;</p><p><code></code>}</p><p><code></code>m_iInterlaced = mpeg2Parser.hdr.interlaced;</p><p><code></code>}</p><p><code></code>} else if (codec == AV_CODEC_ID_H264) {</p><p><code></code>CH264SequenceParser h264parser;</p><p><code></code>if (bH264avc)</p><p><code></code>h264parser.ParseNALs(extra+6, extralen-6, 2);</p><p><code></code>else</p><p><code></code>h264parser.ParseNALs(extra, extralen, 0);</p><p><code></code>if (h264parser.sps.valid)</p><p><code></code>m_iInterlaced = h264parser.sps.interlaced;</p><p><code></code>} else if (codec == AV_CODEC_ID_VC1) {</p><p><code></code>CVC1HeaderParser vc1parser(extra, extralen);</p><p><code></code>if (vc1parser.hdr.valid)</p><p><code></code>m_iInterlaced = (vc1parser.hdr.interlaced ? -1 : 0);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (codec == AV_CODEC_ID_DNXHD)</p><p><code></code>m_pAVCtx->pix_fmt = AV_PIX_FMT_YUV422P10;</p><p><code></code>else if (codec == AV_CODEC_ID_FRAPS)</p><p><code></code>m_pAVCtx->pix_fmt = AV_PIX_FMT_BGR24;</p><p><code></code>if (bLAVInfoValid && codec != AV_CODEC_ID_FRAPS && m_pAVCtx->pix_fmt != AV_PIX_FMT_DXVA2_VLD)</p><p><code></code>m_pAVCtx->pix_fmt = lavPinInfo.pix_fmt;</p><p><code></code>DbgLog((LOG_TRACE, 10, L"AVCodec init successfull. interlaced: %d", m_iInterlaced));</p><p><code></code>return S_OK;</p><p>}</p><p>解码器销毁函数：DestroyDecoder()</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/13272409#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/13272409#>copy</a></p><p>//销毁解码器，各种Free</p><p>STDMETHODIMP CDecAvcodec::DestroyDecoder()</p><p>{</p><p><code></code>DbgLog((LOG_TRACE, 10, L"Shutting down ffmpeg..."));</p><p><code></code>m_pAVCodec = NULL;</p><p><code></code>if (m_pParser) {</p><p><code></code>av_parser_close(m_pParser);</p><p><code></code>m_pParser = NULL;</p><p><code></code>}</p><p><code></code>if (m_pAVCtx) {</p><p><code></code>avcodec_close(m_pAVCtx);</p><p><code></code>av_freep(&m_pAVCtx->extradata);</p><p><code></code>av_freep(&m_pAVCtx);</p><p><code></code>}</p><p><code></code>av_frame_free(&m_pFrame);</p><p><code></code>av_freep(&m_pFFBuffer);</p><p><code></code>m_nFFBufferSize = 0;</p><p><code></code>av_freep(&m_pFFBuffer2);</p><p><code></code>m_nFFBufferSize2 = 0;</p><p><code></code>if (m_pSwsContext) {</p><p><code></code>sws_freeContext(m_pSwsContext);</p><p><code></code>m_pSwsContext = NULL;</p><p><code></code>}</p><p><code></code>m_nCodecId = AV_CODEC_ID_NONE;</p><p><code></code>return S_OK;</p><p>}</p><h2 id=93-mplayer><strong>9.3 MPlayer</strong></h2><h3 id=931-mplayer支持的格式><strong>9.3.1 Mplayer支持的格式</strong></h3><p>MPlayer是一个LINUX下的视频播放器，它支持相当多的媒体格式，无论在音频播放还是在视频播放方面，可以说它支持的格式是相当全面的。</p><p>视频格式支持：MPEG、AVI、ASF 与WMV、QuickTime 与 OGG/OGM、SDP、PVA、GIF。</p><p>音频格式支持：MP3、WAV、OGG/OGM 文件(Vorbis)、WMA 与 ASF、MP4、CD音频、XMMS。</p><h3 id=932-mplayer-中头文件的功能分析><strong>9.3.2 Mplayer 中头文件的功能分析</strong></h3><p>config.h // 各种本地配置宏定义头</p><p>version.h // 版本定义头 #define VERSION "1.0pre7try2-3.4.2"</p><p>mp_msg.h // 消息处理头</p><p>help_mp.h // 根据配置自动生成的帮助头 #include "help/help_mpen.h"</p><p>cfg-mplayer-def.h // Mplayer 运行时的选项缺省值头文件 char*</p><p>default_config =</p><p>sub_reader.h // 拥有格式自动发现功能的字幕(subtitle)阅读器</p><p>libvo/video_out.h // 该文件包含 libvo 视频输出的公共函数、变量</p><p>libvo/font_load.h // 有关字体装载的例程</p><p>libao2/audio_out.h // 音频输出驱动程序相关结构定义和全局数据</p><p>libmpcodecs/dec_audio.h // 音频解码</p><p>libmpcodecs/dec_video.h // 视频解码</p><p>libmpdemux/matroska.h // 多路解复用，媒体容器格式 matroska 处理头</p><p>libmpdemux/stream.h // 流处理</p><p>libmpdemux/demuxer.h // 多路解复用头文件</p><p>libmpdemux/stheader.h // 媒体流头处理</p><p>get_path.c // 路径获取头文件</p><p>spudec.h // SPU 子画面单元头，DVD 字幕流</p><p>edl.h // 剪辑控制清单</p><p>m_option.h // 选项类型处理头</p><p>m_config.h // 配置处理头文件</p><h3 id=933-mplayermain-主流程简要说明><strong>9.3.3 MPlayer.main 主流程简要说明</strong></h3><p>int main() {</p><p>\1) 变量声明，电影信息 movie info:</p><p>\2) 初始化，消息系统……</p><p>play_next_file:</p><p>3)播放文件 filename 的循环 goto play_next_file 开始</p><p>main:</p><p>\4) 主处理 main</p><p>\5) 播放真正主循环 2010 ~3541 while (!eof)</p><p>while (!eof) {</p><p>5.1) 播放音频 PLAY AUDIO 2017 ~ 2064 decode_audio(sh_audio, ...);</p><p>5.2) 播放视频 PLAY VIDEO, 2068 ~ 2300 decode_video(sh_video, ...);</p><p>5.3) 处理暂停 PAUSE</p><p>5.4) 处理 EDL</p><p>5.5) 键盘事件处理, 搜索2400~3216 while (!brk_cmd &&</p><p>(cmd=mp_input_get_cmd(0,0,0))!=NULL)</p><p>5.6) 时间寻道(秒) if (seek_to_sec)</p><p>5.7) 寻道 3243 ~ 3306, if (rel_seek_secs || abs_seek_pos)</p><p>5.8) 处理 GUI</p><p>5.9) 变更 Update OSD</p><p>5.10) 找到字幕 find sub</p><p>5.11) 处理 X11 窗口</p><p>5.12) DVD 字幕 sub:</p><p>}</p><p>goto_next_file:</p><p>\6) 播放结束，转到下个文件 goto_next_file:</p><p>}</p><h3 id=934-mplayer源码分析><strong>9.3.4 Mplayer源码分析</strong></h3><p>从Mplayer.c的main开始处理参数</p><p>mconfig = m_config_new();</p><p>m_config_register_options(mconfig,mplayer_opts);</p><p>// TODO : add something to let modules register their options</p><p>mp_input_register_options(mconfig);</p><p>parse_cfgfiles(mconfig);</p><p>初始化mpctx结构体，mpctx应该是mplayer context的意思，顾名思义是一个统筹全局的变量。</p><p>[cpp] <a href=http://blog.csdn.net/leixiaohua1020/article/details/11885509#>view plain</a><a href=http://blog.csdn.net/leixiaohua1020/article/details/11885509#>copy</a></p><p>static MPContext *mpctx = &mpctx_s;</p><p>// Not all functions in mplayer.c take the context as an argument yet</p><p>static MPContext mpctx_s = {</p><p>.osd_function = OSD_PLAY,</p><p>.begin_skip = MP_NOPTS_VALUE,</p><p>.play_tree_step = 1,</p><p>.global_sub_pos = -1,</p><p>.set_of_sub_pos = -1,</p><p>.file_format = DEMUXER_TYPE_UNKNOWN,</p><p>.loop_times = -1,</p><p>#ifdef HAS_DVBIN_SUPPORT</p><p>.last_dvb_step = 1,</p><p>#endif</p><p>};</p><p>原型</p><p>//真正统筹全局的结构</p><p>typedef struct MPContext {</p><p><code></code>int osd_show_percentage;</p><p><code></code>int osd_function;</p><p><code></code>const ao_functions_t *audio_out;</p><p><code></code>play_tree_t *playtree;</p><p><code></code>play_tree_iter_t *playtree_iter;</p><p><code></code>int eof;</p><p><code></code>int play_tree_step;</p><p><code></code>int loop_times;</p><p><code></code>stream_t *stream;</p><p><code></code>demuxer_t *demuxer;</p><p><code></code>sh_audio_t *sh_audio;</p><p><code></code>sh_video_t *sh_video;</p><p><code></code>demux_stream_t *d_audio;</p><p><code></code>demux_stream_t *d_video;</p><p><code></code>demux_stream_t *d_sub;</p><p><code></code>mixer_t mixer;</p><p><code></code>const vo_functions_t *video_out;</p><p><code></code>// Frames buffered in the vo ready to flip. Currently always 0 or 1.</p><p><code></code>// This is really a vo variable but currently there's no suitable vo</p><p><code></code>// struct.</p><p><code></code>int num_buffered_frames;</p><p><code></code>// used to retry decoding after startup/seeking to compensate for codec delay</p><p><code></code>int startup_decode_retry;</p><p><code></code>// how long until we need to display the "current" frame</p><p><code></code>float time_frame;</p><p><code></code>// AV sync: the next frame should be shown when the audio out has this</p><p><code></code>// much (in seconds) buffered data left. Increased when more data is</p><p><code></code>// written to the ao, decreased when moving to the next frame.</p><p><code></code>// In the audio-only case used as a timer since the last seek</p><p><code></code>// by the audio CPU usage meter.</p><p><code></code>double delay;</p><p><code></code>float begin_skip; ///&lt; start time of the current skip while on edlout mode</p><p><code></code>// audio is muted if either EDL or user activates mute</p><p><code></code>short edl_muted; ///&lt; Stores whether EDL is currently in muted mode.</p><p><code></code>short user_muted; ///&lt; Stores whether user wanted muted mode.</p><p><code></code>int global_sub_size; // this encompasses all subtitle sources</p><p><code></code>int global_sub_pos; // this encompasses all subtitle sources</p><p><code></code>int set_of_sub_pos;</p><p><code></code>int set_of_sub_size;</p><p><code></code>int sub_counts[SUB_SOURCES];</p><p>#ifdef CONFIG_ASS</p><p><code></code>// set_of_ass_tracks[i] contains subtitles from set_of_subtitles[i]</p><p><code></code>// parsed by libass or NULL if format unsupported</p><p><code></code>ASS_Track* set_of_ass_tracks[MAX_SUBTITLE_FILES];</p><p>#endif</p><p><code></code>sub_data* set_of_subtitles[MAX_SUBTITLE_FILES];</p><p><code></code>int file_format;</p><p>#ifdef CONFIG_DVBIN</p><p><code></code>int last_dvb_step;</p><p><code></code>int dvbin_reopen;</p><p>#endif</p><p><code></code>int was_paused;</p><p>#ifdef CONFIG_DVDNAV</p><p><code></code>struct mp_image *nav_smpi; ///&lt; last decoded dvdnav video image</p><p><code></code>unsigned char *nav_buffer; ///&lt; last read dvdnav video frame</p><p><code></code>unsigned char *nav_start; ///&lt; pointer to last read video buffer</p><p><code></code>int nav_in_size; ///&lt; last read size</p><p>#endif</p><p>} MPContext;</p><p>一些GUI相关的操作</p><p>打开字幕流</p><p>打开音视频流</p><p>mpctx->stream=open_stream(filename,0,&mpctx->file_format);</p><p>fileformat 文件还是TV 流DEMUXER_TYPE_PLAYLIST 或DEMUXER_TYPE_UNKNOWN</p><p>DEMUXER_TYPE_TV</p><p>current_module记录状态vobsub open_stream handle_playlist dumpstream</p><p>stream_reset(mpctx->stream);</p><p>stream_seek(mpctx->stream,mpctx->stream->start_pos);</p><p>f=fopen(stream_dump_name,”wb”); dump文件流</p><p>stream->type==STREAMTYPE_DVD</p><p>//============ Open DEMUXERS — DETECT file type ======================</p><p>Demux。分离视频流和音频流</p><p>mpctx->demuxer=demux_open(mpctx->stream,mpctx-</p><p>>file_format,audio_id,video_id,dvdsub_id,filename);</p><p>Demux过程</p><p>demux_open</p><p>get_demuxer_type_from_name</p><p>……</p><p>mpctx->d_audio=mpctx->demuxer->audio;</p><p>mpctx->d_video=mpctx->demuxer->video;</p><p>mpctx->d_sub=mpctx->demuxer->sub;</p><p>mpctx->sh_audio=mpctx->d_audio->sh;</p><p>mpctx->sh_video=mpctx->d_video->sh;</p><p>分离了之后就开始分别Play audio和video</p><p>这里只关心play video</p><p>/*======================== PLAY VIDEO ============================*/</p><p>vo_pts=mpctx->sh_video->timer*90000.0;</p><p>vo_fps=mpctx->sh_video->fps;</p><p>if (!mpctx->num_buffered_frames) {</p><p>double frame_time = update_video(&blit_frame);</p><p>mp_dbg(MSGT_AVSYNC,MSGL_DBG2,”*** ftime=%5.3f ***\n”,frame_time);</p><p>if (mpctx->sh_video->vf_inited &lt; 0) {</p><p>mp_msg(MSGT_CPLAYER,MSGL_FATAL, MSGTR_NotInitializeVOPorVO);</p><p>mpctx->eof = 1; goto goto_next_file;</p><p>}</p><p>if (frame_time &lt; 0)</p><p>mpctx->eof = 1;</p><p>else {</p><p>// might return with !eof && !blit_frame if !correct_pts</p><p>mpctx->num_buffered_frames += blit_frame;</p><p>time_frame += frame_time / playback_speed; // for nosound</p><p>}</p><p>}</p><p>关键的函数是update_video根据pts是否正确调整一下同步并在必要的时候丢帧处理。最终调用decode_video开始解码（包括generate_video_frame里）。mpi = mpvdec->decode(sh_video, start, in_size, drop_frame);mpvdec是在main里通过reinit_video_chain的一系列调用动态选定的解码程序。其实就一结构体。它的原型是</p><p>typedef struct vd_functions_s</p><p>{</p><p>vd_info_t *info;</p><p>int (*init)(sh_video_t *sh);</p><p>void (*uninit)(sh_video_t *sh);</p><p>int (*control)(sh_video_t *sh,int cmd,void* arg, …);</p><p>mp_image_t* (*decode)(sh_video_t *sh,void* data,int len,int flags);</p><p>} vd_functions_t;</p><p>这是所有解码器必须实现的接口。</p><p>int (*init)(sh_video_t *sh);是一个名为init的指针，指向一个接受sh_video_t *类型参数，并返回int类型值的函数地址。那些vd_开头的文件都是解码相关的。随便打开一个vd文件以上几个函数和info变量肯定都包含了。mpi被mplayer用来存储解码后的图像。在mp_image.h里定义。</p><p>typedef struct mp_image_s {</p><p>unsigned short flags;</p><p>unsigned char type;</p><p>unsigned char bpp; // bits/pixel. NOT depth! for RGB it will be n*8</p><p>unsigned int imgfmt;</p><p>int width,height; // stored dimensions</p><p>int x,y,w,h; // visible dimensions</p><p>unsigned char* planes[MP_MAX_PLANES];</p><p>int stride[MP_MAX_PLANES];</p><p>char * qscale;</p><p>int qstride;</p><p>int pict_type; // 0->unknown, 1->I, 2->P, 3->B</p><p>int fields;</p><p>int qscale_type; // 0->mpeg1/4/h263, 1->mpeg2</p><p>int num_planes;</p><p>/* these are only used by planar formats Y,U(Cb),V(Cr) */</p><p>int chroma_width;</p><p>int chroma_height;</p><p>int chroma_x_shift; // horizontal</p><p>int chroma_y_shift; // vertical</p><p>/* for private use by filter or vo driver (to store buffer id or dmpi) */</p><p>void* priv;</p><p>} mp_image_t;</p><p>图像在解码以后会输出到显示器，mplayer本来就是一个视频播放器么。但也有可能作为输入提供给编码器进行二次编码，MP附带的mencoder.exe就是专门用来编码的。在这之前可以定义filter对图像进行处理，以实现各种效果。所有以vf_开头的文件，都是这样的filter。图像的显示是通过vo，即video out来实现的。解码器只负责把解码完成的帧传给vo，怎样显示就不用管了。这也是平台相关性最大的部分，单独分出来的好处是不言而喻的，像在Windows下有通过direcx实现的vo，Linux下有输出到X的vo。vo_*文件是各种不同的vo实现，只是他们不都是以显示为目的，像vo_md5sum.c只是计算一下图像的md5值。在解码完成以后，即得到mpi以后，filter_video被调用，其结果是整个filter链上的所有filter都被调用了一遍，包括最后的VO，在vo的put_image里把图像输出到显示器。这个时候需要考虑的是图像存储的方法即用哪种色彩空间。</p><p>附上两张MPlayer结构图：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.162.jpeg alt></p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.163.jpeg alt></p><p>MPLayer源代码下载地址：<a href=http://download.csdn.net/detail/leixiaohua1020/6374337>http://download.csdn.net/detail/leixiaohua1020/6374337</a></p><h1 id=第十章-开发实例><strong>第十章 开发实例</strong></h1><h1 id=第十一章-mp4文件封装协议分析>第十一章 mp4文件封装协议分析</h1><h2 id=111--概述><strong>11.1 概述</strong></h2><p>MP4文件格式中，所有的内容存在一个称为movie的容器中。一个movie可以由多个trak组成。每个trak就是一个随时间变化的媒体序列，例如，视频帧序列。trak里的每个时间单位是一个sample，它可以是一帧视频，或者音频。sample按照时间顺序排列。注意，一帧音频可以分解成多个音频sample，所以音频一般用sample作为单位，而不用帧。MP4文件格式的定义里面，用sample这个单词表示一个时间帧或者数据单元。每个trak会有一个或者多个sample descriptions。track里面的每个sample通过引用关联到一个sample description。这个sample descriptions定义了怎样解码这个sample，例如使用的压缩算法。</p><p>与其他的多媒体文件格式不同的是，MP4文件格式经常使用几个不同的概念，理解其不同是理解这个文件格式的关键。</p><p>这个文件的物理格式没有限定媒体本身的格式。例如，许多文件格式将媒体数据分成帧，头部或者其他数据紧紧跟随每一帧视频。而MP4文件格式不是如此。</p><p>文件的物理格式和媒体数据的排列都不受媒体的时间顺序的限制。视频帧不需要在文件按时间顺序排列。这就意味着如果文件中真的存在这样的一些帧，那么就有一些文件结构来描述媒体的排列和对应的时间信息。</p><p>MP4文件中所有的数据都封装在一些box中（以前叫atom）。所有的metadata(媒体描述元数据)，包括定义媒体的排列和时间信息的数据都包含在这样的一些结构box中。MP4文件格式定义了这些这些box的格式。Metadata对媒体数据（例如，视频帧）引用说明。媒体数据可以包含在同一个的一个或多个box里，也可以在其他文件中，metadata允许使用URLs来引用其他的文件，而媒体数据在这些引用文件中的排列关系全部在第一个主文件中的metadata描述。其他的文件不一定是MP4文件格式，例如，可能就没有一个box。</p><p>有很多种类的trak，其中有三个最重要，video track包含了视频sample；audio trak包含了audio sample；hint trak稍有不同，它描述了一个流媒体服务器如何把文件中的媒体数据组成符合流媒体协议的数据包。 如果文件只是本地播放，可以忽略hint track，他们只与流媒体有关系。</p><h2 id=112--mp4的物理结构><strong>11.2 mp4的物理结构</strong></h2><p>Box定义了如何在sample table中找到媒体数据的排列。这包括data reference(数据引用), the sample size table, the sample to chunk table, and the chunk offset table. 这些表就可以找到trak中每个sample在文件中的位置和大小。 为了节约空间，这些表都很紧凑。另外，interleave不是sample by sample，而是把单个trak的几个samples组合到一起，然后另外几个sample又进行新的组合。一个trak的连续几个sample组成的单元就被称为chunk。每个chunk在文件中有一个偏移量，这个偏移量是从文件开头算起的，在这个chunk内，sample是连续存储的。</p><p>这样，如果一个chunk包含两个sample，第二个sample的位置就是chunk的偏移量加上第一个sample的大小。chunk offset table说明了每个chunk的偏移量，sample to chunk table说明了sample序号和chunk序号的映射关系。</p><p>注意chunk之间可能会有死区，没有任何媒体数据引用到这部分区域，但是chunk内部不会有这样的死区。</p><h2 id=113--数据的组织结构><strong>11.3 数据的组织结构</strong></h2><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.164.png alt></p><h2 id=114--mp4的时间结构><strong>11.4 mp4的时间结构</strong></h2><p>文件中的时间可以理解为一些结构。电影以及每个trak都有一个timescale。它定义了一个时间轴来说明每秒钟有多少个ticks。合理的选择这个数目，就可以实现准确的计时。一般来说，对于audio track，就是audio的sampling rate。对于video track，情况稍微复杂，需要合理选择。例如，如果一个media TimeScale是30000，media sample durations是1001，就准确的定义了NTSC video的时间格式（虽然不准确，但一般就是29.97）。</p><p>每个trak的全部duration定义在文件头部，这就是对track的总结，每个sample有一个规定的duration。一个sample的准确描述时间，也就是他的时间戳(time-stamp)就是以前的sample的duration之和。</p><p>关键词：</p><p>\1. <strong>trak</strong>  表示一些sample的集合，对于媒体数据来说，track表示一个视频或音频序列。</p><p>\2. <strong>sample</strong>  video sample即为一帧视频，或一组连续视频帧，audio sample即为一段连续的压缩音频，它们统称sample。</p><p>\3. <strong>chunk</strong> 一个trak的几个sample组成的单元。</p><p><strong>4. box</strong> box由header和body组成，其中header统一指明box的大小和类型，body根据类型有不同的意义和格式。 标准的box开头的4个字节（32位）为box size，该大小包括box header和box body整个box的大小，这样我们就可以在文件中定位各个box。size后面紧跟的32位为box type，一般是4个字符，如“ftyp”、“moov”等，这些box type都是已经预定义好的，分别表示固定的意义。</p><p>下图为一个典型的MP4文件的结构树：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.165.jpeg alt=[转载]mp4文件格式解析（一） title=[转载]mp4文件格式解析（一）></p><h2 id=115--文件结构分析><strong>11.5 文件结构分析</strong></h2><h3 id=1151--file-type-boxftyp><strong>11.5.1 File Type Box（ftyp）</strong></h3><p><code>    </code>该box有且只有1个，并且只能被包含在文件层，而不能被其他box包含。该box应该被放在文件的最开始，指示该MP4文件应用的相关信息。</p><p>“ftyp” body依次包括1个32位的major brand（4个字符），1个32位的minor version（整数）和1个以32位（4个字符）为单位元素的数组compatible brands。这些都是用来指示文件应用级别的信息。</p><p>该box的字节实例如下：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.166.jpeg alt=[转载]mp4文件格式解析（一） title=[转载]mp4文件格式解析（一）></p><h3 id=1152--movie-boxmoov><strong>11.5.2 Movie Box（moov）</strong></h3><p>该box包含了文件媒体的metadata信息，“moov”是一个container box，具体内容信息由子box诠释。同File Type Box一样，该box有且只有一个，且只被包含在文件层。一般情况下，“moov”会紧随“ftyp”出现。</p><p>一般情况下，“moov”中会包含1个“mvhd”和若干个“trak”。其中“mvhd”为header box，一般作为“moov”的第一个子box出现。</p><h4 id=11511--movie-header-boxmvhd><strong>11.5.1.1 Movie Header Box（mvhd）</strong></h4><p>mvhd定义了整个movie的特性，例如time scale和duration，它的atom类型是'mvhd'。具体字段的表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box size</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。（以下字节数均按version=0）</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>creation time</td><td style=text-align:center>4</td><td style=text-align:center>创建时间（相对于UTC时间1904-01-01零点的秒数）</td></tr><tr><td style=text-align:center>modification time</td><td style=text-align:center>4</td><td style=text-align:center>修改时间</td></tr><tr><td style=text-align:center>time scale</td><td style=text-align:center>4</td><td style=text-align:center>时间缩放因子</td></tr><tr><td style=text-align:center>duration</td><td style=text-align:center>4</td><td style=text-align:center>该视频的时长(整体标记)</td></tr><tr><td style=text-align:center>rate</td><td style=text-align:center>4</td><td style=text-align:center>推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放</td></tr><tr><td style=text-align:center>volume</td><td style=text-align:center>2</td><td style=text-align:center>与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量</td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>10</td><td style=text-align:center>保留位</td></tr><tr><td style=text-align:center>matrix</td><td style=text-align:center>36</td><td style=text-align:center>视频变换矩阵</td></tr><tr><td style=text-align:center>pre-defined</td><td style=text-align:center>24</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>next track id</td><td style=text-align:center>4</td><td style=text-align:center>下一个track使用的id号</td></tr></tbody></table><p>“mvhd”的字节实例如下图，各字段已经用颜色区分开：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.167.jpeg alt=[转载]mp4文件格式解析（一） title=[转载]mp4文件格式解析（一）></p><h4 id=11512--track-boxtrak><strong>11.5.1.2 Track Box（trak）</strong></h4><p><code></code>主数据存储结构，一部movie可以包含一个或多个tracks，它们之间相互独立，各自有各自的时间和空间信息。每个track atom 都有与之关联的media atom。</p><p>trak atoms 的atom类型是'trak'. trak atom要求必须有一个trak header atom ('tkhd') 和一个media atom ('mdia')。其他的track clipping atom ('clip')，track matte atom ('matt')，edit atom ('edts')，track reference atom ('tref')，track load settings atom ('load')，a track input map atom ('imap')以及user data atom ('udta')都是可选的。 具体表结构如下：</p><p><strong>1. Track Header Box（tkhd）</strong></p><p>trak的头信息，具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>意义</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。（以下字节数均按version=0）</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center><p>按位或操作结果值，预定义如下：</p><p>0x000001 track_enabled，否则该track不被播放；</p><p>0x000002 track_in_movie，表示该track在播放中被引用；</p><p>0x000004 track_in_preview，表示该track在预览时被引用。</p><p>一般该值为7，如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项。</p><p></p><p></p></td></tr><tr><td style=text-align:center>creation time</td><td style=text-align:center>4</td><td style=text-align:center><p>创建时间（相对于UTC时间1904-01-01零点的秒数）</p><p></p><p></p></td></tr><tr><td style=text-align:center>modification time</td><td style=text-align:center>4</td><td style=text-align:center><p>修改时间</p><p></p><p></p></td></tr><tr><td style=text-align:center>track id</td><td style=text-align:center>4</td><td style=text-align:center><p>id号，不能重复且不能为0</p><p></p><p></p></td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>4</td><td style=text-align:center><p>保留位</p><p></p><p></p></td></tr><tr><td style=text-align:center>duration</td><td style=text-align:center>4</td><td style=text-align:center><p>trak的时间长度</p><p></p><p></p></td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>8</td><td style=text-align:center><p>保留位</p><p></p><p></p></td></tr><tr><td style=text-align:center>layer</td><td style=text-align:center>2</td><td style=text-align:center><p>视频层，默认为0(跳过)</p><p></p><p></p></td></tr><tr><td style=text-align:center>alternate group</td><td style=text-align:center>2</td><td style=text-align:center><p>trak分组信息，默认为0表示该trak未与其他trak有群组关系</p><p></p><p></p></td></tr><tr><td style=text-align:center>volume</td><td style=text-align:center>2</td><td style=text-align:center><p>[8.8] 格式，如果为音频trak，1.0（0x0100）表示最大音量；否则为0</p><p></p><p></p></td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>2</td><td style=text-align:center><p>保留位</p><p></p><p></p></td></tr><tr><td style=text-align:center>matrix</td><td style=text-align:center>36</td><td style=text-align:center><p>视频变换矩阵</p><p></p><p></p></td></tr><tr><td style=text-align:center>width</td><td style=text-align:center>4</td><td style=text-align:center><p>宽</p><p></p><p></p></td></tr><tr><td style=text-align:center>height</td><td style=text-align:center>4</td><td style=text-align:center><p>高</p><p></p><p></p></td></tr><tr><td style=text-align:center>“tkhd”的字节实例如下图，各字段已经用颜色区分开：</td><td></td><td></td></tr></tbody></table><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.168.jpeg alt=mp4文件格式解析（二） title=mp4文件格式解析（二）></p><p><strong>2. Media Box（mdia）</strong></p><p>“mdia”也是个container box，其子box的结构和种类还是比较复杂的。树结构图如下：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.169.jpeg alt=mp4文件格式解析（二） title=mp4文件格式解析（二）></p><p><code>  </code>总体来说，“mdia”定义了trak媒体类型以及sample数据，描述sample信息。一般“mdia”包含一个“mdhd”，一个“hdlr”和一个“minf”，其中“mdhd”为media header box，“hdlr” 为handler reference box，“minf”为media information box。</p><p><strong>1</strong>. <strong>Media Header Box（mdhd）</strong></p><p>Media header atom 定义了媒体的特性，例如time scale和duration。它的类型是'mdhd'。</p><p>具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>意义</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。（以下字节数均按version=0）</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>creation time</td><td style=text-align:center>4</td><td style=text-align:center>创建时间（相对于UTC时间1904-01-01零点的秒数）</td></tr><tr><td style=text-align:center>modification time</td><td style=text-align:center>4</td><td style=text-align:center>修改时间</td></tr><tr><td style=text-align:center>time scale</td><td style=text-align:center>4</td><td style=text-align:center>时间缩放因子</td></tr><tr><td style=text-align:center>duration</td><td style=text-align:center>4</td><td style=text-align:center>track的时间长度</td></tr><tr><td style=text-align:center>language</td><td style=text-align:center>2</td><td style=text-align:center>媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）</td></tr><tr><td style=text-align:center>pre-defined</td><td style=text-align:center>2</td><td style=text-align:center> </td></tr><tr><td style=text-align:center><strong>2. Handler Reference Box（hdlr）</strong></td><td></td><td></td></tr></tbody></table><p>Handler reference atom 定义了描述此媒体数据的media handler component，类型是'hdlr'。在过去，handler reference atom也可以用来数据引用，现在废弃。一个media atom内的handler atom解释了媒体流的播放过程。例如，一个视频handler处理一个video track。 具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>hdlr</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>Component type</td><td style=text-align:center>4</td><td style=text-align:center><p>handler的类型。当前只有两种类型：</p><p>'mhlr'：media handlers</p><p>'dhlr'：data handlers**(废弃)**</p><p></p><p></p></td></tr><tr><td style=text-align:center>Component subtype</td><td style=text-align:center>4</td><td style=text-align:center><p>media handler or data handler的类型。</p><p>如果component type是mhlr，这个字段定义了数据的类型，可以用来判断该trak的类型，例如，'vide'是video数据，'soun'是sound数据</p><p>如果component type是dhlr，这个字段定义了数据引用的类型(<strong>废弃</strong>)</p><p></p><p></p></td></tr><tr><td style=text-align:center>Component manufacturer</td><td style=text-align:center>4</td><td style=text-align:center><p>保留字段，缺省为0</p><p></p><p></p></td></tr><tr><td style=text-align:center>Component flags</td><td style=text-align:center>4</td><td style=text-align:center><p>保留字段，缺省为0</p><p></p><p></p></td></tr><tr><td style=text-align:center>Component flags mask</td><td style=text-align:center>4</td><td style=text-align:center><p>保留字段，缺省为0</p><p></p><p></p></td></tr><tr><td style=text-align:center>Component name</td><td style=text-align:center>可变</td><td style=text-align:center><p>这个component的名字，也就是生成此media的media handler。该字段的长度可以为0</p><p></p><p></p></td></tr><tr><td style=text-align:center><strong>3. Media Information Atoms - MINF</strong></td><td></td><td></td></tr></tbody></table><p>“minf”存储了解释trak媒体数据的handler-specific信息，media handler用这些信息将媒体时间映射到媒体数据并进行处理。“minf”中的信息格式和内容与媒体类型以及解释媒体数据的media handler密切相关，其他media handler不知道如何解释这些信息。“minf”是一个container box，其实际内容由子box说明。</p><p>一般情况下，“minf”包含一个header box，一个“dinf”和一个“stbl”，其中，header box根据track type（即media handler type）分为“vmhd”、“smhd”，“dinf”为data information box，“stbl”为sample table box。</p><p><strong>3.1 Media Information Header Box（vmhd、smhd）（拆包时可直接跳过）</strong></p><p><strong>Video Media Header Box（vmhd）</strong> </p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>graphics mode</td><td style=text-align:center>4</td><td style=text-align:center><strong>跳过</strong></td></tr><tr><td style=text-align:center>opcolor</td><td style=text-align:center>2×3</td><td style=text-align:center>｛red，green，blue｝</td></tr><tr><td style=text-align:center><strong>Sound Media Header Box（smhd）</strong> </td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。（以下字节数均按version=0）</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>balance</td><td style=text-align:center>2</td><td style=text-align:center>立体声平衡(<strong>跳过</strong>)</td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>2</td><td style=text-align:center> </td></tr><tr><td style=text-align:center><strong>3.2 Data Information Box（dinf）</strong></td><td></td><td></td></tr></tbody></table><p>“dinf”解释如何定位媒体信息，是一个container box。“dinf”一般包含一个“dref”，即data reference box；“dref”下会包含若干个“url”或“urn”，这些box组成一个表，用来定位trak数据。简单的说，trak可以被分成若干段，每一段都可以根据“url”或“urn”指向的地址来获取数据，sample描述中会用这些片段的序号将这些片段组成一个完整的trak。一般情况下，当数据被完全包含在文件中时，“url”或“urn”中的定位字符串是空的。</p><p><strong>“dref”的字节结构如下表：</strong></p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0。（以下字节数均按version=0）</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td style=text-align:center> </td></tr><tr><td style=text-align:center>entry count</td><td style=text-align:center>4</td><td style=text-align:center>“url”或“urn”表的元素个数,每个data reference就像atom的格式一样，包含以下的数据成员</td></tr><tr><td style=text-align:center>“url”或“urn”列表</td><td style=text-align:center>不定</td><td style=text-align:center>“url”或“urn”列表</td></tr><tr><td style=text-align:center><strong>entry的结构如下表：</strong></td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:left>box size</th><th style=text-align:left>4</th><th style=text-align:left>box大小</th></tr></thead><tbody><tr><td style=text-align:left>box type</td><td style=text-align:left>4</td><td style=text-align:left>见下表</td></tr><tr><td style=text-align:left>version</td><td style=text-align:left>1</td><td style=text-align:left>这个data reference的版本</td></tr><tr><td style=text-align:left>flags</td><td style=text-align:left>3</td><td style=text-align:left><p>目前只有一个标志：</p><p>Self reference</p><p>This flag indicates that the media’s data is in the same file as the movie atom. On the Macintosh, and other file systems with multifork files, set this flag to 1 even if the data resides in a different fork from the movie atom. This flag’s value is 0x0001.</p><p></p><p></p></td></tr><tr><td style=text-align:left>数据</td><td style=text-align:left>可变</td><td style=text-align:left><p>data reference信息</p><p></p><p></p></td></tr></tbody></table><p><strong>data reference具体结构如下：</strong></p><table><thead><tr><th style=text-align:center><strong>类型</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>alis</td><td style=text-align:center>Data reference是一个Macintosh alias。一个alias包含文件信息，例如全路径名。</td></tr><tr><td style=text-align:center>rsrc</td><td style=text-align:center>Data reference是一个Macintosh alias。Alias末尾是文件使用的资源类型（32bit整数）和ID（16bit带符号的整数）</td></tr><tr><td style=text-align:center>url</td><td style=text-align:center>一个C类型的字符串，表示一个URL。字符串后可以有其他的数据。</td></tr><tr><td style=text-align:center><strong>3.3 Sample Table Box（stbl）（重要）</strong></td><td></td></tr></tbody></table><p>“stbl”包含了关于trak中sample所有时间和位置的信息，以及sample的编解码等信息。利用这个表，可以解释sample的时序、类型、大小以及在各自存储容器中的位置。“stbl”是一个container box，其子box包括：sample description box（stsd）、time to sample box（stts）、sample size box（stsz或stz2）、sample to chunk box（stsc）、chunk offset box（stco或co64）、composition time to sample box（ctts）、sync sample box（stss）等。</p><p><strong>3.3.1 Sample Description Atoms - STSD</strong></p><p>“stsd”必不可少，且至少包含一个条目，该box包含了data reference box进行sample数据检索的信息。没有“stsd”就无法计算media sample的存储位置。“stsd”包含了编码的信息，其存储的信息随媒体类型不同而不同。</p><p>在认识stsd之前我们首先需要了解一个数据结构SampleEntry和它的子类AudioSampleEntry,VisualSampleEntry,HintSampleEntry(不作分析)，具体关系如下：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.170.png alt=sample\_e title=sampleentry></p><p>SampleEntry 是一个继成box的抽象的数据结构模型，具体如下表：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>box类型(根据该值查找视频格式id表获得编码器类型，如"avc1"通过查表标记为H264_ID类型)(重要)</td></tr><tr><td style=text-align:center>resved</td><td style=text-align:center>6</td><td style=text-align:center>保留字段,(跳过)</td></tr><tr><td style=text-align:center>drefid</td><td style=text-align:center>2</td><td style=text-align:center>无用(跳过)</td></tr><tr><td style=text-align:center>VisualSampleEntry(类型为"avc1")继承于SampleEntry ，具体结构如下表：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>SampleEntry</td><td style=text-align:center>16</td><td style=text-align:center>SampleEntry</td></tr><tr><td style=text-align:center>resved</td><td style=text-align:center>16</td><td style=text-align:center>保留字段(<strong>跳过</strong>)</td></tr><tr><td style=text-align:center>width</td><td style=text-align:center>2</td><td style=text-align:center>宽度</td></tr><tr><td style=text-align:center>height</td><td style=text-align:center>2</td><td style=text-align:center>高度</td></tr><tr><td style=text-align:center>hrsl</td><td style=text-align:center>4</td><td style=text-align:center>水平分辨率</td></tr><tr><td style=text-align:center>vtsl</td><td style=text-align:center>4</td><td style=text-align:center>垂直分辨率</td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>4</td><td style=text-align:center>一直为0</td></tr><tr><td style=text-align:center>frame_count</td><td style=text-align:center>2</td><td style=text-align:center>每个采样里面的贞数,一般是1</td></tr><tr><td style=text-align:center>compressorname</td><td style=text-align:center>4</td><td style=text-align:center>字符串，对齐到32位，(无用跳过)</td></tr><tr><td style=text-align:center>depth</td><td style=text-align:center>2</td><td style=text-align:center>视频的色深 0x18 表示24位色</td></tr></tbody></table><p>AudioSampleEntry(类型为"mp4a")继承于SampleEntry ,具体结构如下表：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>SampleEntry</td><td style=text-align:center>16</td><td style=text-align:center>SampleEntry</td></tr><tr><td style=text-align:center>resved</td><td style=text-align:center>16</td><td style=text-align:center>保留字段(<strong>跳过</strong>)</td></tr><tr><td style=text-align:center>channelcount</td><td style=text-align:center>2</td><td style=text-align:center>声道数1或者2</td></tr><tr><td style=text-align:center>samplesize</td><td style=text-align:center>2</td><td style=text-align:center>采样位宽 一般为8bit 或16bit</td></tr><tr><td style=text-align:center>reserved</td><td style=text-align:center>4</td><td style=text-align:center>保留字段(跳过)</td></tr><tr><td style=text-align:center>samplerate</td><td style=text-align:center>4</td><td style=text-align:center>采样率</td></tr><tr><td style=text-align:center>esds扩展(重要)</td><td style=text-align:center></td><td style=text-align:center>如果audio type为AAC,需要读取esds扩展，否则音频无法解码。</td></tr><tr><td style=text-align:center>version + flags</td><td style=text-align:center>4</td><td style=text-align:center>version + flags</td></tr><tr><td style=text-align:center>tag</td><td style=text-align:center>1</td><td style=text-align:center>决定的后续的解析</td></tr><tr><td style=text-align:center>descr length</td><td style=text-align:center>4</td><td style=text-align:center><strong>跳过</strong></td></tr><tr><td style=text-align:center>Id+priority</td><td style=text-align:center>2或2+1</td><td style=text-align:center><p>如果tag='0x03'为2个字节(<strong>跳过</strong>)</p><p>其他值为2+1个字节(<strong>跳过</strong>)</p><p></p><p></p></td></tr><tr><td style=text-align:center>tag</td><td style=text-align:center>1</td><td style=text-align:center><p>决定的后续的解析，如果解析正确该值为"0x04"</p><p></p><p></p></td></tr><tr><td style=text-align:center>descr length</td><td style=text-align:center>4</td><td style=text-align:center><p><strong>跳过</strong></p><p></p><p></p></td></tr><tr><td style=text-align:center>audio type id</td><td style=text-align:center>1</td><td style=text-align:center><p>如果解析正确为'0x40',为CODEC_ID_AAC类型</p><p></p><p></p></td></tr><tr><td style=text-align:center>resved</td><td style=text-align:center>1+3+4+4</td><td style=text-align:center><p><strong>跳过</strong></p><p></p><p></p></td></tr><tr><td style=text-align:center>tag</td><td style=text-align:center>1</td><td style=text-align:center><p>如果解析正确为'0x05'</p><p></p><p></p></td></tr><tr><td style=text-align:center>descr length</td><td style=text-align:center>4</td><td style=text-align:center><p>Descr data的长度</p><p></p><p></p></td></tr><tr><td style=text-align:center>Descr data</td><td style=text-align:center>n</td><td style=text-align:center><p>0-3位为采样率查表index</p><p>4-7位为声道的数目</p><p>具体其他信息关系到sbr的一些参数，具体请参看官方文档</p><p></p><p></p></td></tr></tbody></table><p>其他的实体格式如AMRSampleEntry AMRWPSampleEntry H263SampleEntry等分析同上。</p><p>对于"stsd"的表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>box size</td><td style=text-align:center>4</td><td style=text-align:center>box大小</td></tr><tr><td style=text-align:center>box type</td><td style=text-align:center>4</td><td style=text-align:center>该类型为"stsd"</td></tr><tr><td style=text-align:center>version</td><td style=text-align:center>1</td><td style=text-align:center>box版本，0或1，一般为0</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center>3</td><td></td></tr><tr><td style=text-align:center>entry count</td><td style=text-align:center>4</td><td style=text-align:center>entry的个数</td></tr><tr><td style=text-align:center>entry</td><td style=text-align:center>n</td><td style=text-align:center>具体参考上表</td></tr><tr><td style=text-align:center><strong>3.3.2 Time-to-Sample Atoms - STTS</strong></td><td></td><td></td></tr></tbody></table><p>Time-to-sample atoms存储了media sample的duration 信息，提供了时间对具体data sample的映射方法，通过这个atom，你可以找到任何时间的sample，类型是'stts'。</p><p>这个atom可以包含一个压缩的表来映射时间和sample序号，用其他的表来提供每个sample的长度和指针。表中每个条目提供了在同一个时间偏移量里面连续的sample序号， 以及samples的偏移量。递增这些偏移量，就可以建立一个完整的time-to-sample表，计算公式如下</p><p>DT(n+1) = DT(n) + STTS(n)</p><p>其中STTS(n)是没有压缩的STTS第n项信息，DT是第n个sample的显示时间。Sample的排列是按照时间戳的顺序，这样偏移量永远是非负的。DT一般以0开始，如果不为0，edit list atom 设定初始的DT值。DT计算公式如下</p><p>DT(i) = SUM (for j=0 to i-1 of delta(j))</p><p>所有偏移量的和就是trak中media的时间的长度。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.171.png alt></p><table><thead><tr><th><code> </code><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td>类型</td><td style=text-align:center>4</td><td style=text-align:center>stts</td></tr><tr><td>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>time-to-sample的数目</td></tr><tr><td>time-to-sample</td><td style=text-align:center> </td><td style=text-align:center>Media中每个sample的duration。包含如下结构</td></tr><tr><td>Sample count</td><td style=text-align:center>4</td><td style=text-align:center>有相同duration的连续sample的数目</td></tr><tr><td>Sample duration</td><td style=text-align:center>4</td><td style=text-align:center>每个sample的duration</td></tr><tr><td>如果多个sample有相同的duration，可以只用一项描述所有这些samples，数量字段说明sample的个数。例如，如果一个视频媒体的帧率保持不变，整个表可以只有一项，数量就是全部的帧数。</td><td></td><td></td></tr></tbody></table><p><strong>3.3.3 Sync Sample Atoms - STSS</strong></p><p>sync sample atom确定media中的关键帧。对于压缩的媒体，关键帧是一系列压缩序列的开始帧，它的解压缩是不依赖于以前的帧。后续帧的解压缩依赖于这个关键帧。</p><p>sync sample atom可以非常紧凑的标记媒体内的随机存取点。它包含一个sample序号表，表内的每一项严格按照sample的序号排列，说明了媒体中的哪一个sample是关键帧。如果此表不存在，说明每一个sample都是一个关键帧，是一个随机存取点。</p><p>Sync sample atoms 的类型是'stss'。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.172.png alt></p><p>具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>stss</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>sync sample的数目</td></tr><tr><td style=text-align:center>sync sample</td><td style=text-align:center> </td><td style=text-align:center>sync sample表的结构</td></tr><tr><td style=text-align:center>Sample序号</td><td style=text-align:center>4</td><td style=text-align:center>是关键帧的sample序号</td></tr></tbody></table><p><strong>3.3.4 Sample-to-Chunk Atoms - STSC</strong></p><p>当添加samples到media时，用chunks组织这些sample，这样可以方便优化数据获取。一个trunk包含一个或多个sample，chunk的长度可以不同，chunk内的sample的长度也可以不同。sample-to-chunk atom存储sample与chunk的映射关系。</p><p>Sample-to-chunk atoms的类型是'stsc'。它也有一个表来映射sample和trunk之间的关系，查看这张表，就可以找到包含指定sample的trunk，从而找到这个sample。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.173.png alt></p><p>具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>stsc</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>sample-to-chunk的数目</td></tr><tr><td style=text-align:center>sample-to-chunk</td><td style=text-align:center> </td><td style=text-align:center>sample-to-chunk表的结构</td></tr><tr><td style=text-align:center>First chunk</td><td style=text-align:center>4</td><td style=text-align:center>这个table使用的第一个chunk序号</td></tr><tr><td style=text-align:center>Samples per chunk</td><td style=text-align:center>4</td><td style=text-align:center>当前trunk内的sample数目</td></tr><tr><td style=text-align:center>Sample description ID</td><td style=text-align:center>4</td><td style=text-align:center>与这些sample关联的sample description的序号</td></tr><tr><td style=text-align:center><strong>3.3.5 Sample Size Atoms - STSZ</strong></td><td></td><td></td></tr></tbody></table><p>sample size atoms定义了每个sample的大小，它的类型是'stsz'，包含了媒体中全部sample的数目和一张给出每个sample大小的表。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.174.png alt></p><p>具体的表的结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>stsz</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>Sample size</td><td style=text-align:center>4</td><td style=text-align:center>全部sample的数目。如果所有的sample有相同的长度，这个字段就是这个值。否则，这个字段的值就是0。那些长度存在sample size表中</td></tr><tr><td style=text-align:center>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>sample size的数目</td></tr><tr><td style=text-align:center>sample size</td><td style=text-align:center><code> </code>4</td><td style=text-align:center>sample size表的结构。这个表根据sample number索引，第一项就是第一个sample，第二项就是第二个sample</td></tr><tr><td style=text-align:center><strong>3.3.5 Chunk Offset Atoms - STCO</strong></td><td></td><td></td></tr></tbody></table><p>Chunk offset atoms 定义了每个trunk在媒体流中的位置，它的类型是'stco'。位置有两种可能，32位的和64位的，后者对非常大的电影很有用。在一个表中只会有一种可能，这个位置是在整个文件中的，而不是在任何atom中的，这样做就可以直接在文件中找到媒体数据，而不用解释atom。需要注意的是一旦前面的atom有了任何改变，这张表都要重新建立，因为位置信息已经改变了。</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.175.png alt></p><p>具体表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>"stco"或"co64"</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>chunk offset的数目</td></tr><tr><td style=text-align:center>chunk offset</td><td style=text-align:center> </td><td style=text-align:center>字节偏移量从文件开始到当前chunk。这个表根据chunk number索引，第一项就是第一个chunk，第二项就是第二个chunk</td></tr><tr><td style=text-align:center>大小</td><td style=text-align:center>n</td><td style=text-align:center><p>每个sample的大小,如果类型="scto" 大小为4个字节，如果类型="co64"，大小为8个字节</p><p></p><p></p></td></tr></tbody></table><p><strong>3.3.6 Composition Time to Sample Box- CTTS</strong></p><p>Composition Time to Sample Box 提供了在dts(解码时间戳)与pts(显示时间戳)的时间的偏移量，它的类型是'ctts'。因为需要纠正时间的帧的pts一定比dts要大，所以每一个项的值一定是正值。具体可以通过pts(n)=dts(n)+ctts(n)进行简单计算。</p><p>具体的表结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位：byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>尺寸</td><td style=text-align:center>4</td><td style=text-align:center>这个atom的字节数</td></tr><tr><td style=text-align:center>类型</td><td style=text-align:center>4</td><td style=text-align:center>"ctts"</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>这个atom的版本</td></tr><tr><td style=text-align:center>标志</td><td style=text-align:center>3</td><td style=text-align:center>这里为0</td></tr><tr><td style=text-align:center>条目数目</td><td style=text-align:center>4</td><td style=text-align:center>ctts的数目</td></tr><tr><td style=text-align:center>Sample count</td><td style=text-align:center>4 </td><td style=text-align:center>有相同的Sample_offset的连续sample的数目</td></tr><tr><td style=text-align:center>Sample_offset</td><td style=text-align:center>4</td><td style=text-align:center>dts与pts的时间的残差</td></tr></tbody></table><h1 id=第十二章-flv-文件格式分析><strong>第十二章</strong> flv 文件格式分析</h1><h2 id=121--概述><strong>12.1 概述</strong></h2><p><code></code>FLV视频格式是Adobe公司设计开发的一种流媒体的封装格式，总体上看，FLV包括文件头（Flv Header）和文件体（Flv Body）两部分，其中文件体由一系列的Tag及Tag Size对组成。Tag又可以分成三类:audio,video,script，分别代表音频流，视频流，脚本流（关键字或者文件信息之类）。</p><h2 id=122--文件总体结构><strong>12.2 文件总体结构</strong></h2><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.176.jpeg alt></p><p>其中，Previous Tag Size紧跟在每个Tag之后，占4个字节表示一个UI32类型的数值，表示前面一个Tag的大小。需要注意的是，Previous Tag Size #0的值总是为0。Tag类型包括视频、音频和Script，且每个Tag只能包含一种类型的数据。</p><p>具体的工具分析如下：</p><p><img src=/images/2020/ffmpeg/Aspose.Words.a0ce5ffc-99a8-4e85-b952-e75d3ea7f9c4.177.jpeg alt title=0{YA]KF}OB]KP08[@_9G78Q></p><h2 id=123--文件结构分析><strong>12.3 文件结构分析</strong></h2><h3 id=1231--flv文件头的结构><strong>12.3.1 flv文件头的结构</strong></h3><p><code></code>在ffmpeg进行格式识别的时候，是以头部的前3个字节进行探测，识别到'F' 'L' 'V'即可认定该格式为flv格式。</p><table><thead><tr><th style=text-align:center><strong>FLV 头部</strong></th><th style=text-align:center><strong>长度(byte)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>文件类型</td><td style=text-align:center>3</td><td style=text-align:center>'F' (0x46) 'L' (0x4C) 'V' (0x56)</td></tr><tr><td style=text-align:center>版本</td><td style=text-align:center>1</td><td style=text-align:center>版本，目前为1（0x01）</td></tr><tr><td style=text-align:center>流信息</td><td style=text-align:center>1</td><td style=text-align:center><p>1. UB[7]~UB[3]，前5位保留，必须为0。</p><p>2. UB[2] 表示是否存在音频Tag。</p><p>3. UB[1] 该位保留，必须为0。</p><p>4. UB[0] 表示是否存在视频。</p><p></p><p></p></td></tr><tr><td style=text-align:center>header长度</td><td style=text-align:center>4</td><td style=text-align:center><p>整个文件头的长度，一般是9（3+1+1+4）。个人感觉该字段多余，可以去掉。</p><p></p><p></p></td></tr><tr><td style=text-align:center>由于第一个标识长度的4字节签名无tag，但为了格式上的统一，所以可以划为头部。</td><td></td><td></td></tr></tbody></table><h3 id=1232--body主体结构><strong>12.3.2 body主体结构</strong></h3><p><code></code>Tag包括Tag Header和Tag Data两部分。不同类型的Tag的Header结构是相同的，但是Data结构各不相同。</p><p>当前版本的Tag Header结构占用11个字节。</p><p>12.3.2.1 Tag Header结构</p><p><code></code>基于现在版本的Tag Header结构固定占用11个字节，具体描述见下表：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（byte）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>tag type</td><td style=text-align:center>1</td><td style=text-align:center>Tag的类型，值：audio=（0x08）、video=（0x09）和script data=（0x12），其他类型值被保留,一般可以直接忽略掉。</td></tr><tr><td style=text-align:center>data size</td><td style=text-align:center>3</td><td style=text-align:center>表示该Tag 真实Data部分的大小。</td></tr><tr><td style=text-align:center>timestamp</td><td style=text-align:center>3</td><td style=text-align:center>表示该Tag的时间戳（单位为ms），第一个Tag的时间戳总是0。</td></tr><tr><td style=text-align:center>timestampExtended</td><td style=text-align:center>1</td><td style=text-align:center>当时间戳24位数值不够时，该字节作为最高位将时间戳扩展为32位值。左移24位与Timestamp值进行或操作</td></tr><tr><td style=text-align:center>streamID</td><td style=text-align:center>3</td><td style=text-align:center>表示stream id，总是0</td></tr><tr><td style=text-align:center>12.3.2.2 Tag Data结构</td><td></td><td></td></tr></tbody></table><p><code></code>音视频Tag用开始的第1个字节包含视频数据的参数信息，根据Tag Header中的Tag Type类型值为8(音频),值为9(视频),该头部表示的意义会不同，具体结构如下：</p><p>1 <strong>音频类型结构如下</strong></p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度(单位:bit)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>audio format</td><td style=text-align:center>4</td><td style=text-align:center><p>0 -- 未压缩　　</p><p>1 -- ADPCM 　　</p><p>2 -- MP3 　　</p><p>5 -- Nellymoser 8kHz momo 　　</p><p>6 -- Nellymoser 　　</p><p>7 --G.711 A-law logarithmic PCM</p><p>8 --G.711 mu-law logarithmic PCM</p><p>9 -- reserved</p><p>10 --AAC(需要后面附加1个字节，具体见下文)</p><p>11 --Speex</p><p>14--MP3 8-kHz</p><p>15 --Device -specific sound</p><p>Formats 7, 8, 14, and 15 为保留字段，ffmpeg拆包直接跳过</p><p></p><p></p></td></tr><tr><td style=text-align:center>samplerate</td><td style=text-align:center>2</td><td style=text-align:center><p>0 -- 5.5kHz 　　</p><p>1 -- 11kHz 　　</p><p>2 -- 22kHz 　　</p><p>3 -- 44kHz 　</p><p>没有8kHz的采样率，音频8KHz，一般为人声通话的amr格式所采用，所以该字段和Audio format字段都没有提及。</p><p></p><p></p></td></tr><tr><td style=text-align:center>sample length</td><td style=text-align:center>1</td><td style=text-align:center><p>即每一帧所占用的位宽。</p><p>0 -- 8Bit 　　</p><p>1 -- 16Bit</p><p></p><p></p></td></tr><tr><td style=text-align:center>channel type</td><td style=text-align:center>1</td><td style=text-align:center><p>0 --Momo(单声道) 　　</p><p>1 -- Stereo(立体声)</p><p></p><p></p></td></tr><tr><td style=text-align:center>AAC需要注意：</td><td></td><td></td></tr></tbody></table><p>如果SoundFormat是10 (AAC)，TagDataHeader后紧随着一个1个字节的数据AACPacketType，这个字段来表示AACAUDIODATA的类型：0 = AAC sequence header，1 = AAC raw。在flv中一般情况下，带有该AACPacketType 的Tag只会在第一个audio Tag中出现一次，因为aac格式的音频需要在每帧AAC ES流前边添加7个字节ADST头(相当于帧头)，就是AAC的纯ES流要打包成ADST格式的AAC文件，解码器才能正常播放.特别对于RTSP,RTP等实时传输流，ADST必须存在，否则传输过来的流不知道该怎么播放。</p><p>1 <strong>视频类型结构如下</strong></p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度（单位:bit）</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>video format</td><td style=text-align:center>4</td><td style=text-align:center><p>1 -- keyframe 　　</p><p>2 -- inner frame 　　</p><p>3 -- disposable inner frame (H.263 only)</p><p></p><p></p></td></tr><tr><td style=text-align:center><p>codec id</p><p></p></td><td style=text-align:center>4</td><td style=text-align:center><p>1 = JPEG（废弃）</p><p>2 -- Seronson H.263 　　</p><p>3 -- Screen video 　　</p><p>4 -- On2 VP6 　</p><p>5 -- On2 VP6 without channel 　　</p><p>6 -- Screen video version 2 　</p><p>7 -- AVC(h264)</p><p></p><p></p></td></tr><tr><td style=text-align:center>大小为：Tag Header中的Data size - Tag Data Header,根据大小读取数据即可。</td><td></td><td></td></tr></tbody></table><p>12.3.2.3 script Tag结构如下</p><p>如果TAG包中的TagType==18时，就表示这个TAG是SCRIPT Tag。该类型Tag又通常被称为Metadata Tag，会放一些关于FLV视频和音频的参数信息，如duration、width、height等。通常该类型Tag会跟在File Header后面作为第一个Tag出现，而且只有一个。</p><p>一般来说，该Tag Data结构包含两个AMF包。AMF（Action Message Format）是Adobe设计的一种通用数据封装格式，在Adobe的很多产品中应用，简单来说，AMF不区分根节点与子节点，将不同类型的数据用统一的格式来描述。第一个AMF包封装字符串类型数据，即：“02” type+string length+“onMetaData”。第二个AMF包封装一个数组类型，这个数组中包含了音视频信息项的名称和值。</p><p>AMF具体表定义和结构如下：</p><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度(单位:byte)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>data type</td><td style=text-align:center>1</td><td style=text-align:center>数据的类型</td></tr><tr><td style=text-align:center>data</td><td style=text-align:center>n</td><td style=text-align:center><p>If Type = 0, DOUBLE(8个字节)</p><p>If Type = 1, BOOL(1个字节)</p><p>If Type = 2, 后续:2字节(表征字符串长度)+字符串数据</p><p>If Type = 3, 遵从Object memeber表结构，可以看做array的一个数据项。</p><p>If Type = 8, 遵从MixedArray结构表。</p><p>If Type = 10,遵从normal array表。</p><p>If Type = 11,日期类型</p><p></p><p></p></td></tr><tr><td style=text-align:center>Type='0x08' MixedArray内部结构定义：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度(单位:byte)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>object number</td><td style=text-align:center>4</td><td style=text-align:center>数组中包括的对象数目。</td></tr><tr><td style=text-align:center>object memeber</td><td style=text-align:center>n</td><td style=text-align:center>数据成员具体见下表。</td></tr><tr><td style=text-align:center>end flag</td><td style=text-align:center>3</td><td style=text-align:center>数组的结束标志总为'0x09'。</td></tr><tr><td style=text-align:center>MixedArray Object memeber具体结构如下（采用key-value结构）：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度(单位:byte)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>key length</td><td style=text-align:center>2</td><td style=text-align:center>对象的名称长度。</td></tr><tr><td style=text-align:center>stringData</td><td style=text-align:center>n</td><td style=text-align:center>对象名称，长度由StringLength指出。</td></tr><tr><td style=text-align:center>object type</td><td style=text-align:center>1</td><td style=text-align:center>遵从AMF定义，可以为数组。</td></tr><tr><td style=text-align:center>data</td><td style=text-align:center>n</td><td style=text-align:center>遵从AMF定义。</td></tr><tr><td style=text-align:center>Type='0x0a' normal array表结构：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>长度(单位:byte)</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>object number</td><td style=text-align:center>4</td><td style=text-align:center>数组中包括的对象数目。</td></tr><tr><td style=text-align:center>object member</td><td style=text-align:center>n</td><td style=text-align:center>遵从AMF表结构。</td></tr><tr><td style=text-align:center>end flag</td><td style=text-align:center>3</td><td style=text-align:center>数组的结束标志总为'0x09'。</td></tr><tr><td style=text-align:center>在script tag中常用的字段的键表如下：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:center><strong>字段</strong></th><th style=text-align:center><strong>类型</strong></th><th style=text-align:center><strong>描述</strong></th></tr></thead><tbody><tr><td style=text-align:center>hasKeyFrames</td><td style=text-align:center>bool</td><td style=text-align:center>无</td></tr><tr><td style=text-align:center>hasVideo</td><td style=text-align:center>bool</td><td style=text-align:center>无</td></tr><tr><td style=text-align:center>hasAudio</td><td style=text-align:center>bool</td><td style=text-align:center>无</td></tr><tr><td style=text-align:center>hasMetaData</td><td style=text-align:center>bool</td><td style=text-align:center>无</td></tr><tr><td style=text-align:center>canSeekToEnd</td><td style=text-align:center>bool</td><td style=text-align:center>无</td></tr><tr><td style=text-align:center>duration</td><td style=text-align:center>Number</td><td style=text-align:center>单位为秒</td></tr><tr><td style=text-align:center>datasize</td><td style=text-align:center>Number</td><td style=text-align:center>实际的音视频数据的总的大小</td></tr><tr><td style=text-align:center>videosize</td><td style=text-align:center>Number</td><td style=text-align:center>实际的视频数据的大小</td></tr><tr><td style=text-align:center>audiosize</td><td style=text-align:center>Number</td><td style=text-align:center>实际的音频数据的大小</td></tr><tr><td style=text-align:center>width</td><td style=text-align:center>Number</td><td style=text-align:center>视频的原始的宽度</td></tr><tr><td style=text-align:center>height</td><td style=text-align:center>Number</td><td style=text-align:center>视频的原始的高度</td></tr><tr><td style=text-align:center>framerate</td><td style=text-align:center>Number</td><td style=text-align:center>视频的帧率</td></tr><tr><td style=text-align:center>videodatarate</td><td style=text-align:center>Number</td><td style=text-align:center>数值*1024为比特率</td></tr><tr><td style=text-align:center>audiosamplerate</td><td style=text-align:center>Number</td><td style=text-align:center>音频采样率</td></tr><tr><td style=text-align:center>audiosmplesize</td><td style=text-align:center>Number</td><td style=text-align:center>音频每个sample的位宽</td></tr><tr><td style=text-align:center>filesize</td><td style=text-align:center>Number</td><td style=text-align:center>整体文件的大小</td></tr><tr><td style=text-align:center>lastkeyframestamp</td><td style=text-align:center>Number</td><td style=text-align:center>最后关键帧的时间戳</td></tr><tr><td style=text-align:center>lastkeyframelocation</td><td style=text-align:center>Number</td><td style=text-align:center>最后关键帧的在文件中的偏移量</td></tr><tr><td style=text-align:center><strong>附加关键帧索引(Keyframes)</strong></td><td></td><td></td></tr></tbody></table><p><code></code>Adobe的官方文档中并没有keyframes头，但是由于flv的每一个tag没有同步头，所以在进行seek时只能不断的通过往下读取数据来进行判断，这在网络流媒体播放时是不能忍受的(优酷的flv都带有keyframes)所以在script tag中加入了该关键帧的索引表，以进行快速的seek等操作。包含着2个内容 'filepositions' and 'times'分别指的是关键帧的文件位置和关键帧的PTS.通过keyframes可以建立起自己的Index，然后再seek和快进快退的操作中，快速有效的跳转到你想要找的关键帧的位置进行处理。</p><p>具体结构如下：</p><p>keyframes</p><p><code></code>- filepositions(在文件中的offset) value(普通数组，遵从amf协议)</p><p><code></code>-times(关键帧的时间) value(普通数组，遵从amf协议)。</p><h1 id=附录a常见问题><strong>附录A：常见问题</strong></h1><h2 id=1-ffmpeg-从内存中读取数据httpblogcsdnnetleixiaohua1020articledetails12980423><strong>1 <a href=http://blog.csdn.net/leixiaohua1020/article/details/12980423>ffmpeg 从内存中读取数据**</a></strong></h2><p>ffmpeg一般情况下支持打开一个本地文件，例如“C:\test.avi”</p><p>或者是一个流媒体协议的URL，例如“rtmp://222.31.64.208/vod/test.flv”</p><p>其打开文件的函数是avformat_open_input()，直接将文件路径或者流媒体URL的字符串传递给该函数就可以了。</p><p>但其是否支持从内存中读取数据呢？这个问题困扰了我很长时间。当时在做项目的时候，通过Winpcap抓取网络上的RTP包，打算直接送给ffmpeg进行解码。一直没能找到合适的方法。因为抓取的数据包是存在内存中的，所以无法传递给avformat_open_input()函数其路径（根本没有路径= =）。当然也可以将抓取的数据报存成文件，然后用ffmpeg打开这个文件，但是这样的话，程序的就太难控制了。</p><p>后来经过分析ffmpeg的源代码，发现其竟然是可以从内存中读取数据的，代码很简单，如下所示：</p><p>AVFormatContext *ic = NULL;</p><p>ic = avformat_alloc_context();</p><p>unsigned char * iobuffer=(unsigned char *)av_malloc(32768);</p><p>AVIOContext *avio =avio_alloc_context(iobuffer, 32768,0,buffer,fill_iobuffer,NULL,NULL);</p><p>ic->pb=avio;</p><p>err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);</p><p>关键要在avformat_open_input()之前初始化一个AVIOContext，而且将原本的AVFormatContext的指针pb（AVIOContext类型）指向这个自行初始化AVIOContext。当自行指定了AVIOContext之后，avformat_open_input()里面的URL参数就不起作用了。示例代码开辟了一块空间iobuffer作为AVIOContext的缓存。</p><p>此外buffer就是期望读取数据的内存，fill_iobuffer则是读取buffer数据至iobuffer的回调函数。fill_iobuffer()形式（参数，返回值）是固定的，是一个回调函数，如下所示（只是个例子，具体怎么读取数据可以自行设计）。</p><p>//把数据从buffer向iobuf传-------------------------</p><p>//AVIOContext使用的回调函数！</p><p>//注意：返回值是读取的字节数</p><p>//手动初始化AVIOContext只需要两个东西：内容来源的buffer，和读取这个Buffer到FFmpeg中的函数</p><p>int fill_iobuffer(void * buffer,uint8_t *iobuf, int bufsize){</p><p><code></code>int i;</p><p><code></code>for(i=0;i&lt;bufsize;i++){</p><p><code></code>iobuf[i]=mediabuf_get();</p><p><code></code>}</p><p><code></code>return i;</p><p>}</p><h2 id=2-mfc中使用sdl播放音频没有声音的解决方法httpblogcsdnnetleixiaohua1020articledetails15029951><strong>2 <a href=http://blog.csdn.net/leixiaohua1020/article/details/15029951>MFC中使用SDL播放音频没有声音的解决方法**</a></strong></h2><p>此处所说的音频是指的纯音频，不包含视频的那种。</p><p>在控制台中使用SDL播放音频，一般情况下不会有问题。</p><p>但是在MFC中使用SDL播放音频的时候，会出现没有声音的情况。经过长时间探索，没有找到特别好的解决方案，但是有一种方式可以让声音播放出来：那就是让SDL显示图像（视频）时候的那个对话框弹出来，声音就会出现了。</p><p>具体的方法可以加载一张图片（比如说BMP），下图所示代码片段为加载BMP图片的代码。</p><p>SDL_Surface *screen = SDL_SetVideoMode(640, 480, 8, SDL_SWSURFACE);</p><p>SDL_Surface *image;</p><p>/* Load the BMP file into a surface */</p><p>image = SDL_LoadBMP("background.bmp");</p><p>if (image == NULL) {</p><p><code></code>return 0;</p><p>}</p><p>/*</p><p>* Palettized screen modes will have a default palette (a standard</p><p>* 8*8*4 colour cube), but if the image is palettized as well we can</p><p>* use that palette for a nicer colour matching</p><p>*/</p><p>if (image->format->palette && screen->format->palette) {</p><p><code></code>SDL_SetColors(screen, image->format->palette->colors, 0,</p><p><code></code>image->format->palette->ncolors);</p><p>}</p><p>/* Blit onto the screen surface */</p><p>if(SDL_BlitSurface(image, NULL, screen, NULL) &lt; 0)</p><p><code></code>fprintf(stderr, "BlitSurface error: %s\n", SDL_GetError());</p><p>SDL_UpdateRect(screen, 0, 0, image->w, image->h);</p><p>不明白这是为什么，但是程序就可以出声了。</p><h1 id=附录b经典代码示例><strong>附录B：经典代码示例</strong></h1><p><strong>output_example.c事例代码</strong></p><p>#include &lt;stdlib.h></p><p>#include &lt;stdio.h></p><p>#include &lt;string.h></p><p>#include &lt;math.h></p><p>#ifndef M_PI</p><p>#define M_PI 3.14159265358979323846</p><p>#endif</p><p>#include "libavformat/avformat.h"</p><p>#include "libswscale/swscale.h"</p><p>#undef exit</p><p>/* 5 seconds stream duration */</p><p>#define STREAM_DURATION 5.0</p><p>#define STREAM_FRAME_RATE 25 /* 25 images/s */</p><p>#define STREAM_NB_FRAMES ((int)(STREAM_DURATION * STREAM_FRAME_RATE))</p><p>#define STREAM_PIX_FMT PIX_FMT_YUV420P /* default pix_fmt */</p><p>static int sws_flags = SWS_BICUBIC;</p><p>/**************************************************************/</p><p>/* audio output */</p><p>float t, tincr, tincr2;</p><p>int16_t *samples;</p><p>uint8_t *audio_outbuf;</p><p>int audio_outbuf_size;</p><p>int audio_input_frame_size;</p><p>/*</p><p><code></code>* add an audio output stream</p><p><code></code>*/</p><p>static AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)</p><p>{</p><p><code></code>AVCodecContext *c;</p><p><code></code>AVStream *st;</p><p><code></code>st = av_new_stream(oc, 1);</p><p><code></code>if (!st) {</p><p><code></code>fprintf(stderr, "Could not alloc stream\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>c = st->codec;</p><p><code></code>c->codec_id = codec_id;</p><p><code></code>c->codec_type = CODEC_TYPE_AUDIO;</p><p><code></code>/* put sample parameters */</p><p><code></code>c->bit_rate = 64000;</p><p><code></code>c->sample_rate = 44100;</p><p><code></code>c->channels = 2;</p><p><code></code>return st;</p><p>}</p><p>static void open_audio(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>AVCodecContext *c;</p><p><code></code>AVCodec *codec;</p><p><code></code>c = st->codec;</p><p><code></code>/* find the audio encoder */</p><p><code></code>codec = avcodec_find_encoder(c->codec_id);</p><p><code></code>if (!codec) {</p><p><code></code>fprintf(stderr, "codec not found\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/* open it */</p><p><code></code>if (avcodec_open(c, codec) &lt; 0) {</p><p><code></code>fprintf(stderr, "could not open codec\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/* init signal generator */</p><p><code></code>t = 0;</p><p><code></code>tincr = 2 * M_PI * 110.0 / c->sample_rate;</p><p><code></code>/* increment frequency by 110 Hz per second */</p><p><code></code>tincr2 = 2 * M_PI * 110.0 / c->sample_rate / c->sample_rate;</p><p><code></code>audio_outbuf_size = 10000;</p><p><code></code>audio_outbuf = av_malloc(audio_outbuf_size);</p><p><code></code>/* ugly hack for PCM codecs (will be removed ASAP with new PCM</p><p><code></code>support to compute the input frame size in samples */</p><p><code></code>if (c->frame_size &lt;= 1) {</p><p><code></code>audio_input_frame_size = audio_outbuf_size / c->channels;</p><p><code></code>switch(st->codec->codec_id) {</p><p><code></code>case CODEC_ID_PCM_S16LE:</p><p><code></code>case CODEC_ID_PCM_S16BE:</p><p><code></code>case CODEC_ID_PCM_U16LE:</p><p><code></code>case CODEC_ID_PCM_U16BE:</p><p><code></code>audio_input_frame_size >>= 1;</p><p><code></code>break;</p><p><code></code>default:</p><p><code></code>break;</p><p><code></code>}</p><p><code></code>} else {</p><p><code></code>audio_input_frame_size = c->frame_size;</p><p><code></code>}</p><p><code></code>samples = av_malloc(audio_input_frame_size * 2 * c->channels);</p><p>}</p><p>/* prepare a 16 bit dummy audio frame of 'frame_size' samples and</p><p><code></code>'nb_channels' channels */</p><p>static void get_audio_frame(int16_t *samples, int frame_size, int nb_channels)</p><p>{</p><p><code></code>int j, i, v;</p><p><code></code>int16_t *q;</p><p><code></code>q = samples;</p><p><code></code>for(j=0;j&lt;frame_size;j++) {</p><p><code></code>v = (int)(sin(t) * 10000);</p><p><code></code>for(i = 0; i &lt; nb_channels; i++)</p><p><code></code>*q++ = v;</p><p><code></code>t += tincr;</p><p><code></code>tincr += tincr2;</p><p><code></code>}</p><p>}</p><p>static void write_audio_frame(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>AVCodecContext *c;</p><p><code></code>AVPacket pkt;</p><p><code></code>av_init_packet(&pkt);</p><p><code></code>c = st->codec;</p><p><code></code>get_audio_frame(samples, audio_input_frame_size, c->channels);</p><p><code></code>pkt.size= avcodec_encode_audio(c, audio_outbuf, audio_outbuf_size, samples);</p><p><code></code>pkt.pts= av_rescale_q(c->coded_frame->pts, c->time_base, st->time_base);</p><p><code></code>pkt.flags |= PKT_FLAG_KEY;</p><p><code></code>pkt.stream_index= st->index;</p><p><code></code>pkt.data= audio_outbuf;</p><p><code></code>/* write the compressed frame in the media file */</p><p><code></code>if (av_write_frame(oc, &pkt) != 0) {</p><p><code></code>fprintf(stderr, "Error while writing audio frame\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p>}</p><p>static void close_audio(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>avcodec_close(st->codec);</p><p><code></code>av_free(samples);</p><p><code></code>av_free(audio_outbuf);</p><p>}</p><p>/**************************************************************/</p><p>/* video output */</p><p>AVFrame *picture, *tmp_picture;</p><p>uint8_t *video_outbuf;</p><p>int frame_count, video_outbuf_size;</p><p>/* add a video output stream */</p><p>static AVStream *add_video_stream(AVFormatContext *oc, int codec_id)</p><p>{</p><p><code></code>AVCodecContext *c;</p><p><code></code>AVStream *st;</p><p><code></code>st = av_new_stream(oc, 0);</p><p><code></code>if (!st) {</p><p><code></code>fprintf(stderr, "Could not alloc stream\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>c = st->codec;</p><p><code></code>c->codec_id = codec_id;</p><p><code></code>c->codec_type = CODEC_TYPE_VIDEO;</p><p><code></code>/* put sample parameters */</p><p><code></code>c->bit_rate = 400000;</p><p><code></code>/* resolution must be a multiple of two */</p><p><code></code>c->width = 352;</p><p><code></code>c->height = 288;</p><p><code></code>/* time base: this is the fundamental unit of time (in seconds) in terms</p><p><code></code>of which frame timestamps are represented. for fixed-fps content,</p><p><code></code>timebase should be 1/framerate and timestamp increments should be</p><p><code></code>identically 1. */</p><p><code></code>c->time_base.den = STREAM_FRAME_RATE;</p><p><code></code>c->time_base.num = 1;</p><p><code></code>c->gop_size = 12; /* emit one intra frame every twelve frames at most */</p><p><code></code>c->pix_fmt = STREAM_PIX_FMT;</p><p><code></code>if (c->codec_id == CODEC_ID_MPEG2VIDEO) {</p><p><code></code>/* just for testing, we also add B frames */</p><p><code></code>c->max_b_frames = 2;</p><p><code></code>}</p><p><code></code>if (c->codec_id == CODEC_ID_MPEG1VIDEO){</p><p><code></code>/* Needed to avoid using macroblocks in which some coeffs overflow.</p><p><code></code>This does not happen with normal video, it just happens here as</p><p><code></code>the motion of the chroma plane does not match the luma plane. */</p><p><code></code>c->mb_decision=2;</p><p><code></code>}</p><p><code></code>// some formats want stream headers to be separate</p><p><code></code>if(!strcmp(oc->oformat->name, "mp4") || !strcmp(oc->oformat->name, "mov") || !strcmp(oc->oformat->name, "3gp"))</p><p><code></code>c->flags |= CODEC_FLAG_GLOBAL_HEADER;</p><p><code></code>return st;</p><p>}</p><p>static AVFrame *alloc_picture(int pix_fmt, int width, int height)</p><p>{</p><p><code></code>AVFrame *picture;</p><p><code></code>uint8_t *picture_buf;</p><p><code></code>int size;</p><p><code></code>picture = avcodec_alloc_frame();</p><p><code></code>if (!picture)</p><p><code></code>return NULL;</p><p><code></code>size = avpicture_get_size(pix_fmt, width, height);</p><p><code></code>picture_buf = av_malloc(size);</p><p><code></code>if (!picture_buf) {</p><p><code></code>av_free(picture);</p><p><code></code>return NULL;</p><p><code></code>}</p><p><code></code>avpicture_fill((AVPicture *)picture, picture_buf,</p><p><code></code>pix_fmt, width, height);</p><p><code></code>return picture;</p><p>}</p><p>static void open_video(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>AVCodec *codec;</p><p><code></code>AVCodecContext *c;</p><p><code></code>c = st->codec;</p><p><code></code>/* find the video encoder */</p><p><code></code>codec = avcodec_find_encoder(c->codec_id);</p><p><code></code>if (!codec) {</p><p><code></code>fprintf(stderr, "codec not found\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/* open the codec */</p><p><code></code>if (avcodec_open(c, codec) &lt; 0) {</p><p><code></code>fprintf(stderr, "could not open codec\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>video_outbuf = NULL;</p><p><code></code>if (!(oc->oformat->flags & AVFMT_RAWPICTURE)) {</p><p><code></code>/* allocate output buffer */</p><p><code></code>/* XXX: API change will be done */</p><p><code></code>/* buffers passed into lav* can be allocated any way you prefer,</p><p><code></code>as long as they're aligned enough for the architecture, and</p><p><code></code>they're freed appropriately (such as using av_free for buffers</p><p><code></code>allocated with av_malloc) */</p><p><code></code>video_outbuf_size = 200000;</p><p><code></code>video_outbuf = av_malloc(video_outbuf_size);</p><p><code></code>}</p><p><code></code>/* allocate the encoded raw picture */</p><p><code></code>picture = alloc_picture(c->pix_fmt, c->width, c->height);</p><p><code></code>if (!picture) {</p><p><code></code>fprintf(stderr, "Could not allocate picture\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/* if the output format is not YUV420P, then a temporary YUV420P</p><p><code></code>picture is needed too. It is then converted to the required</p><p><code></code>output format */</p><p><code></code>tmp_picture = NULL;</p><p><code></code>if (c->pix_fmt != PIX_FMT_YUV420P) {</p><p><code></code>tmp_picture = alloc_picture(PIX_FMT_YUV420P, c->width, c->height);</p><p><code></code>if (!tmp_picture) {</p><p><code></code>fprintf(stderr, "Could not allocate temporary picture\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>}</p><p>}</p><p>/* prepare a dummy image */</p><p>static void fill_yuv_image(AVFrame *pict, int frame_index, int width, int height)</p><p>{</p><p><code></code>int x, y, i;</p><p><code></code>i = frame_index;</p><p><code></code>/* Y */</p><p><code></code>for(y=0;y&lt;height;y++) {</p><p><code></code>for(x=0;x&lt;width;x++) {</p><p><code></code>pict->data[0][y * pict->linesize[0] + x] = x + y + i * 3;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* Cb and Cr */</p><p><code></code>for(y=0;y&lt;height/2;y++) {</p><p><code></code>for(x=0;x&lt;width/2;x++) {</p><p><code></code>pict->data[1][y * pict->linesize[1] + x] = 128 + y + i * 2;</p><p><code></code>pict->data[2][y * pict->linesize[2] + x] = 64 + x + i * 5;</p><p><code></code>}</p><p><code></code>}</p><p>}</p><p>static void write_video_frame(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>int out_size, ret;</p><p><code></code>AVCodecContext *c;</p><p><code></code>static struct SwsContext *img_convert_ctx;</p><p><code></code>c = st->codec;</p><p><code></code>if (frame_count >= STREAM_NB_FRAMES) {</p><p><code></code>/* no more frame to compress. The codec has a latency of a few</p><p><code></code>frames if using B frames, so we get the last frames by</p><p><code></code>passing the same picture again */</p><p><code></code>} else {</p><p><code></code>if (c->pix_fmt != PIX_FMT_YUV420P) {</p><p><code></code>/* as we only generate a YUV420P picture, we must convert it</p><p><code></code>to the codec pixel format if needed */</p><p><code></code>if (img_convert_ctx == NULL) {</p><p><code></code>img_convert_ctx = sws_getContext(c->width, c->height,</p><p><code></code>PIX_FMT_YUV420P,</p><p><code></code>c->width, c->height,</p><p><code></code>c->pix_fmt,</p><p><code></code>sws_flags, NULL, NULL, NULL);</p><p><code></code>if (img_convert_ctx == NULL) {</p><p><code></code>fprintf(stderr, "Cannot initialize the conversion context\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>fill_yuv_image(tmp_picture, frame_count, c->width, c->height);</p><p><code></code>sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,</p><p><code></code>0, c->height, picture->data, picture->linesize);</p><p><code></code>} else {</p><p><code></code>fill_yuv_image(picture, frame_count, c->width, c->height);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (oc->oformat->flags & AVFMT_RAWPICTURE) {</p><p><code></code>/* raw video case. The API will change slightly in the near</p><p><code></code>futur for that */</p><p><code></code>AVPacket pkt;</p><p><code></code>av_init_packet(&pkt);</p><p><code></code>pkt.flags |= PKT_FLAG_KEY;</p><p><code></code>pkt.stream_index= st->index;</p><p><code></code>pkt.data= (uint8_t *)picture;</p><p><code></code>pkt.size= sizeof(AVPicture);</p><p><code></code>ret = av_write_frame(oc, &pkt);</p><p><code></code>} else {</p><p><code></code>/* encode the image */</p><p><code></code>out_size = avcodec_encode_video(c, video_outbuf, video_outbuf_size, picture);</p><p><code></code>/* if zero size, it means the image was buffered */</p><p><code></code>if (out_size > 0) {</p><p><code></code>AVPacket pkt;</p><p><code></code>av_init_packet(&pkt);</p><p><code></code>pkt.pts= av_rescale_q(c->coded_frame->pts, c->time_base, st->time_base);</p><p><code></code>if(c->coded_frame->key_frame)</p><p><code></code>pkt.flags |= PKT_FLAG_KEY;</p><p><code></code>pkt.stream_index= st->index;</p><p><code></code>pkt.data= video_outbuf;</p><p><code></code>pkt.size= out_size;</p><p><code></code>/* write the compressed frame in the media file */</p><p><code></code>ret = av_write_frame(oc, &pkt);</p><p><code></code>} else {</p><p><code></code>ret = 0;</p><p><code></code>}</p><p><code></code>}</p><p><code></code>if (ret != 0) {</p><p><code></code>fprintf(stderr, "Error while writing video frame\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>frame_count++;</p><p>}</p><p>static void close_video(AVFormatContext *oc, AVStream *st)</p><p>{</p><p><code></code>avcodec_close(st->codec);</p><p><code></code>av_free(picture->data[0]);</p><p><code></code>av_free(picture);</p><p><code></code>if (tmp_picture) {</p><p><code></code>av_free(tmp_picture->data[0]);</p><p><code></code>av_free(tmp_picture);</p><p><code></code>}</p><p><code></code>av_free(video_outbuf);</p><p>}</p><p>/**************************************************************/</p><p>/* media file output */</p><p>int main(int argc, char **argv)</p><p>{</p><p><code></code>const char *filename;</p><p><code></code>AVOutputFormat *fmt;</p><p><code></code>AVFormatContext *oc;</p><p><code></code>AVStream *audio_st, *video_st;</p><p><code></code>double audio_pts, video_pts;</p><p><code></code>int i;</p><p><code></code>/* initialize libavcodec, and register all codecs and formats */</p><p><code></code>av_register_all();</p><p><code></code>if (argc != 2) {</p><p><code></code>printf("usage: %s output_file\n"</p><p><code></code>"API example program to output a media file with libavformat.\n"</p><p><code></code>"The output format is automatically guessed according to the file extension.\n"</p><p><code></code>"Raw images can also be output by using '%%d' in the filename\n"</p><p><code></code>"\n", argv[0]);</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>filename = argv[1];</p><p><code></code>/* auto detect the output format from the name. default is</p><p><code></code>mpeg. */</p><p><code></code>fmt = guess_format(NULL, filename, NULL);</p><p><code></code>if (!fmt) {</p><p><code></code>printf("Could not deduce output format from file extension: using MPEG.\n");</p><p><code></code>fmt = guess_format("mpeg", NULL, NULL);</p><p><code></code>}</p><p><code></code>if (!fmt) {</p><p><code></code>fprintf(stderr, "Could not find suitable output format\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>/* allocate the output media context */</p><p><code></code>oc = av_alloc_format_context();</p><p><code></code>if (!oc) {</p><p><code></code>fprintf(stderr, "Memory error\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>oc->oformat = fmt;</p><p><code></code>snprintf(oc->filename, sizeof(oc->filename), "%s", filename);</p><p><code></code>/* add the audio and video streams using the default format codecs</p><p><code></code>and initialize the codecs */</p><p><code></code>video_st = NULL;</p><p><code></code>audio_st = NULL;</p><p><code></code>if (fmt->video_codec != CODEC_ID_NONE) {</p><p><code></code>video_st = add_video_stream(oc, fmt->video_codec);</p><p><code></code>}</p><p><code></code>if (fmt->audio_codec != CODEC_ID_NONE) {</p><p><code></code>audio_st = add_audio_stream(oc, fmt->audio_codec);</p><p><code></code>}</p><p><code></code>/* set the output parameters (must be done even if no</p><p><code></code>parameters). */</p><p><code></code>if (av_set_parameters(oc, NULL) &lt; 0) {</p><p><code></code>fprintf(stderr, "Invalid output format parameters\n");</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>dump_format(oc, 0, filename, 1);</p><p><code></code>/* now that all the parameters are set, we can open the audio and</p><p><code></code>video codecs and allocate the necessary encode buffers */</p><p><code></code>if (video_st)</p><p><code></code>open_video(oc, video_st);</p><p><code></code>if (audio_st)</p><p><code></code>open_audio(oc, audio_st);</p><p><code></code>/* open the output file, if needed */</p><p><code></code>if (!(fmt->flags & AVFMT_NOFILE)) {</p><p><code></code>if (url_fopen(&oc->pb, filename, URL_WRONLY) &lt; 0) {</p><p><code></code>fprintf(stderr, "Could not open '%s'\n", filename);</p><p><code></code>exit(1);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* write the stream header, if any */</p><p><code></code>av_write_header(oc);</p><p><code></code>for(;;) {</p><p><code></code>/* compute current audio and video time */</p><p><code></code>if (audio_st)</p><p><code></code>audio_pts = (double)audio_st->pts.val * audio_st->time_base.num / audio_st->time_base.den;</p><p><code></code>else</p><p><code></code>audio_pts = 0.0;</p><p><code></code>if (video_st)</p><p><code></code>video_pts = (double)video_st->pts.val * video_st->time_base.num / video_st->time_base.den;</p><p><code></code>else</p><p><code></code>video_pts = 0.0;</p><p><code></code>if ((!audio_st || audio_pts >= STREAM_DURATION) &&</p><p><code></code>(!video_st || video_pts >= STREAM_DURATION))</p><p><code></code>break;</p><p><code></code>/* write interleaved audio and video frames */</p><p><code></code>if (!video_st || (video_st && audio_st && audio_pts &lt; video_pts)) {</p><p><code></code>write_audio_frame(oc, audio_st);</p><p><code></code>} else {</p><p><code></code>write_video_frame(oc, video_st);</p><p><code></code>}</p><p><code></code>}</p><p><code></code>/* close each codec */</p><p><code></code>if (video_st)</p><p><code></code>close_video(oc, video_st);</p><p><code></code>if (audio_st)</p><p><code></code>close_audio(oc, audio_st);</p><p><code></code>/* write the trailer, if any */</p><p><code></code>av_write_trailer(oc);</p><p><code></code>/* free the streams */</p><p><code></code>for(i = 0; i &lt; oc->nb_streams; i++) {</p><p><code></code>av_freep(&oc->streams[i]->codec);</p><p><code></code>av_freep(&oc->streams[i]);</p><p><code></code>}</p><p><code></code>if (!(fmt->flags & AVFMT_NOFILE)) {</p><p><code></code>/* close the output file */</p><p><code></code>url_fclose(&oc->pb);</p><p><code></code>}</p><p><code></code>/* free the stream */</p><p><code></code>av_free(oc);</p><p><code></code>return 0;</p><p>}</p><h1 id=附录cffmpeg参数中文详细解释><strong>附录c：ffmpeg参数中文详细解释</strong></h1><p><strong>a) 通用选项</strong></p><p>-L license</p><p>-h 帮助</p><p>-fromats 显示可用的格式，编解码的，协议的...</p><p>-f fmt 强迫采用格式fmt</p><p>-I filename 输入文件</p><p>-y 覆盖输出文件</p><p>-t duration 设置纪录时间 hh:mm:ss[.xxx]格式的记录时间也支持</p><p>-ss position 搜索到指定的时间 [-]hh:mm:ss[.xxx]的格式也支持</p><p>-title string 设置标题</p><p>-author string 设置作者</p><p>-copyright string 设置版权</p><p>-comment string 设置评论</p><p>-target type 设置目标文件类型(vcd,svcd,dvd) 所有的格式选项（比特率，编解码以及缓冲区大小）自动设置，只需要输入如下的就可以了：ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg</p><p>-hq 激活高质量设置</p><p>-itsoffset offset 设置以秒为基准的时间偏移，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持</p><p><strong>b) 视频选项</strong></p><p>-b bitrate 设置比特率，缺省200kb/s</p><p>-r fps 设置帧频 缺省25</p><p>-s size 设置帧大小 格式为WXH 缺省160X128.下面的简写也可以直接使用：</p><p>Sqcif 128X96 qcif 176X144 cif 252X288 4cif 704X576</p><p>-aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777</p><p>-croptop size 设置顶部切除带大小 像素单位</p><p>-cropbottom size –cropleft size –cropright size</p><p>-padtop size 设置顶部补齐的大小 像素单位</p><p>-padbottom size –padleft size –padright size –padcolor color 设置补齐条颜色(hex,6个16进制的数，红:绿:兰排列，比如 000000代表黑色)</p><p>-vn 不做视频记录</p><p>-bt tolerance 设置视频码率容忍度kbit/s</p><p>-maxrate bitrate设置最大视频码率容忍度</p><p>-minrate bitreate 设置最小视频码率容忍度</p><p>-bufsize size 设置码率控制缓冲区大小</p><p>-vcodec codec 强制使用codec编解码方式。如果用copy表示原始编解码数据必须被拷贝。</p><p>-sameq 使用同样视频质量作为源（VBR）</p><p>-pass n 选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率</p><p>-passlogfile file 选择两遍的纪录文件名为file</p><p><strong>c)高级视频选项</strong></p><p>-g gop_size 设置图像组大小</p><p>-intra 仅适用帧内编码</p><p>-qscale q 使用固定的视频量化标度(VBR)</p><p>-qmin q 最小视频量化标度(VBR)</p><p>-qmax q 最大视频量化标度(VBR)</p><p>-qdiff q 量化标度间最大偏差 (VBR)</p><p>-qblur blur 视频量化标度柔化(VBR)</p><p>-qcomp compression 视频量化标度压缩(VBR)</p><p>-rc_init_cplx complexity 一遍编码的初始复杂度</p><p>-b_qfactor factor 在p和b帧间的qp因子</p><p>-i_qfactor factor 在p和i帧间的qp因子</p><p>-b_qoffset offset 在p和b帧间的qp偏差</p><p>-i_qoffset offset 在p和i帧间的qp偏差</p><p>-rc_eq equation 设置码率控制方程 默认tex^qComp</p><p>-rc_override override 特定间隔下的速率控制重载</p><p>-me method 设置运动估计的方法 可用方法有 zero phods log x1 epzs(缺省) full</p><p>-dct_algo algo 设置dct的算法 可用的有 0 FF_DCT_AUTO 缺省的DCT 1 FF_DCT_FASTINT 2 FF_DCT_INT 3 FF_DCT_MMX 4 FF_DCT_MLIB 5 FF_DCT_ALTIVEC</p><p>-idct_algo algo 设置idct算法。可用的有 0 FF_IDCT_AUTO 缺省的IDCT 1 FF_IDCT_INT 2 FF_IDCT_SIMPLE 3 FF_IDCT_SIMPLEMMX 4 FF_IDCT_LIBMPEG2MMX 5 FF_IDCT_PS2 6 FF_IDCT_MLIB 7 FF_IDCT_ARM 8 FF_IDCT_ALTIVEC 9 FF_IDCT_SH4 10 FF_IDCT_SIMPLEARM</p><p>-er n 设置错误残留为n 1 FF_ER_CAREFULL 缺省 2 FF_ER_COMPLIANT 3 FF_ER_AGGRESSIVE 4 FF_ER_VERY_AGGRESSIVE</p><p>-ec bit_mask 设置错误掩蔽为bit_mask,该值为如下值的位掩码 1 FF_EC_GUESS_MVS (default=enabled) 2 FF_EC_DEBLOCK (default=enabled)</p><p>-bf frames 使用frames B 帧，支持mpeg1,mpeg2,mpeg4</p><p>-mbd mode 宏块决策 0 FF_MB_DECISION_SIMPLE 使用mb_cmp 1 FF_MB_DECISION_BITS 2 FF_MB_DECISION_RD</p><p>-4mv 使用4个运动矢量 仅用于mpeg4</p><p>-part 使用数据划分 仅用于mpeg4</p><p>-bug param 绕过没有被自动监测到编码器的问题</p><p>-strict strictness 跟标准的严格性</p><p>-aic 使能高级帧内编码 h263+</p><p>-umv 使能无限运动矢量 h263+</p><p>-deinterlace 不采用交织方法</p><p>-interlace 强迫交织法编码仅对mpeg2和mpeg4有效。当你的输入是交织的并且你想要保持交织以最小图像损失的时候采用该选项。可选的方法是不交织，但是损失更大</p><p>-psnr 计算压缩帧的psnr</p><p>-vstats 输出视频编码统计到vstats_hhmmss.log</p><p>-vhook module 插入视频处理模块 module 包括了模块名和参数，用空格分开</p><p><strong>D)音频选项</strong></p><p>-ab bitrate 设置音频码率</p><p>-ar freq 设置音频采样率</p><p>-ac channels 设置通道 缺省为1</p><p>-an 不使能音频纪录</p><p>-acodec codec 使用codec编解码</p><p><strong>E)音频/视频捕获选项</strong></p><p>-vd device 设置视频捕获设备。比如/dev/video0</p><p>-vc channel 设置视频捕获通道 DV1394专用</p><p>-tvstd standard 设置电视标准 NTSC PAL(SECAM)</p><p>-dv1394 设置DV1394捕获</p><p>-av device 设置音频设备 比如/dev/dsp</p><p><strong>F)高级选项</strong></p><p>-map file:stream 设置输入流映射</p><p>-debug 打印特定调试信息</p><p>-benchmark 为基准测试加入时间</p><p>-hex 倾倒每一个输入包</p><p>-bitexact 仅使用位精确算法 用于编解码测试</p><p>-ps size 设置包大小，以bits为单位</p><p>-re 以本地帧频读数据，主要用于模拟捕获设备</p><p>-loop 循环输入流（只工作于图像流，用于ffserver测试）</p><h1 id=附录dffplay的快捷键以及选项httpblogcsdnnetleixiaohua1020articledetails15186441><strong>附录D：<a href=http://blog.csdn.net/leixiaohua1020/article/details/15186441>ffplay的快捷键以及选项**</a></strong></h1><p>ffplay是ffmpeg工程中提供的播放器，功能相当的强大，凡是ffmpeg支持的视音频格式它基本上都支持。甚至连VLC不支持的一些流媒体都可以播放（比如说RTMP），但是它的缺点是其不是图形化界面的，必须通过键盘来操作。因此本文介绍一下它的快捷键以及选项。</p><p>快捷键</p><p><code></code>播放视音频文件的时候，可以通过下列按键控制视音频的播放</p><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>q, ESC</td><td>退出</td></tr><tr><td>F</td><td>全屏</td></tr><tr><td>p,空格</td><td>暂停</td></tr><tr><td>w</td><td>显示音频波形</td></tr><tr><td>s</td><td>逐帧显示</td></tr><tr><td>左/右方向键</td><td>向后/前10s</td></tr><tr><td>上/下方向键</td><td>向后/前1min</td></tr><tr><td>page down/page up</td><td>向后/前10min</td></tr><tr><td>鼠标点击屏幕</td><td>跳转到指定位置（根据鼠标位置相对屏幕的宽度计算）</td></tr><tr><td>选项</td><td></td></tr></tbody></table><p>在播放视频前，可以预设一些参数。</p><p>一般播放视频的时候，使用命令：</p><p>#ffplay "abc.flv"</p><p>如果我们希望能在播放完成后自动退出，则可以使用命令：</p><p>ffplay -autoexit "abc.flv";</p><p>所有的命令如下列表所示：</p><table><thead><tr><th>名称</th><th>有参数</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>Y</td><td>强制屏幕宽度</td></tr><tr><td>y</td><td>Y</td><td>强制屏幕高度</td></tr><tr><td>s</td><td>Y</td><td>强制屏幕大小</td></tr><tr><td>fs</td><td>N</td><td>全屏</td></tr><tr><td>an</td><td>N</td><td>关闭音频</td></tr><tr><td>vn</td><td>N</td><td>关闭视频</td></tr><tr><td>ast</td><td>Y</td><td>设置想播放的音频流（需要指定流ID）</td></tr><tr><td>vst</td><td>Y</td><td>设置想播放的视频流（需要指定流ID）</td></tr><tr><td>sst</td><td>Y</td><td>设置想播放的字幕流（需要指定流ID）</td></tr><tr><td>ss</td><td>Y</td><td>从指定位置开始播放，单位是秒</td></tr><tr><td>t</td><td>Y</td><td>播放指定时长的视频</td></tr><tr><td>nodisp</td><td>N</td><td>无显示屏幕</td></tr><tr><td>f</td><td>Y</td><td>强制封装格式</td></tr><tr><td>pix_fmt</td><td>Y</td><td>指定像素格式</td></tr><tr><td>stats</td><td>N</td><td>显示统计信息</td></tr><tr><td>idct</td><td>Y</td><td>IDCT算法</td></tr><tr><td>ec</td><td>Y</td><td>错误隐藏方法</td></tr><tr><td>sync</td><td>Y</td><td>视音频同步方式（type=audio/video/ext）</td></tr><tr><td>autoexit</td><td>N</td><td>播放完成自动退出</td></tr><tr><td>exitonkeydown</td><td>N</td><td>按下按键退出</td></tr><tr><td>exitonmousedown</td><td>N</td><td>按下鼠标退出</td></tr><tr><td>loop</td><td>Y</td><td>指定循环次数</td></tr><tr><td>framedrop</td><td>N</td><td>CPU不够的时候丢帧</td></tr><tr><td>window_title</td><td>Y</td><td>显示窗口的标题</td></tr><tr><td>rdftspeed</td><td>Y</td><td>Rdft速度</td></tr><tr><td>showmode</td><td>Y</td><td>显示方式(0 = video, 1 = waves, 2 = RDFT)</td></tr><tr><td>codec</td><td>Y</td><td>强制解码器</td></tr></tbody></table><h1 id=附录e-ffmpeg处理rtmp流媒体><strong>附录E： ffmpeg处理rtmp流媒体</strong></h1><p>1、将文件当做直播送至live</p><p>ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp://server/live/streamName</p><p>2、将直播媒体保存至本地文件</p><p>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</p><p>3、将其中一个直播流，视频改用h264压缩，音频不变，送至另外一个直播服务流</p><p>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream</p><p>4、将其中一个直播流，视频改用h264压缩，音频改用faac压缩，送至另外一个直播服务流</p><p>ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream</p><p>5、将其中一个直播流，视频不变，音频改用faac压缩，送至另外一个直播服务流</p><p>ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream</p><p>6、将一个高清流，复制为几个不同视频清晰度的流重新发布，其中音频不变</p><p>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k</p><p>7、功能一样，只是采用-x264opts选项</p><p>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -c:a copy -c:v x264lib -s 640×360 -x264opts bitrate=500:profile=baseline:preset=slow rtmp://server/live/baseline_500k -c:a copy -c:v x264lib -s 480×272 -x264opts bitrate=300:profile=baseline:preset=slow rtmp://server/live/baseline_300k -c:a copy -c:v x264lib -s 320×200 -x264opts bitrate=150:profile=baseline:preset=slow rtmp://server/live/baseline_150k -c:a libfaac -vn -b:a 48k rtmp://server/live/audio_only_AAC_48k</p><p>8、将当前摄像头及音频通过DSSHOW采集，视频h264、音频faac压缩后发布</p><p>ffmpeg -r 25 -f dshow -s 640×480 -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b 600k -vpre slow -acodec libfaac -ab 128k rtmp://server/application/stream_name</p><p>9、将一个JPG图片经过h264压缩循环输出为mp4视频</p><p>ffmpeg.exe -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4</p><p>10、将普通流视频改用h264压缩，音频不变，送至高清流服务(新版本FMS live=1)</p><p>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv “rtmp://server/live/h264Stream live=1″</p></article><aside class=sidebar><section class=sidebar_inner><div class=author_header><img src=https://b9aobj.github.io/logos/4596723.png alt="Alin.Zhong photo"><h2>Alin.Zhong</h2></div><div class=author_bio>React前端/IOS<br>邮箱：zhongxilin@gmail.com<br>QQ：413232030</div><a href=https://b9aobj.github.io/about/ class="button mt-1" role=button title=阅读更多>阅读更多</a><h2 class=mt-4>精选文章</h2><ul><li><a href=https://b9aobj.github.io/post/zh-cn/2021/jswebrtc%E6%96%87%E6%A1%A3/ class=nav-link title=JsWebrtc文档>JsWebrtc文档</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E6%88%91%E6%83%B3%E5%9C%A8gitlabe%E7%94%A8cicd%E9%83%A8%E7%BD%B2/ class=nav-link title=我想在gitlab用CI/CD部署>我想在gitlab用CI/CD部署</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2020/cas%E6%8E%A5%E5%85%A5/ class=nav-link title=Cas接入>Cas接入</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/chrome%E7%9A%84console%E8%B0%83%E8%AF%95/ class=nav-link title=Chrome的console调试>Chrome的console调试</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%9F%E6%B4%BB%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B9%A0%E6%83%AF%E7%AF%87/ class=nav-link title=改变自己的生活系列之习惯篇>改变自己的生活系列之习惯篇</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E9%83%A8%E5%88%86%E4%B8%93%E4%B8%9A%E8%8B%B1%E6%96%87%E6%9C%AF%E8%AF%AD/ class=nav-link title=部分专业英文术语>部分专业英文术语</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/zhongwenzhengze/ class=nav-link title=中文匹配>中文匹配</a></li><li><a href=https://b9aobj.github.io/post/markdown-syntax/ class=nav-link title="Markdown Syntax Guide">Markdown Syntax Guide</a></li></ul><h2 class=mt-4>最新文章</h2><ul class=flex-column><li><a href=https://b9aobj.github.io/post/zh-cn/2021/jswebrtc%E6%96%87%E6%A1%A3/ class=nav-link title=JsWebrtc文档>JsWebrtc文档</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E6%88%91%E6%83%B3%E5%9C%A8gitlabe%E7%94%A8cicd%E9%83%A8%E7%BD%B2/ class=nav-link title=我想在gitlab用CI/CD部署>我想在gitlab用CI/CD部署</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2020/cas%E6%8E%A5%E5%85%A5/ class=nav-link title=Cas接入>Cas接入</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/chrome%E7%9A%84console%E8%B0%83%E8%AF%95/ class=nav-link title=Chrome的console调试>Chrome的console调试</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%9F%E6%B4%BB%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B9%A0%E6%83%AF%E7%AF%87/ class=nav-link title=改变自己的生活系列之习惯篇>改变自己的生活系列之习惯篇</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/%E9%83%A8%E5%88%86%E4%B8%93%E4%B8%9A%E8%8B%B1%E6%96%87%E6%9C%AF%E8%AF%AD/ class=nav-link title=部分专业英文术语>部分专业英文术语</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2021/zhongwenzhengze/ class=nav-link title=中文匹配>中文匹配</a></li><li><a href=https://b9aobj.github.io/post/zh-cn/2017/2017-10-20-li-yong-live555zai-macduan-da-jian-rtsptui-liu/ class=nav-link title=利用live555在Mac端搭建rtsp推流>利用live555在Mac端搭建rtsp推流</a></li></ul><div><h2 class="mt-4 taxonomy" id=categories-section>分类</h2><nav class=tags_nav><a href=https://b9aobj.github.io/categories/ios/ class="post_tag button button_translucent" title=ios>IOS
<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/categories/xcode/ class="post_tag button button_translucent" title=xcode>XCODE
<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/categories/octopress/ class="post_tag button button_translucent" title=octopress>OCTOPRESS
<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/categories/git/ class="post_tag button button_translucent" title=git>GIT
<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/categories/swift/ class="post_tag button button_translucent" title=swift>SWIFT
<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/categories/cas/ class="post_tag button button_translucent" title=cas>CAS
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/chrome/ class="post_tag button button_translucent" title=chrome>CHROME
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/ffmpeg/ class="post_tag button button_translucent" title=ffmpeg>FFMPEG
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/instruments/ class="post_tag button button_translucent" title=instruments>INSTRUMENTS
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/javascript/ class="post_tag button button_translucent" title=javascript>JAVASCRIPT
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/live/ class="post_tag button button_translucent" title=live>LIVE
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/mac/ class="post_tag button button_translucent" title=mac>MAC
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/markdown/ class="post_tag button button_translucent" title=markdown>MARKDOWN
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/playground/ class="post_tag button button_translucent" title=playground>PLAYGROUND
<span class=button_tally>1</span></a><br><div class="post_tags_toggle button">所有分类</div><div class=post_tags><div class=tags_list><a href=https://b9aobj.github.io/categories/cas/ class="post_tag button button_translucent" data-position=1 title=cas>CAS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/chrome/ class="post_tag button button_translucent" data-position=1 title=chrome>CHROME<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/ffmpeg/ class="post_tag button button_translucent" data-position=1 title=ffmpeg>FFMPEG<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/git/ class="post_tag button button_translucent" data-position=2 title=git>GIT<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/categories/instruments/ class="post_tag button button_translucent" data-position=1 title=instruments>INSTRUMENTS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/ios/ class="post_tag button button_translucent" data-position=5 title=ios>IOS<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/categories/javascript/ class="post_tag button button_translucent" data-position=1 title=javascript>JAVASCRIPT<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/live/ class="post_tag button button_translucent" data-position=1 title=live>LIVE<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/mac/ class="post_tag button button_translucent" data-position=1 title=mac>MAC<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/markdown/ class="post_tag button button_translucent" data-position=1 title=markdown>MARKDOWN<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/octopress/ class="post_tag button button_translucent" data-position=3 title=octopress>OCTOPRESS<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/categories/playground/ class="post_tag button button_translucent" data-position=1 title=playground>PLAYGROUND<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/swift/ class="post_tag button button_translucent" data-position=2 title=swift>SWIFT<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/categories/syntax/ class="post_tag button button_translucent" data-position=1 title=syntax>SYNTAX<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/technology/ class="post_tag button button_translucent" data-position=1 title=technology>TECHNOLOGY<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/themes/ class="post_tag button button_translucent" data-position=1 title=themes>THEMES<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/uiwebview/ class="post_tag button button_translucent" data-position=1 title=uiwebview>UIWEBVIEW<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/xcode/ class="post_tag button button_translucent" data-position=5 title=xcode>XCODE<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/categories/%E5%B7%A5%E4%BD%9C/ class="post_tag button button_translucent" data-position=1 title=工作>工作<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/%E6%80%BB%E7%BB%93/ class="post_tag button button_translucent" data-position=1 title=总结>总结<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/%E7%94%9F%E6%B4%BB/ class="post_tag button button_translucent" data-position=1 title=生活>生活<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/categories/%E9%9D%A2%E8%AF%95/ class="post_tag button button_translucent" data-position=1 title=面试>面试<span class=button_tally>1</span></a><div class=tags_sort><span title="sort alphabetically">[A~Z]</span><span title="sort by count">[0~9]</span></div><span class=tags_hide><svg class="icon"><use xlink:href="#closeme"/></svg></span></div></div></nav></div><div><h2 class="mt-4 taxonomy" id=series-section>专栏</h2><nav class=tags_nav><a href=https://b9aobj.github.io/series/themes-guide/ class="post_tag button button_translucent" title=themes-guide>THEMES-GUIDE
<span class=button_tally>1</span></a></nav></div><div><h2 class="mt-4 taxonomy" id=tags-section>标签</h2><nav class=tags_nav><a href=https://b9aobj.github.io/tags/ios/ class="post_tag button button_translucent" title=ios>IOS
<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/tags/xcode/ class="post_tag button button_translucent" title=xcode>XCODE
<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/tags/markdown/ class="post_tag button button_translucent" title=markdown>MARKDOWN
<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/tags/octopress/ class="post_tag button button_translucent" title=octopress>OCTOPRESS
<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/tags/git/ class="post_tag button button_translucent" title=git>GIT
<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/javascript/ class="post_tag button button_translucent" title=javascript>JAVASCRIPT
<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/swift/ class="post_tag button button_translucent" title=swift>SWIFT
<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/audio/ class="post_tag button button_translucent" title=audio>AUDIO
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/cas/ class="post_tag button button_translucent" title=cas>CAS
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/chrome/ class="post_tag button button_translucent" title=chrome>CHROME
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/ci/cd/ class="post_tag button button_translucent" title=ci/cd>CI/CD
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/console/ class="post_tag button button_translucent" title=console>CONSOLE
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/css/ class="post_tag button button_translucent" title=css>CSS
<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/emoji/ class="post_tag button button_translucent" title=emoji>EMOJI
<span class=button_tally>1</span></a><br><div class="post_tags_toggle button">所有标签</div><div class=post_tags><div class=tags_list><a href=https://b9aobj.github.io/tags/audio/ class="post_tag button button_translucent" data-position=1 title=audio>AUDIO<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/cas/ class="post_tag button button_translucent" data-position=1 title=cas>CAS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/chrome/ class="post_tag button button_translucent" data-position=1 title=chrome>CHROME<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/ci/cd/ class="post_tag button button_translucent" data-position=1 title=ci/cd>CI/CD<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/console/ class="post_tag button button_translucent" data-position=1 title=console>CONSOLE<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/css/ class="post_tag button button_translucent" data-position=1 title=css>CSS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/emoji/ class="post_tag button button_translucent" data-position=1 title=emoji>EMOJI<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/featured/ class="post_tag button button_translucent" data-position=1 title=featured>FEATURED<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/ffmpeg/ class="post_tag button button_translucent" data-position=1 title=ffmpeg>FFMPEG<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/git/ class="post_tag button button_translucent" data-position=2 title=git>GIT<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/gitlab/ class="post_tag button button_translucent" data-position=1 title=gitlab>GITLAB<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/html/ class="post_tag button button_translucent" data-position=1 title=html>HTML<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/index/ class="post_tag button button_translucent" data-position=1 title=index>INDEX<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/instruments/ class="post_tag button button_translucent" data-position=1 title=instruments>INSTRUMENTS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/ios/ class="post_tag button button_translucent" data-position=5 title=ios>IOS<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/tags/javascript/ class="post_tag button button_translucent" data-position=2 title=javascript>JAVASCRIPT<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/js/ class="post_tag button button_translucent" data-position=1 title=js>JS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/live/ class="post_tag button button_translucent" data-position=1 title=live>LIVE<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/live555/ class="post_tag button button_translucent" data-position=1 title=live555>LIVE555<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/mac/ class="post_tag button button_translucent" data-position=1 title=mac>MAC<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/markdown/ class="post_tag button button_translucent" data-position=3 title=markdown>MARKDOWN<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/tags/octopress/ class="post_tag button button_translucent" data-position=3 title=octopress>OCTOPRESS<span class=button_tally>3</span></a>
<a href=https://b9aobj.github.io/tags/playground/ class="post_tag button button_translucent" data-position=1 title=playground>PLAYGROUND<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/privacy/ class="post_tag button button_translucent" data-position=1 title=privacy>PRIVACY<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/reg/ class="post_tag button button_translucent" data-position=1 title=reg>REG<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/rtsp/ class="post_tag button button_translucent" data-position=1 title=rtsp>RTSP<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/shortcodes/ class="post_tag button button_translucent" data-position=1 title=shortcodes>SHORTCODES<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/srs/ class="post_tag button button_translucent" data-position=1 title=srs>SRS<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/swift/ class="post_tag button button_translucent" data-position=2 title=swift>SWIFT<span class=button_tally>2</span></a>
<a href=https://b9aobj.github.io/tags/text/ class="post_tag button button_translucent" data-position=1 title=text>TEXT<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/themes/ class="post_tag button button_translucent" data-position=1 title=themes>THEMES<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/uiwebview/ class="post_tag button button_translucent" data-position=1 title=uiwebview>UIWEBVIEW<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/video/ class="post_tag button button_translucent" data-position=1 title=video>VIDEO<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/webrtc/ class="post_tag button button_translucent" data-position=1 title=webrtc>WEBRTC<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/xcode/ class="post_tag button button_translucent" data-position=5 title=xcode>XCODE<span class=button_tally>5</span></a>
<a href=https://b9aobj.github.io/tags/%E4%B8%AD%E6%96%87/ class="post_tag button button_translucent" data-position=1 title=中文>中文<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/%E5%B7%A5%E4%BD%9C/ class="post_tag button button_translucent" data-position=1 title=工作>工作<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/%E7%94%9F%E6%B4%BB/ class="post_tag button button_translucent" data-position=1 title=生活>生活<span class=button_tally>1</span></a>
<a href=https://b9aobj.github.io/tags/%E9%9D%A2%E8%AF%95/ class="post_tag button button_translucent" data-position=1 title=面试>面试<span class=button_tally>1</span></a><div class=tags_sort><span title="sort alphabetically">[A~Z]</span><span title="sort by count">[0~9]</span></div><span class=tags_hide><svg class="icon"><use xlink:href="#closeme"/></svg></span></div></div></nav></div></section></aside></div></main><svg width="0" height="0" class="hidden"><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter"><path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68.0 01-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043.0-1.924.366-2.643 1.078A3.56 3.56.0 008.766 5.383c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846.0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47.0.929.273 1.705.82 2.388a3.623 3.623.0 002.115 1.291c-.312.08-.641.118-.979.118-.312.0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652.0 002.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422.0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139.0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77.0 001.172-4.892v-.468a7.788 7.788.0 001.84-1.921 8.142 8.142.0 01-2.11.593z"/></symbol><symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar"><path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916.0 1e2v352c0 33.084 26.916 60 60 60h392c33.084.0 60-26.916 60-60V1e2c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028.0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028.0 20 8.972 20 20v48z"/><path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github"><path d="M255.968 5.329C114.624 5.329.0 120.401.0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384.0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008.0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992.0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584.0 34.368-.32 62.08-.32 70.496.0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab"><path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6.0L12.3 74.8z"/><path d="M12.3 74.7.5 111c-1 3.2.0 6.8 3 8.8l101.6 74-92.5-119z"/><path d="M105 193.7l-38.6-119h-54l92.7 119z"/><path d="M105 193.7l38.7-119H66.4l38.7 119z"/><path d="M105 193.7l38.7-119H198l-93 119z"/><path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/><path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6.0L198 74.8z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss"><circle cx="3.429" cy="20.571" r="3.429"/><path d="M11.429 24h4.57C15.999 15.179 8.821 8.001.0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"/><path d="M24 24C24 10.766 13.234.0.0.0v4.571c10.714.0 19.43 8.714 19.43 19.429z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin"><path d="M437 0H75C33.648.0.0 33.648.0 75v362c0 41.352 33.648 75 75 75h362c41.352.0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="arrow"><path d="M604.501 440.509 325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298.0 36.323s26.223 10.024 36.222.0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221.0 9.999-10.023 9.999-26.298.0-36.323z"/></symbol><symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly"><path d="M504.971 239.029 448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c19.851.0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002.0 004e2 320v108c0 19.851-16.149 36-36 36h-44c-13.255.0-24 10.745-24 24s10.745 24 24 24h44c46.318.0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568.0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255.0 24-10.745 24-24S205.255.0 192 0h-44c-46.318.0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568.0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255.0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851.0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002.0 00112 192z"/></symbol><symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy"><path d="M23 2.75A2.75 2.75.0 0020.25.0H8.75A2.75 2.75.0 006 2.75v13.5A2.75 2.75.0 008.75 19h11.5A2.75 2.75.0 0023 16.25zM18.25 14.5h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5zm0-3h-7.5a.75.75.0 010-1.5h7.5a.75.75.0 010 1.5z"/><path d="M8.75 20.5A4.255 4.255.0 014.5 16.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752.0 001 5.25v16A2.752 2.752.0 003.75 24h12a2.752 2.752.0 002.75-2.75v-.75z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme"><path d="M284.286 256.002 506.143 34.144c7.811-7.811 7.811-20.475.0-28.285-7.811-7.81-20.475-7.811-28.285.0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285.0-7.81 7.811-7.811 20.475.0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475.0 28.285a19.938 19.938.0 0014.143 5.857 19.94 19.94.0 0014.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475.0-28.285L284.286 256.002z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu"><path d="M492 236H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954.0 96s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046.0-20 8.954-20 20s8.954 20 20 20h472c11.046.0 20-8.954 20-20s-8.954-20-20-20z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram"><path d="M12 2.163c3.204.0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849.0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204.0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849.0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741.0 8.333.014 7.053.072c-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948s.014 3.668.072 4.948c.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24s3.668-.014 4.948-.072c4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948s-.014-3.667-.072-4.947c-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403.0-6.162 2.759-6.162 6.162S8.597 18.163 12 18.163s6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zM12 16c-2.209.0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796.0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795.0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="youtube"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23.0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23.0C23.512 20.55 23.971 18.196 24 12c-.029-6.185-.484-8.549-4.385-8.816zM9 16V8l8 3.993L9 16z"/></symbol><symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow"><path d="M21 27v-8h3v11H0V19h3v8h18z"/><path d="M17.1.2 15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8 13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"/></symbol></svg><footer class=footer><div class="footer_inner wrap pale"><img src=https://b9aobj.github.io/logos/apple-touch-icon.png class="icon icon_2 transparent" alt=X•O专业去码><p>Copyright&nbsp;<span class=year></span>&nbsp;X•O专业去码. All Rights Reserved</p><a class=to_top href=#documentTop><svg class="icon"><use xlink:href="#arrow"/></svg></a></div></footer><script type=text/javascript src=https://b9aobj.github.io/js/bundle.min.d0f0362720d4ba914aa22c906d463694ca5445a70923037ec128f108cf4616c6df3dba89902f7d6b8b123a359aaf0485763117871aa780a561c563ed6adfda0e.js integrity="sha512-0PA2JyDUupFKoiyQbUY2lMpURacJIwN+wSjxCM9GFsbfPbqJkC99a4sSOjWarwSFdjEXhxqngKVhxWPtat/aDg==" crossorigin=anonymous></script></body></html>